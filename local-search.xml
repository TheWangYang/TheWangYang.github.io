<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-hot-100</title>
    <link href="/2023/09/17/leetcode-hot-100/"/>
    <url>/2023/09/17/leetcode-hot-100/</url>
    
    <content type="html"><![CDATA[<h2 id="128-最长连续序列（C-使用set实现）"><a href="#128-最长连续序列（C-使用set实现）" class="headerlink" title="128. 最长连续序列（C++使用set实现）"></a>128. 最长连续序列（C++使用set实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//使用set集合实现</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">count</span>(nums[i] - <span class="hljs-number">1</span>))&#123;<span class="hljs-comment">//表示s中没有前一个元素</span><br>                <span class="hljs-type">int</span> curr = nums[i];<br>                <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">count</span>(curr))&#123;<br>                    tmp += <span class="hljs-number">1</span>;<br>                    curr += <span class="hljs-number">1</span>;<br>                &#125;<br>                result = <span class="hljs-built_in">max</span>(result, tmp);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="283-移动零（C-使用快慢指针实现）"><a href="#283-移动零（C-使用快慢指针实现）" class="headerlink" title="283. 移动零（C++使用快慢指针实现）"></a>283. 移动零（C++使用快慢指针实现）</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    void moveZeroes(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        //使用快慢指针<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-number">0</span>;<br><br>        while(<span class="hljs-built_in">right</span> &lt; nums.size())&#123;<br>            <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">right</span>] != <span class="hljs-number">0</span>)&#123;<br>                nums[<span class="hljs-built_in">left</span>] = nums[<span class="hljs-built_in">right</span>];<br>                <span class="hljs-built_in">left</span>++;<br>            &#125;<br>            <span class="hljs-built_in">right</span> ++;<br>        &#125;<br><br><br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">left</span>;i &lt; nums.size();i++)&#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器（C-贪心算法实现）"><a href="#11-盛最多水的容器（C-贪心算法实现）" class="headerlink" title="11. 盛最多水的容器（C++贪心算法实现）"></a>11. 盛最多水的容器（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：使得长方形的宽度更大，高度更宽</span><br>        <span class="hljs-type">int</span> result = INT32_MIN;<br><br>        <span class="hljs-comment">//使用贪心算法</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> w = right - left;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[right], height[left]);<br>            result = <span class="hljs-built_in">max</span>(result, w * h);<br>            <span class="hljs-comment">//尽可能地保留更高的不变</span><br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和（C-去重实现）"><a href="#15-三数之和（C-去重实现）" class="headerlink" title="15. 三数之和（C++去重实现）"></a>15. 三数之和（C++去重实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//思路：需要满足nums[i] + nums[j] + nums[k] == 0</span><br>        <span class="hljs-comment">//那么，等价于：nums[i] + nums[j] = -nums[k]</span><br><br>        <span class="hljs-comment">//首先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br><br>            <span class="hljs-comment">//首先判断首个元素是否大于0，如果是，那么直接break</span><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//使用双指针</span><br>            <span class="hljs-comment">//从i+1开始找</span><br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-comment">//得到三数之和</span><br>                <span class="hljs-type">int</span> tmp = nums[i] + nums[l] + nums[r];<br><br>                <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//去重，将右边相等的元素删除掉</span><br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>])&#123;<br>                        r --;<br>                    &#125;<br><br>                    <span class="hljs-comment">//将左边相等的元素删除掉</span><br>                    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>])&#123;<br>                        l++;<br>                    &#125;<br><br>                    <span class="hljs-comment">//将结果放到result数组中</span><br>                    result.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);<br>                    <span class="hljs-comment">//right --</span><br>                    r--;<br>                    <span class="hljs-comment">//left ++</span><br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//应当r--，使得总和尽可能地减小</span><br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//当tmp &lt; 0的时候，应当left++，使得总和尽可能地增大</span><br>                    l++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串（C-实现，使用set保存当前最长的记录）"><a href="#3-无重复字符的最长子串（C-实现，使用set保存当前最长的记录）" class="headerlink" title="3. 无重复字符的最长子串（C++实现，使用set保存当前最长的记录）"></a>3. 无重复字符的最长子串（C++实现，使用set保存当前最长的记录）</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> lengthOfLongestSubstring(string s) &#123;<br>        //思路：使用set保存当前最长的子串<br><br>        <span class="hljs-built_in">if</span>(s.size() == <span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">if</span>(s.size() == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-number">1</span>;<br>        &#125;<br><br>        unordered_set&lt;<span class="hljs-built_in">char</span>&gt; mySet;<br><br>        //使用双指针实现<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">left</span>;<br>        <br>        <span class="hljs-built_in">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        while(<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span> &amp;&amp; <span class="hljs-built_in">right</span> &lt; s.size())&#123;<br>            <span class="hljs-built_in">if</span>(!mySet.count(s[<span class="hljs-built_in">right</span>]))&#123;<br>                mySet.insert(s[<span class="hljs-built_in">right</span>]);<br>                <span class="hljs-built_in">right</span>++;<br>                result = <span class="hljs-built_in">max</span>(result, <span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>);<br>            &#125;else&#123;//找到了得到set的长度<br>                mySet.erase(s[<span class="hljs-built_in">left</span>]);<br>                <span class="hljs-built_in">left</span>++;<br>            &#125;<br>        &#125;<br><br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组（C-使用前缀和实现）"><a href="#560-和为-K-的子数组（C-使用前缀和实现）" class="headerlink" title="560. 和为 K 的子数组（C++使用前缀和实现）"></a>560. 和为 K 的子数组（C++使用前缀和实现）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> subarraySum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-comment">//思路：使用map记录nums中出现的sum的次数</span><br>        unordered_map&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; keep;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//初始化keep[0] = 1</span><br>        keep[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            result += keep[<span class="hljs-keyword">sum</span> - k];<br>            keep[<span class="hljs-keyword">sum</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和（C-贪心算法实现）"><a href="#53-最大子数组和（C-贪心算法实现）" class="headerlink" title="53. 最大子数组和（C++贪心算法实现）"></a>53. 最大子数组和（C++贪心算法实现）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> result = INT32_MIN;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-keyword">count</span> += nums[i];<br>            <br>            <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-keyword">count</span>)&#123;<br>                result = <span class="hljs-keyword">count</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<span class="hljs-comment">//从i + 1开始</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> result = INT32_MIN;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(auto&amp; it: nums)&#123;<br>            <span class="hljs-keyword">count</span> += it;<br>            result = max(result, <span class="hljs-keyword">count</span>);<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间（C-使用贪心算法实现）"><a href="#56-合并区间（C-使用贪心算法实现）" class="headerlink" title="56. 合并区间（C++使用贪心算法实现）"></a>56. 合并区间（C++使用贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//cmp()函数用于按照区间的左边进行排序</span><br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">//按照区间左边界升序排序</span><br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; merge(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end());<br><br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; result;<br><br>        <span class="hljs-comment">//记录开始区间的左边界和有边界</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//将第一个区间放入到result中</span><br>        result.push_back(<span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-comment">//从index = 1开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">int</span>ervals.size();i++)&#123;<br>            <span class="hljs-comment">//如果当前区间的左边界小于上一个区间的右边界</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;= right)&#123;<br>                <span class="hljs-comment">//定义tmp数组</span><br>                vector&lt;<span class="hljs-built_in">int</span>&gt; tmp;<br>                tmp.push_back(left);<br>                tmp.push_back(max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]));<br>                <span class="hljs-comment">//弹出上一个区间</span><br>                result.pop_back();<br>                <span class="hljs-comment">//将当前区间添加到result中</span><br>                result.push_back(tmp);<br><br>                <span class="hljs-comment">//更新right</span><br>                right = max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//表示当前区间与上一个区间没有交集，直接加入即可</span><br>                result.push_back(<span class="hljs-built_in">int</span>ervals[i]);<br>                <span class="hljs-comment">//更新left和right</span><br>                left = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>                right = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="189-轮转数组（C-复制数组实现）"><a href="#189-轮转数组（C-复制数组实现）" class="headerlink" title="189. 轮转数组（C++复制数组实现）"></a>189. 轮转数组（C++复制数组实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：复制一份nums数组，然后在原地修改nums数组</span><br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; tmpNums = nums;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; tmpNums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//定义一个nums数组的新的index下标</span><br>            <span class="hljs-type">int</span> index = (i + k) % tmpNums.<span class="hljs-built_in">size</span>();<br>            nums[index] = tmpNums[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="238-除自身以外数组的乘积（C-先从左向右进行遍历，然后再从右向左进行遍历）"><a href="#238-除自身以外数组的乘积（C-先从左向右进行遍历，然后再从右向左进行遍历）" class="headerlink" title="238. 除自身以外数组的乘积（C++先从左向右进行遍历，然后再从右向左进行遍历）"></a>238. 除自身以外数组的乘积（C++先从左向右进行遍历，然后再从右向左进行遍历）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：先从左向右进行遍历，累积left *= nums[i]</span><br>        <span class="hljs-comment">//然后，再从右向左进行遍历，累积right *= nums[i]</span><br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//初始化result为1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//从左向右遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            result[i] *= left;<br>            left *= nums[i]; <br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;j &gt;= <span class="hljs-number">0</span>;j--)&#123;<br>            result[j] *= right;<br>            right *= nums[j];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="41-缺失的第一个正数（C-实现，先对nums数组进行排序，然后使用map去重，之后分多种情况进行判断）"><a href="#41-缺失的第一个正数（C-实现，先对nums数组进行排序，然后使用map去重，之后分多种情况进行判断）" class="headerlink" title="41. 缺失的第一个正数（C++实现，先对nums数组进行排序，然后使用map去重，之后分多种情况进行判断）"></a>41. 缺失的第一个正数（C++实现，先对nums数组进行排序，然后使用map去重，之后分多种情况进行判断）</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> firstMissingPositive(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//思路：使用map来保存nums中的元素，用来去重</span><br>        <span class="hljs-comment">//然后，使用map来进行判断</span><br>        <span class="hljs-comment">//如果map的长度为1，且元素小于等于0，或大于1，那么直接返回1</span><br>        <span class="hljs-comment">//如果map的长度不为1，那么判断map的最后一个元素是否小于等于0 或 大于1，是的话直接返回1</span><br><br>        <span class="hljs-comment">//给nums数组进行排序</span><br>        sort(nums.begin(), nums.end());<br><br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; keep;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            keep[nums[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//数值map的迭代器</span><br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; :: iterator iter;<br>        iter = keep.begin();<br><br>        <span class="hljs-keyword">if</span>(keep.size() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;first &lt;= <span class="hljs-number">0</span> || iter-&gt;first &gt; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> iter-&gt;first + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(iter != keep.end())&#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;first &lt;= <span class="hljs-number">0</span>)&#123;<br>                iter++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(iter-&gt;first != <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果等于keep.end()</span><br>        <span class="hljs-keyword">if</span>(iter == keep.end())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//表示keep中全是负数，此时返回1</span><br>        &#125;<br><br>        <span class="hljs-comment">//否则判断是否为</span><br>        <span class="hljs-keyword">int</span> shouldNum = iter-&gt;first + <span class="hljs-number">1</span>;<br>        iter++;<br><br>        <span class="hljs-keyword">while</span>(iter != keep.end())&#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;first == shouldNum)&#123;<br>                shouldNum ++;<br>                iter++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> shouldNum;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[nums.size() - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="73-矩阵置零（C-使用标记数组实现）"><a href="#73-矩阵置零（C-使用标记数组实现）" class="headerlink" title="73. 矩阵置零（C++使用标记数组实现）"></a>73. 矩阵置零（C++使用标记数组实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">void</span> setZeroes(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; <span class="hljs-type">matrix</span>) &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-built_in">row</span> = <span class="hljs-type">matrix</span>.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">col</span> = <span class="hljs-type">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//首先设置标记数组来记录哪些行和列需要设置为0</span><br>        <span class="hljs-type">vector</span>&lt;bool&gt; row_zero(<span class="hljs-built_in">row</span>, false);<br>        <span class="hljs-type">vector</span>&lt;bool&gt; col_zero(<span class="hljs-built_in">col</span>, false);<br><br>        <span class="hljs-comment">//思路：遍历二维矩阵，然后对出现0元素的行和列进行循环设为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">row</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j  = <span class="hljs-number">0</span>;j &lt; <span class="hljs-built_in">col</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-type">matrix</span>[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    row_zero[i] = true;<br>                    col_zero[j] = true;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//将对应的行设置为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; row_zero.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(row_zero[i] == true)&#123;<span class="hljs-comment">//需要设置为0</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-built_in">col</span>;j++)&#123;<br>                    <span class="hljs-type">matrix</span>[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//将对应的列设置为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; col_zero.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(col_zero[j] == true)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">row</span>;i++)&#123;<br>                    <span class="hljs-type">matrix</span>[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵（C-大模拟实现）"><a href="#54-螺旋矩阵（C-大模拟实现）" class="headerlink" title="54. 螺旋矩阵（C++大模拟实现）"></a>54. 螺旋矩阵（C++大模拟实现）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; spiral<span class="hljs-constructor">Order(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&gt;&amp; <span class="hljs-params">matrix</span>)</span> &#123;<br>        <span class="hljs-comment">//思路：更改动态left/right/top/bottom</span><br>        <span class="hljs-built_in">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> bottom = matrix.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = matrix<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br><br>        vector&lt;<span class="hljs-built_in">int</span>&gt; result;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//首先从左向右遍历</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = left;j &lt;= right;j++)&#123;<br>                result.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">top</span>][<span class="hljs-params">j</span>])</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//增加到下一行</span><br>            top++;<br><br>            <span class="hljs-keyword">if</span>(top &gt; bottom)&#123;<br>                break;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = top;i &lt;= bottom;i++)&#123;<br>                result.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">i</span>][<span class="hljs-params">right</span>])</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//减少一列</span><br>            right --;<br><br>            <span class="hljs-keyword">if</span>(right &lt; left)&#123;<br>                break;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = right;j &gt;= left;j--)&#123;<br>                result.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">bottom</span>][<span class="hljs-params">j</span>])</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//减少一行</span><br>            bottom--;<br><br><br>            <span class="hljs-keyword">if</span>(bottom &lt; top)&#123;<br>                break;<br>            &#125;<br><br>            <span class="hljs-comment">//遍历left对应的列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = bottom;i &gt;= top;i--)&#123;<br>                result.push<span class="hljs-constructor">_back(<span class="hljs-params">matrix</span>[<span class="hljs-params">i</span>][<span class="hljs-params">left</span>])</span>;<br>            &#125;<br><br>            left ++;<br><br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                break;<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="48-旋转图像（C-找规律实现）"><a href="#48-旋转图像（C-找规律实现）" class="headerlink" title="48. 旋转图像（C++找规律实现）"></a>48. 旋转图像（C++找规律实现）</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    void <span class="hljs-keyword">rotate</span>(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-comment">//思路：先复制一份matrix，然后找规律，原来的i,j位置的矩阵元素应当在新的矩阵的j,m-i-1处</span><br>        <span class="hljs-comment">//其中，m为矩阵的行数</span><br>        <span class="hljs-keyword">int</span> m = <span class="hljs-keyword">matrix</span>.<span class="hljs-keyword">size</span>();<br><br>        <span class="hljs-comment">//复制一份矩阵</span><br>        auto matrix_new = <span class="hljs-keyword">matrix</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();j++)&#123;<br>                matrix_new[j][m - i - <span class="hljs-number">1</span>] = <span class="hljs-keyword">matrix</span>[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">matrix</span> = matrix_new;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="240-搜索二维矩阵-II（C-从左下角开始遍历）"><a href="#240-搜索二维矩阵-II（C-从左下角开始遍历）" class="headerlink" title="240. 搜索二维矩阵 II（C++从左下角开始遍历）"></a>240. 搜索二维矩阵 II（C++从左下角开始遍历）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    bool searchMatrix(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; <span class="hljs-type">matrix</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-comment">//思路：选择从左下角开始遍历是最方便快捷的</span><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">row</span> = <span class="hljs-type">matrix</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">col</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">row</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">col</span> &lt;= <span class="hljs-type">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">target</span> &lt; <span class="hljs-type">matrix</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>])&#123;<br>                <span class="hljs-built_in">row</span>--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">target</span> &gt; <span class="hljs-type">matrix</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>])&#123;<br>                <span class="hljs-built_in">col</span>++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> true;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> false;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode hot 100</tag>
      
      <tag>Alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230916</title>
    <link href="/2023/09/16/leetcode-notes-20230916/"/>
    <url>/2023/09/16/leetcode-notes-20230916/</url>
    
    <content type="html"><![CDATA[<h2 id="416-分割等和子集（C-动态规划实现）"><a href="#416-分割等和子集（C-动态规划实现）" class="headerlink" title="416. 分割等和子集（C++动态规划实现）"></a>416. 分割等和子集（C++动态规划实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    bool canPartition(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//思路：背包的体积为sum/2</span><br>        <span class="hljs-comment">//每个元素既是重量又是价值</span><br>        <span class="hljs-comment">//dp[j]表示对于容量为j的背包，其能装的物体最大价值是dp[j]</span><br>        <span class="hljs-comment">//确定递推公式：</span><br>        <span class="hljs-comment">//dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br>        <span class="hljs-comment">//最终判断的标准：</span><br>        <span class="hljs-comment">//如果dp[target] == target，那么返回true，否则返回false；</span><br><br>        <span class="hljs-comment">//初始化动态规划数组</span><br>        <span class="hljs-comment">//题目中指定数组中元素的大小不会超过200，长度不会超过100，所以综合不会超过20000，那么</span><br>        <span class="hljs-comment">//sum / 2 = target == 10000</span><br>        <span class="hljs-comment">//因此定义动态规划数组的长度为10001</span><br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; dp(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">//判断sum / 2余数是否为1，如果为1，直接返回false；</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> false;<br>        &#125;<br><br>        <span class="hljs-comment">//得到背包最大容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">target</span> = <span class="hljs-built_in">sum</span> / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//开始递推更新dp数组</span><br>        <span class="hljs-comment">//外层循环遍历物体重量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//内层循环遍历物体的价值数组</span><br>            <span class="hljs-comment">//需要从后向前遍历，因为为了防止元素重复</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-built_in">target</span>;j &gt;= nums[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//判断dp[target] == target</span><br>        <span class="hljs-keyword">if</span>(dp[<span class="hljs-built_in">target</span>] == <span class="hljs-built_in">target</span>)&#123;<br>            <span class="hljs-keyword">return</span> true;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> false;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1049-最后一块石头的重量-II（C-动态规划实现）"><a href="#1049-最后一块石头的重量-II（C-动态规划实现）" class="headerlink" title="1049. 最后一块石头的重量 II（C++动态规划实现）"></a>1049. 最后一块石头的重量 II（C++动态规划实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> lastStoneWeightII(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones) &#123;<br>        <span class="hljs-comment">//思路：stones[i]表示第i块石头的重量，价值也为stones[i]</span><br>        <span class="hljs-comment">//题目中说的最小的重量，也就是说将这两堆石头尽可能地分为两份相同的重量</span><br>        <span class="hljs-comment">//那么这道题目就和分割等和子集一样了</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">sum</span> += stones[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">target</span> = <span class="hljs-built_in">sum</span> / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//初始化dp数组</span><br>        <span class="hljs-comment">//由于题目中给出stones数组长度最大为30，每个石头最大重量为100</span><br>        <span class="hljs-comment">//30 * 100 = 3000</span><br>        <span class="hljs-comment">//那么，target = sum / 2 = 3000 / 2 = 1500</span><br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; dp(<span class="hljs-number">1501</span>, <span class="hljs-number">0</span>);<br><br><br>        <span class="hljs-comment">//更新dp数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-built_in">target</span>;j &gt;= stones[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> - dp[<span class="hljs-built_in">target</span>] - dp[<span class="hljs-built_in">target</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="494-目标和（C-动态规划实现）"><a href="#494-目标和（C-动态规划实现）" class="headerlink" title="494. 目标和（C++动态规划实现）"></a>494. 目标和（C++动态规划实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> findTargetSumWays(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-comment">//思路：假设left - right = target，且left + right = sum</span><br>        <span class="hljs-comment">//那么，right = sum - left;</span><br>        <span class="hljs-comment">//则有left - (sum - left) = target</span><br>        <span class="hljs-comment">//left * 2 = sum + target</span><br>        <span class="hljs-comment">//left = (target + sum) / 2</span><br>        <span class="hljs-comment">//所以，原题目变成了求nums[i]数组中元素相加等于(target + sum) / 2的元素和</span><br>        <span class="hljs-comment">//需要注意的是：(target + sum) / 2可能向下取整，这个时候就返回0，表示不存在对应的表达式</span><br>        <span class="hljs-comment">//还有如果target &gt; sum，也是不存在的</span><br>        <span class="hljs-comment">//dp[j]表示能将j容量背包填满的方案数为dp[j]</span><br>        <span class="hljs-comment">//其中，dp[j]应该由dp[j - nums[i]]得到，其中nums[i]是元素i的重量</span><br>        <span class="hljs-comment">//也就是说，只要能找到nums[i]，就能找到dp[j - nums[i]] + nums[i] = dp[j]</span><br><br>        <span class="hljs-comment">//同时，dp[0]还应该初始化为1</span><br>        <span class="hljs-comment">//因为：对于nums = &#123;0, 0, 0&#125;，(target + sum) / 2，其中target = 0</span><br>        <span class="hljs-comment">//此时，实际上的不同表达式数目为2 * 2 * 2，而结果8的获得肯定是由dp[0] = 1递推得到的，</span><br>        <span class="hljs-comment">//因为如果dp[0] = 0，那么最终得到的dp[j]肯动都是0，因此，dp[0]应当初始化为1</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &lt; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">target</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">target</span> + <span class="hljs-built_in">sum</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br><br>        <span class="hljs-comment">//得到背包的目标容量为bagSize</span><br>        <span class="hljs-type">int</span> bagSize = (<span class="hljs-built_in">target</span> + <span class="hljs-built_in">sum</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//初始化数组都为0</span><br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; dp(bagSize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//初始化dp[0] = 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//进行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagSize;j &gt;= nums[i];j--)&#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>动态规划（dp）算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230915</title>
    <link href="/2023/09/15/leetcode-notes-20230915/"/>
    <url>/2023/09/15/leetcode-notes-20230915/</url>
    
    <content type="html"><![CDATA[<h2 id="509-斐波那契数（C-动态规划实现）"><a href="#509-斐波那契数（C-动态规划实现）" class="headerlink" title="509. 斐波那契数（C++动态规划实现）"></a>509. 斐波那契数（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">//使用动态规划实现</span><br>        <span class="hljs-comment">//定义状态数组，长度为n+1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯（C-动态规划实现）"><a href="#70-爬楼梯（C-动态规划实现）" class="headerlink" title="70. 爬楼梯（C++动态规划实现）"></a>70. 爬楼梯（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <br>        <span class="hljs-comment">//思路：假设dp[i]表示达到第i阶楼梯所有可能的方法种类数量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//dp[0] = 0;//不需要考虑n=0的情况，因为n&gt;=1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<span class="hljs-comment">//可以走两步，也可以连续走一步</span><br>        <span class="hljs-comment">//由于dp[i]可以由dp[i - 1]增加一阶得到也可以由dp[i - 2]增加两阶得到</span><br>        <span class="hljs-comment">//因此dp[i] = dp[i - 1] + dp[i - 2]</span><br>        <span class="hljs-comment">//从前向后遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n;i ++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯（C-动态规划实现，优化空间的写法）"><a href="#70-爬楼梯（C-动态规划实现，优化空间的写法）" class="headerlink" title="70. 爬楼梯（C++动态规划实现，优化空间的写法）"></a>70. 爬楼梯（C++动态规划实现，优化空间的写法）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">//优化空间的写法</span><br>        <span class="hljs-built_in">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">2</span>] = <span class="hljs-keyword">sum</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯（C-动态规划实现）"><a href="#746-使用最小花费爬楼梯（C-动态规划实现）" class="headerlink" title="746. 使用最小花费爬楼梯（C++动态规划实现）"></a>746. 使用最小花费爬楼梯（C++动态规划实现）</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;<br>        //思路：使用一维dp数组，dp<span class="hljs-comment">[i]</span>表示跳到i层需要的最少花费<br>        //dp<span class="hljs-comment">[i]</span>可以由dp<span class="hljs-comment">[i - 1]</span>得到，此时的dp<span class="hljs-comment">[i]</span> = dp<span class="hljs-comment">[i - 1]</span> + cost<span class="hljs-comment">[i - 1]</span>;<br>        //dp<span class="hljs-comment">[i]</span>也可以由dp<span class="hljs-comment">[i - 2]</span>得到，此时的dp<span class="hljs-comment">[i]</span> = dp<span class="hljs-comment">[i - 2]</span> + cost<span class="hljs-comment">[i - 2]</span>;<br>        //那么dp<span class="hljs-comment">[i]</span> = min(dp<span class="hljs-comment">[i - 1]</span> + cost<span class="hljs-comment">[i - 1]</span>, dp<span class="hljs-comment">[i - 2]</span> + cost<span class="hljs-comment">[i - 2]</span>);<br>        //初始化dp数组：dp<span class="hljs-comment">[0]</span> = 0; dp<span class="hljs-comment">[1]</span> = 0;<br>        <br>        // 定义dp数组<br>        vector&lt;int&gt; dp(cost.size() + 1);<br>        dp<span class="hljs-comment">[0]</span> = 0;<br>        dp<span class="hljs-comment">[1]</span> = 0;<br><br>        for(int i = 2;i &lt;= cost.size();i++)&#123;<br>            dp<span class="hljs-comment">[i]</span> = min(dp<span class="hljs-comment">[i - 1]</span> + cost<span class="hljs-comment">[i - 1]</span>, dp<span class="hljs-comment">[i - 2]</span> + cost<span class="hljs-comment">[i - 2]</span>);<br>        &#125;<br><br>        return dp<span class="hljs-comment">[cost.size()]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯（C-动态规划实现，优化内存空间）"><a href="#746-使用最小花费爬楼梯（C-动态规划实现，优化内存空间）" class="headerlink" title="746. 使用最小花费爬楼梯（C++动态规划实现，优化内存空间）"></a>746. 使用最小花费爬楼梯（C++动态规划实现，优化内存空间）</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;<br>        //优化空间复杂度<br>        int dp<span class="hljs-comment">[3]</span>;<br>        dp<span class="hljs-comment">[0]</span> = 0;<br>        dp<span class="hljs-comment">[1]</span> = 0;<br><br>        for(int i = 2;i &lt;= cost.size();i++)&#123;<br>            dp<span class="hljs-comment">[2]</span> = min(dp<span class="hljs-comment">[1]</span> + cost<span class="hljs-comment">[i - 1]</span>, dp<span class="hljs-comment">[0]</span> + cost<span class="hljs-comment">[i - 2]</span>);<br>            dp<span class="hljs-comment">[0]</span> = dp<span class="hljs-comment">[1]</span>;<br>            dp<span class="hljs-comment">[1]</span> = dp<span class="hljs-comment">[2]</span>;<br>        &#125;<br><br>        return dp<span class="hljs-comment">[1]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径（C-动态规划实现）"><a href="#62-不同路径（C-动态规划实现）" class="headerlink" title="62. 不同路径（C++动态规划实现）"></a>62. 不同路径（C++动态规划实现）</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int uniquePaths(int m, int n) &#123;<br>        //思路：设dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>为动态数组，表示从(0, 0)开始到(i, j)总共有dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>条路径<br>        //而dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>只能从两个方向来推导：dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>和dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span><br>        //初始化dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>数组：从(0, 0)开始到(i, 0)或(0, j)的方法只有一个<br>        <br>        //初始化dp数组<br>        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));<br>        for(int i = 0;i &lt; m; i++)&#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = 1;<br>        &#125;<br><br>        for(int j = 0; j &lt; n;j++)&#123;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span> = 1;<br>        &#125;<br><br>        //遍历整个m*n网格<br>        for(int i = 1;i &lt; m;i++)&#123;<br>            for(int j = 1;j &lt; n;j++)&#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>            &#125;<br>        &#125;<br><br>        return dp<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="63-不同路径-II（C-动态规划实现）"><a href="#63-不同路径-II（C-动态规划实现）" class="headerlink" title="63. 不同路径 II（C++动态规划实现）"></a>63. 不同路径 II（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：首先对于(i, 0)和(0, j)的处理与没有障碍物的题目类似，但是不同的地方在于：</span><br>        <span class="hljs-comment">//由于存在障碍物，需要判断是否等于0，如果等于0，那么设置为1，否则从等于1的地方开始向后都设置为0</span><br>        <span class="hljs-comment">//在更新dp数组的时候需要注意：如果(i, j)有障碍物，那么跳过即可</span><br>        <span class="hljs-comment">//得到行列数</span><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//初始化dp表</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//初始化最左边的列，障碍物之后都是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//初始化最上边的行，障碍物之后都是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//然后更新dp表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-comment">//表示有障碍物</span><br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="343-整数拆分（C-动态规划实现）"><a href="#343-整数拆分（C-动态规划实现）" class="headerlink" title="343. 整数拆分（C++动态规划实现）"></a>343. 整数拆分（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：dp[i]表示拆分数字i得到的正整数的最大乘积为dp[i]</span><br>        <span class="hljs-comment">//此时，dp[i]可以由如下两种方法得到：</span><br>        <span class="hljs-comment">//1.由j * (i - j)得到；</span><br>        <span class="hljs-comment">//2.由j * dp[i - j]得到，相当于，拆分了dp[i - j]；</span><br><br>        <span class="hljs-comment">//初始化dp数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//初始化dp[2] = 1</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//2 = 1 * 1</span><br>        <span class="hljs-comment">//更新dp数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-comment">//j实际上从1增加到i / 2即可</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= i / <span class="hljs-number">2</span>;j++)&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j * (i - j), j * dp[i - j]));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="96-不同的二叉搜索树（C-动态规划实现）"><a href="#96-不同的二叉搜索树（C-动态规划实现）" class="headerlink" title="96. 不同的二叉搜索树（C++动态规划实现）"></a>96. 不同的二叉搜索树（C++动态规划实现）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Solution &#123;<br>public:<br>    int numTrees(int n) &#123;<br>        <span class="hljs-regexp">//</span>思路：<br>        <span class="hljs-regexp">//</span>节点数为<span class="hljs-number">1</span>的，只有一种；<br>        <span class="hljs-regexp">//</span>结点数为<span class="hljs-number">2</span>的，有两种；<br><br>        <span class="hljs-regexp">//</span>节点数为<span class="hljs-number">3</span>的，需要分情况讨论：<br>        <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.头节点为<span class="hljs-number">1</span>对应的种类数=右子树有<span class="hljs-number">2</span>个结点的种类数*左子树有<span class="hljs-number">0</span>个结点的种类数；<br>        <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.头节点为<span class="hljs-number">2</span>对应的种类数=右子树有<span class="hljs-number">1</span>个结点的种类数*左子树有<span class="hljs-number">1</span>个结点的种类数；<br>        <span class="hljs-regexp">//</span><span class="hljs-number">3</span>.头结点为<span class="hljs-number">3</span>对应的种类数=右子树有<span class="hljs-number">0</span>个结点的种类数*左子树有<span class="hljs-number">2</span>个结点的种类数；<br>        <span class="hljs-regexp">//</span>那么节点数为<span class="hljs-number">3</span>对应的种类=头节点为<span class="hljs-number">1</span>对应的种类数+头节点为<span class="hljs-number">2</span>对应的种类数+头节点为<span class="hljs-number">3</span>对应的种类数<br><br>        <span class="hljs-regexp">//</span>而：<span class="hljs-number">0</span>个结点的种类数为dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-regexp">//</span>有<span class="hljs-number">1</span>个结点的种类数为dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-regexp">//</span>有<span class="hljs-number">2</span>个节点的种类数为dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-regexp">//</span>那么得到递推公式为：dp[<span class="hljs-number">3</span>] = dp[<span class="hljs-number">2</span>] * dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">0</span>] * dp[<span class="hljs-number">2</span>] + dp[<span class="hljs-number">1</span>] * dp[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-regexp">//</span>定义初始化数组：<br>        vector&lt;int&gt; dp(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-regexp">//</span>初始化dp[<span class="hljs-number">0</span>]为<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>; i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">1</span>;j &lt;= i;j++)&#123;<br>                <span class="hljs-regexp">//</span>j从<span class="hljs-number">1</span>开始遍历到i结束<br>                <span class="hljs-regexp">//</span>更新dp动态数组<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <br>        return dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="01背包问题基础公式推导（C-动态规划实现）"><a href="#01背包问题基础公式推导（C-动态规划实现）" class="headerlink" title="01背包问题基础公式推导（C++动态规划实现）"></a>01背包问题基础公式推导（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//背包问题公式推导</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_beibao_problem</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//设置测试用例</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; values = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><br>        <span class="hljs-comment">//定义背包的最大容量</span><br>        <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>        <span class="hljs-comment">//定义二维数组</span><br>        <span class="hljs-comment">//第一个维度表示物品数组的长度</span><br>        <span class="hljs-comment">//第二个维度表示背包容量的长度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weights.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-comment">//初始化的时候需要注意：从weights开始，小于背包容量的设置为values[0]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weights[<span class="hljs-number">0</span>];j &lt;= bagweight;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = values[<span class="hljs-number">0</span>];<span class="hljs-comment">//初始化为values[0]</span><br>        &#125;<br><br>        <span class="hljs-comment">//先循环物品数组，再循环背包容量数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; weights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//循环背包容量数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= bagweights;j++)&#123;<br>                <span class="hljs-comment">//如果物品的重量大于j，表示无法将第i个物品放到背包里</span><br>                <span class="hljs-keyword">if</span>(j &lt; weights[i])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i]] + values[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[weights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweights];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>动态规划（dp）算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230914</title>
    <link href="/2023/09/14/leetcode-notes-20230914/"/>
    <url>/2023/09/14/leetcode-notes-20230914/</url>
    
    <content type="html"><![CDATA[<h2 id="134-加油站（C-贪心算法实现）"><a href="#134-加油站（C-贪心算法实现）" class="headerlink" title="134. 加油站（C++贪心算法实现）"></a>134. 加油站（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-comment">//设置currSum，用来保存从i+1更新后的sum总油量和</span><br>        <span class="hljs-type">int</span> currSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> totalSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//结果返回变量</span><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历油的数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++)&#123;<br>            totalSum += gas[i] - cost[i];<br>            currSum += gas[i] - cost[i];<br><br>            <span class="hljs-keyword">if</span>(currSum &lt; <span class="hljs-number">0</span>)&#123;<br>                currSum = <span class="hljs-number">0</span>;<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(totalSum &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="135-分发糖果（C-贪心算法实现）"><a href="#135-分发糖果（C-贪心算法实现）" class="headerlink" title="135. 分发糖果（C++贪心算法实现）"></a>135. 分发糖果（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-comment">//设置和ratings长度相同的数组，并初始化元素值为0</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candys</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-comment">//从前向后遍历，右孩子大于左孩子的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] - ratings[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                candys[i] = candys[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//这个时候有孩子一定大于左孩子1</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//从后向前遍历</span><br>        <span class="hljs-comment">//判断左孩子大于右孩子的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] - ratings[i + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                candys[i] = <span class="hljs-built_in">max</span>(candys[i], candys[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//统计总和</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; candys.<span class="hljs-built_in">size</span>();i++)&#123;<br>            result += candys[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="860-柠檬水找零（C-贪心算法实现）"><a href="#860-柠檬水找零（C-贪心算法实现）" class="headerlink" title="860. 柠檬水找零（C++贪心算法实现）"></a>860. 柠檬水找零（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//其中当bills[i] == 20时，优先使用一张10面值+一张5面值的，尽可能多地保留5面值，因为5面值相对来说更加通用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-comment">//进行模拟</span><br>        <span class="hljs-comment">//curr_xxx表示当前商家手里面的钱的数量</span><br>        <span class="hljs-type">int</span> curr_five = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curr_ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curr_twenty = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//for循环实现遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; bills.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">5</span>)&#123;<br>                curr_five += <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-comment">//10元面值的钱增加1</span><br>                curr_ten += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//5元面值的钱减少1</span><br>                <span class="hljs-keyword">if</span>(curr_five &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    curr_five -= <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-comment">//20元面值的钱增加1</span><br>                curr_twenty += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//有两种可能</span><br>                <span class="hljs-keyword">if</span>(curr_ten &gt;= <span class="hljs-number">1</span> &amp;&amp; curr_five &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//第1种：找一张10面值+一张5面值的</span><br>                    curr_ten -= <span class="hljs-number">1</span>;<br>                    curr_five -= <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curr_five &gt;= <span class="hljs-number">3</span>)&#123;<span class="hljs-comment">//第2种：找三张5面值的</span><br>                    curr_five -= <span class="hljs-number">3</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//没有满足的找零，那么直接返回false</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="406-根据身高重建队列（C-贪心算法实现）"><a href="#406-根据身高重建队列（C-贪心算法实现）" class="headerlink" title="406. 根据身高重建队列（C++贪心算法实现）"></a>406. 根据身高重建队列（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//设置排列器，传入参数为vector数组地址</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-comment">//思路：先排身高最高的，身高相同的，按照后边的ki进行排序</span><br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<span class="hljs-comment">//创建的结果返回数组</span><br>        <br>        <span class="hljs-comment">//在循环中根据每个元素的ki对元素进行重新排序即可得到最终的结果队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; people.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//得到当前i同学应该在的位置</span><br>            <span class="hljs-type">int</span> pos = people[i][<span class="hljs-number">1</span>];<br>            result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">begin</span>() + pos, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="406-根据身高重建队列（C-贪心算法实现，将结果队列从vector替换为list）"><a href="#406-根据身高重建队列（C-贪心算法实现，将结果队列从vector替换为list）" class="headerlink" title="406. 根据身高重建队列（C++贪心算法实现，将结果队列从vector&lt;vector&gt;替换为list&lt;vector&gt;）"></a>406. 根据身高重建队列（C++贪心算法实现，将结果队列从vector&lt;vector<int>&gt;替换为list&lt;vector<int>&gt;）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//使用list数组实现</span><br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; people.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> pos = people[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//使用迭代器</span><br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = result.<span class="hljs-built_in">begin</span>(); <br>            <span class="hljs-keyword">while</span>(pos--)&#123;<br>                it++;<br>            &#125;<br>            result.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>    &#125;<br>   <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="452-用最少数量的箭引爆气球（C-贪心算法实现）"><a href="#452-用最少数量的箭引爆气球（C-贪心算法实现）" class="headerlink" title="452. 用最少数量的箭引爆气球（C++贪心算法实现）"></a>452. 用最少数量的箭引爆气球（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//按照从小到大的顺序进行排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：寻找最少的x坐标，使得其落在尽可能多的区间内</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">//取排序后的第一个数组元素的右边界</span><br>        <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//遍历从index=1开始的所有元素，得到最终的结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; right)&#123;<span class="hljs-comment">//表示下一个元素大于上一个的最小右right边界，需要增加箭的数量</span><br>                right = points[i][<span class="hljs-number">1</span>];<br>                result++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//表示该区间与上一个区间有交集</span><br>                right = <span class="hljs-built_in">min</span>(points[i][<span class="hljs-number">1</span>], right);<span class="hljs-comment">//更新right为该区间和上一个区间的最小right边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="435-无重叠区间（C-贪心算法实现）"><a href="#435-无重叠区间（C-贪心算法实现）" class="headerlink" title="435. 无重叠区间（C++贪心算法实现）"></a>435. 无重叠区间（C++贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//按照左边界进行升序排列</span><br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> eraseOverlapIntervals(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-comment">//思路：按照左边界进行排序之后，从index=1开始判断，该区间的左边界是否在右边界以内</span><br>        <span class="hljs-comment">//如果是，那么判断是删除当前区间还是删除上一个区间，这个看哪个区间的右边界大，右边界大的优先删除</span><br>        <span class="hljs-comment">//即可</span><br><br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end(), cmp);<br>        <span class="hljs-built_in">int</span> pre = <span class="hljs-number">0</span>;<span class="hljs-comment">//保存的前一个保留下来的数组index</span><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">int</span>ervals.size();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">int</span>ervals[pre][<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//判断保留下来哪一个区间</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">int</span>ervals[pre][<span class="hljs-number">1</span>])&#123;<br>                    pre = i;<span class="hljs-comment">//保存下来小的</span><br>                &#125;<br>                <span class="hljs-comment">//结果+1</span><br>                result ++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//表示没有交集，那么直接将保留区间index的变量pre更新为i</span><br>                pre = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="763-划分字母区间（C-贪心算法实现）"><a href="#763-划分字母区间（C-贪心算法实现）" class="headerlink" title="763. 划分字母区间（C++贪心算法实现）"></a>763. 划分字母区间（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//一共有27个英文字母</span><br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            hash[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br><br>        <span class="hljs-comment">//结果返回数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//更新end下标</span><br>            end = <span class="hljs-built_in">max</span>(end, hash[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span>(i == end)&#123;<br>                <span class="hljs-comment">//加入包含当前字母的区间长度</span><br>                result.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间（C-贪心算法实现）"><a href="#56-合并区间（C-贪心算法实现）" class="headerlink" title="56. 合并区间（C++贪心算法实现）"></a>56. 合并区间（C++贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; merge(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals.size() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals;<br>        &#125;<br><br>        <span class="hljs-comment">//思路：按照区间的左边界进行升序排序</span><br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end(), cmp);<br><br>        <span class="hljs-comment">//如果当前区间的左边界小于上一个区间的右边界，那么合并两个区间同时，更新left和right</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//定义的结果数组</span><br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; result;<br>        result.push_back(<span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-comment">//从index=1开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">int</span>ervals.size();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;= right)&#123;<br>                vector&lt;<span class="hljs-built_in">int</span>&gt; tmp;<br>                tmp.push_back(left);<br>                tmp.push_back(max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]));<br>                result.pop_back();<span class="hljs-comment">//弹出上一个区间</span><br>                result.push_back(tmp);<br>                <span class="hljs-comment">//更新right边界</span><br>                right = max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果当前的left大于等于上一个的右边界，那么直接加入即可，然后更新</span><br>                result.push_back(<span class="hljs-built_in">int</span>ervals[i]);<br>                left = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>                right = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="738-单调递增的数字（C-贪心算法实现）"><a href="#738-单调递增的数字（C-贪心算法实现）" class="headerlink" title="738. 单调递增的数字（C++贪心算法实现）"></a>738. 单调递增的数字（C++贪心算法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> monotoneIncreasingDigits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-comment">//思路：将数字转换为字符串，然后判断strNum[i - 1]是否大于strNum[i]，如果是，</span><br>        <span class="hljs-comment">//需要将strNum[i - 1] --;同时将strNum[i]替换为9</span><br>        string strNum = to_string(n);<br><br>        <span class="hljs-keyword">int</span> flag = strNum.<span class="hljs-keyword">size</span>();<br><br>        <span class="hljs-comment">//从后向前遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = strNum.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i])&#123;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>                flag = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 从flag开始，全部设置为9</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = flag;i &lt; strNum.<span class="hljs-keyword">size</span>();i++)&#123;<br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stoi(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（困难）-968-监控二叉树（C-贪心算法实现）"><a href="#（困难）-968-监控二叉树（C-贪心算法实现）" class="headerlink" title="（困难） 968. 监控二叉树（C++贪心算法实现）"></a>（困难） 968. 监控二叉树（C++贪心算法实现）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs awk">/**<br> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), left(nullptr), right(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    <span class="hljs-regexp">//</span>返回结果的变量<br>    int result = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-regexp">//</span>遍历二叉树，按照从下往上的顺序进行<br>    int traversal(TreeNode* curr)&#123;<br>        <span class="hljs-regexp">//</span> 空结点，该结点有覆盖<br>        <span class="hljs-keyword">if</span>(curr == nullptr)&#123;<br>            return <span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>返回<span class="hljs-number">2</span>（状态<span class="hljs-number">2</span>表示该结点为空结点且有覆盖）<br>        &#125;<br><br>        <span class="hljs-regexp">//</span>得到left结点和right结点<br>        int left = traversal(curr-&gt;left);<span class="hljs-regexp">//</span>左结点<br>        int right = traversal(curr-&gt;right);<span class="hljs-regexp">//</span>右结点<br><br>        <span class="hljs-regexp">//</span>对中节点情况的处理<br>        <span class="hljs-regexp">//</span>情况<span class="hljs-number">1</span>：左右节点都有覆盖<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>)&#123;<br>            return <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>表示当前父结点<br>        &#125;<br><br>        <span class="hljs-regexp">//</span>情况<span class="hljs-number">2</span>分为如下几种：<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>，左右节点无覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">0</span>，左结点有摄像头，右结点无覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">1</span>，左节点无覆盖，右结点有摄像头<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">2</span>，左结点无覆盖，右结点有覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">0</span>，左结点有覆盖，右结点无覆盖<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>)&#123;<br>            result++;<span class="hljs-regexp">//</span>表示当左右结点至少有一个结点无覆盖时，在中结点增加摄像头<br>            return <span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>表示增加摄像头<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>情况<span class="hljs-number">3</span>分为如下几种：<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">2</span>，左节点有摄像头，右结点有覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">1</span>，左结点有覆盖，右结点有摄像头<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">1</span>，左右节点均有摄像头<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>那么left和right的父亲结点设置为<span class="hljs-number">2</span>，表示有覆盖<br>        &#125;<br><br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    int minCameraCover(TreeNode* root) &#123;<br>        result = <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>初始化结果为<span class="hljs-number">0</span><br><br>        <span class="hljs-regexp">//</span>表示无覆盖<br>        <span class="hljs-keyword">if</span>(traversal(root) == <span class="hljs-number">0</span>)&#123;<br>            result ++;<br>        &#125;<br><br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>贪心算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230913</title>
    <link href="/2023/09/13/leetcode-notes-20230913/"/>
    <url>/2023/09/13/leetcode-notes-20230913/</url>
    
    <content type="html"><![CDATA[<h2 id="376-摆动序列（Java贪心实现）"><a href="#376-摆动序列（Java贪心实现）" class="headerlink" title="376. 摆动序列（Java贪心实现）"></a>376. 摆动序列（Java贪心实现）</h2><p>思路：先对数组进行升序排序，然后从后往前遍历胃口数组，遍历的同时去判断饼干数组是否有满足要求的数值，如果有，则结果返回变量result++。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> wiggleMaxLength(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> preDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> currDiff = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length - <span class="hljs-number">1</span>;i++)&#123;<br>            currDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span>((preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp;currDiff &lt; <span class="hljs-number">0</span>) || (preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; currDiff &gt; <span class="hljs-number">0</span>))&#123;<br>                result ++;<br>                preDiff = currDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和（Java贪心实现）"><a href="#53-最大子数组和（Java贪心实现）" class="headerlink" title="53. 最大子数组和（Java贪心实现）"></a>53. 最大子数组和（Java贪心实现）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxSubArray(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-comment">//思路：首先遍历nums数组，定义count变量来记录从下标i开始的子数组元素累积和，如果出现count &lt;= 0       //的情况，更新count = 0即可，从头开始记录。</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">count</span> += nums[i];<br><br>            <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-keyword">count</span>)&#123;<br>                result = <span class="hljs-keyword">count</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II（Java贪心实现）"><a href="#122-买卖股票的最佳时机-II（Java贪心实现）" class="headerlink" title="122. 买卖股票的最佳时机 II（Java贪心实现）"></a>122. 买卖股票的最佳时机 II（Java贪心实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxProfit(<span class="hljs-built_in">int</span>[] prices) &#123;<br>        <span class="hljs-comment">//思路：首先某一天既可以买入也可以卖出。如果假设在i天买入在第i+5天卖出，</span><br>        <span class="hljs-comment">//实际上与从i天到i+5天每天买入和卖出，并取其中为正数的交易金额相加是一样的效果。</span><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; prices.length - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i + <span class="hljs-number">1</span>] - prices[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                result += prices[i + <span class="hljs-number">1</span>] -prices[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-跳跃游戏（Java贪心算法实现）"><a href="#55-跳跃游戏（Java贪心算法实现）" class="headerlink" title="55. 跳跃游戏（Java贪心算法实现）"></a>55. 跳跃游戏（Java贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean canJump(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-comment">//思路：定义一个cover变量保存从当前下标开始能覆盖的最大index，</span><br>        <span class="hljs-comment">//如果cover大于或等于nums.length - 1，就表示能达到最后一个下标</span><br>        <span class="hljs-built_in">int</span> cover = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= cover;i ++)&#123;<br>            <span class="hljs-comment">//获得当前cover最大值</span><br>            cover = Math.max(i + nums[i], cover);<br><br>            <span class="hljs-keyword">if</span>(cover &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II（Java贪心算法实现）"><a href="#45-跳跃游戏-II（Java贪心算法实现）" class="headerlink" title="45. 跳跃游戏 II（Java贪心算法实现）"></a>45. 跳跃游戏 II（Java贪心算法实现）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Solution &#123;<br>    public int jump(int[] nums) &#123;<br>        <span class="hljs-regexp">//</span>思路：定义两个变量currDistance和nextDistance，<br>        <span class="hljs-regexp">//</span>其中currDistance表示从每次跳跃开始位置可以覆盖的最远坐标，<br>        <span class="hljs-regexp">//</span>nextDistance表示从遍历的i开始，能达到的最远范围，<br>        <span class="hljs-regexp">//</span>当i走到currDistance时，更新currDistance = nextDistance，表示从当前i位置开始<br>        <span class="hljs-regexp">//</span>能到达的最远坐标范围，然后判断最远范围是否可以覆盖到数组最后，如果可以那么就<span class="hljs-keyword">break</span>，<br>        <span class="hljs-regexp">//</span>这样就可以保证以最小的次数跳跃到数组最后。<br>        <br>        <span class="hljs-regexp">//</span>如果长度为<span class="hljs-number">0</span>，那么不需要跳跃<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        int currDistance = <span class="hljs-number">0</span>;<br>        int result = <span class="hljs-number">0</span>;<br>        int nextDistance = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-regexp">//</span>得到当前能达到的最大坐标值nextDistance<br>            nextDistance = Math.max(i + nums[i], nextDistance);<br>            <span class="hljs-regexp">//</span>表示到达了currDistance对应的坐标处<br>            <span class="hljs-keyword">if</span>(i == currDistance)&#123;<br>                <span class="hljs-regexp">//</span>更新currDistance<br>                currDistance = nextDistance;<br>                result ++;<span class="hljs-regexp">//</span>跳跃次数增加<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span>(currDistance &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1005-K-次取反后最大化的数组和（Java贪心实现）"><a href="#1005-K-次取反后最大化的数组和（Java贪心实现）" class="headerlink" title="1005. K 次取反后最大化的数组和（Java贪心实现）"></a>1005. K 次取反后最大化的数组和（Java贪心实现）</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-regexp">//使用Java 8特性中的IntStream来实现</span><br><span class="hljs-regexp">class Solution &#123;</span><br><span class="hljs-regexp">    public int largestSumAfterKNegations(int[] nums, int K) &#123;</span><br><span class="hljs-regexp">    //</span> 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小<br>nums = IntStream.<span class="hljs-keyword">of</span>(nums)<br>     .boxed()<br>     .sorted<span class="hljs-function"><span class="hljs-params">((o1, o2) -&gt; <span class="hljs-built_in">Math</span>.abs(o2) - <span class="hljs-built_in">Math</span>.abs(o1))</span></span><br><span class="hljs-function">     .<span class="hljs-title">mapToInt</span><span class="hljs-params">(Integer::intValue)</span>.<span class="hljs-title">toArray</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-title">len</span> = <span class="hljs-title">nums</span>.<span class="hljs-title">length</span>;    </span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">    //从前向后遍历，遇到负数将其变为正数，同时<span class="hljs-title">K</span>--</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>] = -<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">    <span class="hljs-title">K</span>--;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">// 如果<span class="hljs-title">K</span>还大于0，那么反复转变数值最小的元素，将<span class="hljs-title">K</span>用完</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)</span> <span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1] = -<span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1];</span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">stream</span><span class="hljs-params">(nums)</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">//使用带有排序规则器的方法实现</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">AbsoluteValueComparator</span> <span class="hljs-title">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Integer</span>&gt; &#123;</span><br><span class="hljs-function">        @<span class="hljs-title">Override</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">return</span> <span class="hljs-title">Math</span>.<span class="hljs-title">abs</span><span class="hljs-params">(b)</span> - <span class="hljs-title">Math</span>.<span class="hljs-title">abs</span><span class="hljs-params">(a)</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(int[] nums, int K)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">int</span> <span class="hljs-title">len</span> = <span class="hljs-title">nums</span>.<span class="hljs-title">length</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Integer</span>[] <span class="hljs-title">numsInteger</span> = <span class="hljs-title">new</span> <span class="hljs-title">Integer</span>[<span class="hljs-title">len</span>];</span><br><span class="hljs-function">        </span><br><span class="hljs-function">        // 将 <span class="hljs-title">int</span>[] 转换为 <span class="hljs-title">Integer</span>[]</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">numsInteger</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小</span><br><span class="hljs-function">        <span class="hljs-title">Arrays</span>.<span class="hljs-title">sort</span><span class="hljs-params">(numsInteger, <span class="hljs-keyword">new</span> AbsoluteValueComparator())</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        //将排序后的<span class="hljs-title">numsInteger</span>转为<span class="hljs-title">nums</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">numsInteger</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">            //从前向后遍历，遇到负数将其变为正数，同时<span class="hljs-title">K</span>--</span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>] = -<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">                <span class="hljs-title">K</span>--;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        // 如果<span class="hljs-title">K</span>还大于0，那么反复转变数值最小的元素，将<span class="hljs-title">K</span>用完</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)</span> <span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1] = -<span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1];</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">stream</span><span class="hljs-params">(nums)</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="134-加油站（C-贪心算法实现）"><a href="#134-加油站（C-贪心算法实现）" class="headerlink" title="134. 加油站（C++贪心算法实现）"></a>134. 加油站（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-comment">//使用贪心算法实现</span><br>        <span class="hljs-comment">//思路：分三种情况，首先计算所有的gas[i] - cost[i]剩下的油总和是否小于0，</span><br>        <span class="hljs-comment">//第三种情况：如果是，那么表示从哪里出发也无法转一圈；</span><br>        <span class="hljs-comment">//第二种情况：如果min最小值大于0，表示从0出发可以达到；</span><br>        <span class="hljs-comment">//第三种情况：如果min最小值为负数，那么从0开始判断，哪个位置的油可以使得min值变为大于0的数</span><br>        <span class="hljs-comment">//那么这个位置i就是结果</span><br><br>        <span class="hljs-type">int</span> currSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> min = INT32_MAX;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            currSum += rest;<br>            <span class="hljs-keyword">if</span>(currSum &lt; min)&#123;<br>                min = currSum;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(currSum &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(min &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//情况三，从后向前遍历实现</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = gas.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            min += rest;<br>            <span class="hljs-keyword">if</span>(min &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>贪心算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230912.</title>
    <link href="/2023/09/12/leetcode-notes-20230912/"/>
    <url>/2023/09/12/leetcode-notes-20230912/</url>
    
    <content type="html"><![CDATA[<h2 id="455-分发饼干（C-实现贪心算法，先遍历胃口数组）"><a href="#455-分发饼干（C-实现贪心算法，先遍历胃口数组）" class="headerlink" title="455. 分发饼干（C++实现贪心算法，先遍历胃口数组）"></a>455. 分发饼干（C++实现贪心算法，先遍历胃口数组）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> find<span class="hljs-constructor">ContentChildren(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">g</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">//先对两个数组进行排序</span><br>        sort(g.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, g.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        sort(s.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, s.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        <span class="hljs-built_in">int</span> index = s.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">//index保存饼干数组的当前位置</span><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录结果（孩子满足的人数）</span><br>        <span class="hljs-comment">//外层for循环遍历胃口数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = g.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(index &gt;=<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span> &gt;= g<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                index --;<br>                result ++;<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="455-分发饼干（C-实现贪心算法，先遍历饼干数组）"><a href="#455-分发饼干（C-实现贪心算法，先遍历饼干数组）" class="headerlink" title="455. 分发饼干（C++实现贪心算法，先遍历饼干数组）"></a>455. 分发饼干（C++实现贪心算法，先遍历饼干数组）</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> findContentChildren(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; g, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; s) &#123;<br>        sort(g.begin(), g.<span class="hljs-keyword">end</span>());<br>        sort(s.begin(), s.<span class="hljs-keyword">end</span>());<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        //先遍历饼干<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span> &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] &gt;= g[<span class="hljs-built_in">index</span>])&#123;<br>                <span class="hljs-built_in">index</span>++;<br>                result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="376-摆动序列（C-贪心算法实现）"><a href="#376-摆动序列（C-贪心算法实现）" class="headerlink" title="376. 摆动序列（C++贪心算法实现）"></a>376. 摆动序列（C++贪心算法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> wiggleMaxLength(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-keyword">size</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> preDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> currDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>;i++)&#123;<br>            currDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">//如果出现峰值</span><br>            <span class="hljs-keyword">if</span>((preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; currDiff &lt; <span class="hljs-number">0</span>) || (preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; currDiff &gt; <span class="hljs-number">0</span>))&#123;<br>                result ++;<br>                preDiff = currDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和（C-贪心算法实现）"><a href="#53-最大子数组和（C-贪心算法实现）" class="headerlink" title="53. 最大子数组和（C++贪心算法实现）"></a>53. 最大子数组和（C++贪心算法实现）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> result = INT32_MIN;<br>        <span class="hljs-comment">//定义暂时保存的最大和变量count</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//单层for循环实现遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-comment">//更新count</span><br>            <span class="hljs-keyword">count</span> += nums[i];<br><br>            <span class="hljs-comment">//判断count是否大于result，大于result的话直接更新result为count的值</span><br>            <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-keyword">count</span>)&#123;<br>                result = <span class="hljs-keyword">count</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//判断count是否小于等于0，如果是，表示当前nums[i]为负，那么就更count为nums[i+1]</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II（C-贪心算法实现）"><a href="#122-买卖股票的最佳时机-II（C-贪心算法实现）" class="headerlink" title="122. 买卖股票的最佳时机 II（C++贪心算法实现）"></a>122. 买卖股票的最佳时机 II（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                result += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II（Java贪心算法实现）"><a href="#122-买卖股票的最佳时机-II（Java贪心算法实现）" class="headerlink" title="122. 买卖股票的最佳时机 II（Java贪心算法实现）"></a>122. 买卖股票的最佳时机 II（Java贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxProfit(<span class="hljs-built_in">int</span>[] prices) &#123;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                result += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-跳跃游戏（Java贪心算法实现）"><a href="#55-跳跃游戏（Java贪心算法实现）" class="headerlink" title="55. 跳跃游戏（Java贪心算法实现）"></a>55. 跳跃游戏（Java贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean canJump(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> cover = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= cover;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i + nums[i] &gt; cover)&#123;<br>                cover = i + nums[i];<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(cover &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II（Java贪心算法实现）"><a href="#45-跳跃游戏-II（Java贪心算法实现）" class="headerlink" title="45. 跳跃游戏 II（Java贪心算法实现）"></a>45. 跳跃游戏 II（Java贪心算法实现）</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs glsl">class Solution &#123;<br>    public <span class="hljs-type">int</span> jump(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">length</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前定义的最小下标</span><br>        <span class="hljs-type">int</span> currDistance = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">length</span>;i++)&#123;<br>            nextDistance = Math.<span class="hljs-built_in">max</span>(nums[i] + i, nextDistance);<br>            <span class="hljs-keyword">if</span>(i == currDistance)&#123;<br>                result++;<br>                currDistance = nextDistance;<br>                <span class="hljs-keyword">if</span>(nextDistance &gt;= nums.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>贪心算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230904</title>
    <link href="/2023/09/04/leetcode-notes-20230904/"/>
    <url>/2023/09/04/leetcode-notes-20230904/</url>
    
    <content type="html"><![CDATA[<h2 id="47-全排列-II（C-回溯算法实现）"><a href="#47-全排列-II（C-回溯算法实现）" class="headerlink" title="47. 全排列 II（C++回溯算法实现）"></a>47. 全排列 II（C++回溯算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-comment">//在叶子结点收集元素</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i ++)&#123;<br>            <span class="hljs-comment">// 判断同层中是否已经使用了相同的元素</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示已经使用过了</span><br>            &#125;<br><br>            <span class="hljs-comment">//表示当前元素没有使用过</span><br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">false</span>)&#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracing</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="51-N-皇后（C-回溯法实现）"><a href="#51-N-皇后（C-回溯法实现）" class="headerlink" title="51. N 皇后（C++回溯法实现）"></a>51. N 皇后（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//判断是否合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//检查列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; row;i ++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][col] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//检查左上角45度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//检查右下角135度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n)&#123;<span class="hljs-comment">//表示到最后一层了</span><br>            result.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//循环棋盘，然后判断是否合法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(row, col, chessboard, n))&#123;<span class="hljs-comment">//如果合法，那么修改棋盘</span><br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<span class="hljs-comment">//放置皇后</span><br>                <span class="hljs-built_in">backtracing</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(n, <span class="hljs-number">0</span>, chessboard);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230828</title>
    <link href="/2023/08/28/leetcode-notes-20230828/"/>
    <url>/2023/08/28/leetcode-notes-20230828/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）78-子集（C-回溯法实现）"><a href="#（复习）78-子集（C-回溯法实现）" class="headerlink" title="（复习）78. 子集（C++回溯法实现）"></a>（复习）78. 子集（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>    &#125;<br><br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="90-子集-II（C-回溯实现）"><a href="#90-子集-II（C-回溯实现）" class="headerlink" title="90. 子集 II（C++回溯实现）"></a>90. 子集 II（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br><br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="491-递增子序列（C-回溯法实现递增子序列）"><a href="#491-递增子序列（C-回溯法实现递增子序列）" class="headerlink" title="491. 递增子序列（C++回溯法实现递增子序列）"></a>491. 递增子序列（C++回溯法实现递增子序列）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//题目中要求大于2的序列</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-comment">// return;不能加return是因为，需要取树上的所有结点</span><br>        &#125;<br><br>        <span class="hljs-comment">//定义本层去重需要使用的unordered_set</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]) || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="491-递增子序列（C-回溯法实现递增子序列，使用int数组代替unordered-set）"><a href="#491-递增子序列（C-回溯法实现递增子序列，使用int数组代替unordered-set）" class="headerlink" title="491. 递增子序列（C++回溯法实现递增子序列，使用int数组代替unordered_set）"></a>491. 递增子序列（C++回溯法实现递增子序列，使用int数组代替unordered_set）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//题目中要求大于2的序列</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-comment">// return;不能加return是因为，需要取树上的所有结点</span><br>        &#125;<br><br>        <span class="hljs-comment">//定义本层去重需要使用的unordered_set</span><br>        <span class="hljs-comment">//unordered_set&lt;int&gt; uset;</span><br>        <span class="hljs-comment">//使用int类型数组代替unordered_set</span><br>        <span class="hljs-type">int</span> unums[<span class="hljs-number">201</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]) || unums[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-comment">//uset.insert(nums[i]);</span><br>            unums[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="46-全排列（C-回溯法实现，使用used数组标记是否使用过）"><a href="#46-全排列（C-回溯法实现，使用used数组标记是否使用过）" class="headerlink" title="46. 全排列（C++回溯法实现，使用used数组标记是否使用过）"></a>46. 全排列（C++回溯法实现，使用used数组标记是否使用过）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//因为是全排列，所以当path的长度等于nums的长度时，得到结果</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示当前nums[i]元素已经使用过</span><br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(nums, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>paper-reading-Transformer</title>
    <link href="/2023/08/27/paper-reading-Transformer/"/>
    <url>/2023/08/27/paper-reading-Transformer/</url>
    
    <content type="html"><![CDATA[<h2 id="Transformer-Attention-Is-All-You-Need"><a href="#Transformer-Attention-Is-All-You-Need" class="headerlink" title="Transformer(Attention Is All You Need)"></a>Transformer(Attention Is All You Need)</h2><p><a href="https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">Attention Is All You Need</a></p><p>参考：跟李沐学AI-<a href="https://www.bilibili.com/video/BV1pu411o7BE/?vd_source=4f4d3466cdc2c5a2539504632c862ce7">Transformer论文逐段精读【论文精读】</a></p><h3 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h3><p>首先摘要说明：目前，主流的序列转录（序列转录：给一个序列，转录为另外一个新的序列）模型都是基于RNN和CNN，且一般都是一个encoder和decoder的架构。在这些encoder和decoder中通常会使用注意力机制。然后，作者接着说，这篇文章提出了一个<strong>简单</strong>的只使用了注意力机制的模型架构-Transformer，而没有使用RNN或CNN等卷积操作。接着，作者将该架构在两个机器翻译任务上进行实验，可以实现更好的性能和更少的训练时间。</p><h3 id="导言（Introduction）"><a href="#导言（Introduction）" class="headerlink" title="导言（Introduction）"></a>导言（Introduction）</h3><p>首先作者介绍了RNN、GRN等主流的sequence models，然后作者指出，这里面有两个比较主流的模型，一个叫做语言模型，海有一个是当输出结构化信息比较多的时候的encoder和decoder架构的模型。</p><p>然后，作者讲了RNN的特点和缺点，在RNN中给一个序列，其做法是对序列从左往右一步一步往前做的。当前第t个词的状态$h_t$是由前一个词的状态$h_{t-1}$和当前词本身决定的。这样的话RNN就可以把前边学到的历史信息通过$h_{t-1}$放到当下，然后和当前词做一些计算，然后输出。RNN存在的问题比较难以并行。</p><p>在第三段，作者指出，Attention机制已经在RNN中使用，主要是用在解决，如何将encoder的信息传递给decoder中。</p><p>在导言的最后一段中，作者指出，本篇文章提出了一个叫做Transformer的模型，不再使用之前的RNN layers，而是纯注意力机制。</p><h3 id="相关工作（Background）"><a href="#相关工作（Background）" class="headerlink" title="相关工作（Background）"></a>相关工作（Background）</h3><p>首先，作者指出如何使用卷积神经网络来替换掉RNN layers来减少时序计算。同时，又指出，使用CNN无法对比较长的序列进行建模。但是，如果使用Transformer的话，每次都能看到所有的像素。但是，CNN比较好的地方是可以做多个输出的channels，一个channel可以认为CNN去识别不一样的模式。为了实现和CNN一样的能够输出多个channel的功能，文中提出了一个叫做Multi-Head Attention机制（多头注意力机制）。</p><p>接下来，作者提出了Self-Attention（自注意力机制）。然后最后，作者指出，Transformer是第一个只依赖于自注意力机制的encoder和decoder架构模型。</p><h3 id="模型架构（Model-Architecture）"><a href="#模型架构（Model-Architecture）" class="headerlink" title="模型架构（Model Architecture）"></a>模型架构（Model Architecture）</h3><p>首先，作者说明大多数的序列转录模型中都具有encoder和decoder架构。然后，解释encoder是将一个序列表示为中间的向量表示形式，然后decoder是将中间的向量表示形式，表示为最后的输出。这里的输入和输出不一定具有同样的长度（例如：英文转为中文的话，长度不一定是一样的）。但是需要注意的是，在decoder解码的时候，结果输出是一个一个生成的，文中指出这种解码机制叫做自回归（auto-regressive模型，在这个模型中输入又是输出，即：过去时刻的输出又是当前时刻的输入）。</p><p>Transformer模型架构是将self-attention、point-wise和FCN（全连接层）堆叠在一起的。整个Transformer模型架构如下图所示。</p><p><img src="/../image/../images/Transformer/Transformer-architecture.png" alt="Transformer模型架构"></p><p>上图中，左边部分为Transformer的encoder架构，右边部分为decoder架构。其中，encoder的输入是序列（可以是图片序列、语句序列等），decoder的输入是上一个decoder的输出。</p><p><em><strong>编码器encoder</strong></em></p><p>首先，作者介绍了encoder：使用6个完全一样的上图中的encoder组成。作者将6个encoder中的每一个叫做layer，其中每个layer中有两个sub layer。第一个sub layer叫做“Multi-Head self-attention”机制，第二个sub layer叫做point wise FFN（其实就是一个MLP前向传播网络）。对每个子层使用一个残差连接。最后使用一个layer normalization（层级正则化）。其中，$LayerNorm(x+Sublayer(x))$表示，针对每个encoder层来说，输入x首先经过sublayer层然后和x进行相加，之后再通过一个Norm层。文中说，将每个encoder层的输出向量维度设置为512。（这里和CNN不一样，在基于CNN架构的模型中对向量的维度是长度方向上减少，而channel方向上增加，这里只是使用一个固定维度为512的向量，所以Transformer相对来说架构比较简单）</p><p><em><strong>解释LayerNorm（以及为什么在Transformer的架构中不使用BatchNorm）</strong></em></p><p><img src="/../images/Transformer/layer-norm-reason.jpg" alt="为什么使用Layer Norm而不是Mini Batch Norm"></p><p>上图中，解释了为什么Transformer中不使用Batch Norm而是使用Layer Norm。</p><p><em><strong>解码器decoder</strong></em></p><p>Transformer中decoder和encoder的架构很相似，数量也是N&#x3D;6个进行堆叠。不一样的地方在于decoder中加入了第三个sub layer，这个第三子层同样是一个多头注意力机制，其作用为防止decoder在做预测的时候，不能看到当前t时刻之后的输入（因为Transformer中使用了注意力机制，同一时刻理论上所有的输入都是可以看到的，但是这样在解码的时候不合理，所以使用了这个Masked Multi-Head Attention Encoder，即使用一个掩码机制来限制decoder去接受当前时刻t之后的输入，从而保证训练和预测的时候行为是一致的。）</p><p><em><strong>注意力Attention</strong></em></p><p>首先作者介绍了Attention Function的含义：attention function是一个将一个query和一系列key-value对映射为输出（output）的函数。这里的query、keys、values、output都是一些向量。output是values的加权和，所以output的维度和values的维度是一样的。对于每个value对应的权重是该value对应的key与query计算相似度之后得到的。（这里计算相似度的函数不一样就会导致不一样的注意力机制）</p><p><em><strong>Scaled Dot-Product Attention</strong></em></p><p><img src="/../image/../images/Transformer/attention-eqution.jpg" alt="提出的Attention机制计算公式"></p><p>文中提出的注意力机制中，query和key是等长的，都等于$d_k$，values为$d_v$。作者指出，将query和key做点积，结果作为相似度（如果两个等长向量的内积越大，即余弦值越大，那么两个向量的相似度越大）。将得到的结果除以$\sqrt{d_k}$，即向量的长度。query会和每一个key做内积，然后将得到的结果输入到softmax当中，得到N个非负的且加起来和等于1的权重。然后，将这些权重作用在N个key对应的N个value上面，这样就得到了最后的输出。</p><p><em><strong>实际运算过程中对上述相似度计算过程的处理</strong></em></p><p><img src="/../images/Transformer/query-key-number-comparision.jpg" alt="query key-value矩阵形式对比"></p><p>query可以写成一个矩阵$Q$（因为不止一个query），且需要注意的是上图中展示的Q（多个query组合得到的矩阵）中的query数量可以和key的数量不一致，但是每个query与key的长度一定是一致的，这样才能做内积。上图中的两个矩阵相乘之后，就可以得到一个$N\times M$的矩阵。然后，将该矩阵除以$\sqrt{d_k}$，之后对结果的每一行做softmax即可（行与行之间是独立的）。然后，将结果乘以values即可。最后就可以得到$N\times d_v$的矩阵。</p><p>然后，作者指出了上述提出的注意力机制和传统的注意力机制的区别。一般来说有两种注意力机制：加型注意力（可以处理query和key不等长的情况）。另外一个叫做点积的注意力机制。本文提出的注意力机制基本上和点积注意力机制一样，只是本文的注意力机制中除了$\sqrt{d_k}$。</p><p><em><strong>为什么本文提出的注意力机制需要除以一个$\sqrt{d_k}$</strong></em></p><p>作者解释：当$d_k$不是那么大的时候，其实除与不除基本没有区别。但是对于较长的key和query来说，两者点积之后得到的矩阵，在通过softmax之后，会更加向1和0（两端）靠拢。这样的话，最后计算梯度的时候，梯度会比较小，那么在训练的时候就会出现模型跑不动（训练不起来）情况。</p><p><img src="/../images/Transformer/Scaled-Dot-Product-Attention-and-Multi-Head-Attention.jpg" alt="文中提出的点击缩放注意力计算函数和多头注意力机制"></p><p>上图左子图中包含Masked Attention，具体来说，假设query和key是等长的，那么对t时刻，query与key计算时，应该只看$k_1-k_{t-1}$时刻，而不能看$k_t$及其之后的时刻。（因为$k_t$在t时刻还没有计算出来，但是对于注意力机制来说，实际上query可以看到所有key中内容，且query会与key中左右内容进行计算，计算是可以算的，但是在计算最后注意力机制输出的时候不要使用t时刻以及t时刻之后的key的内容即可，实际操作的时候，mask中将t以及t时刻之后的query与key计算的值换成非常大的负数，那么在通过softmax的时候，这些非常大的负数对应的权重就是0。）</p><p><em><strong>Multi-Head Attention机制</strong></em></p><p><img src="/../image/../images/Transformer/Multi-Head-attention-eqution.jpg" alt="Multi-Head Attention"></p><p>作者在文中说，通过将query&#x2F;key&#x2F;value投影到一个低维的向量中，投影h次，然后再做h次的注意力函数，然后将每个函数的输出并到一起，然后再投影得到最终的输出。为什么使用多头注意力机制，是因为本文提出的注意力机制实际上是没有可学习的参数，那么上图中的多头注意力机制中对于query&#x2F;key&#x2F;value输入首先通过的Linear线性层中的w和b是可以学习的。也就是说，给h次机会，希望这个多头注意力机制能够学习到不同的投影方法，使得在投影后的那个空间可以匹配得到不同模式需要的相似函数。（这个多头注意力机制与CNN中的多个输出通道有一种相似的感觉）</p><p>在实际操作中，作者指出，由于注意力机制中残差连接的存在，输入和输出维度本来就是一样的，那么这个时候使用h个多头注意力机制，对应到每个注意力机制的输出就是原始的单注意力机制&#x2F;h（这里原始的输入输出维度为512，h&#x3D;8，那么多头注意力机制中每个头的输入输出维度为512&#x2F;8&#x3D;64）</p><p><em><strong>在Transformer架构中使用注意力机制</strong></em></p><p><img src="/../image/../images/Transformer/Transformer-architecture.png" alt="Transformer模型架构"></p><p>上图左子图为encdoer，其中首先将input输入复制三份，分别作为Multi-Head Attention中的key&#x2F;value&#x2F;query（这就叫做自注意力机制）。右子图中为decoder，其中首先为一个Masked Multi-Head Attention机制（前边已经解释过），然后是一个和encoder一样的Multi-Head Attention（该注意力层中，key&#x2F;value来自于encoder，而query来自于decoder的第一个Masked Multi-Head Attention）。</p><p><em><strong>Point wise Feed Forward Networks</strong></em></p><p><img src="/../image/../images/Transformer/FFN.jpg" alt="FFN"></p><p>其实，就是一个全连接前向传播网络，就是一个MLP（多层感知机）。但是，作者指出，和传统的FFN不一样的地方在于，其将序列中的每个点（可以理解为，加入输入是一段英文序列，那么一个点就表示一个单词）做一次FFN，即对每个词作用同样的一个MLP（共享权重）。其中，x表示一个512的向量。其中的$W_1$会将512投影成2048维的向量。然后，$W_2$会把2048维的向量又投影回512。</p><p><em><strong>扩展：Transformer与CNN的区别</strong></em></p><p><img src="/../images/Transformer/Transformer%E4%B8%8ERNN%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="Transformer与CNN的区别"></p><p>上图中左边为Transformer的注意力机制，右边为RNN（循环神经网络）。其中，RNN为了得到历史信息，其需要在t时刻使用t-1时刻的信息接入，这种就会造成一个问题，当前t时刻的信息会越来越大。而对于Transformer来说，其做到与RNN相同的获得历史全局信息的过程是使用多个注意力头。</p><p><em><strong>embedding and softmax层</strong></em></p><p>Transformer的输入是多个词源（token），那么在处理的时候需要将每个token映射为一个向量，那么embedding就是针对任何一个token，学习一个长为d的向量来表示。编码器和解码器都有一个embedding过程。最后在softmax之前的Linear线性层也需要一个embedding，这三个embedding层是同样的权重，这样训练起来会简单一些。还有一点，作者在文中说到，将权重乘了$\sqrt{d_{model}}$（原始论文中，$d_{model}$就是512）。因为，对于embedding层来说，当学习的向量维度变大之后，那么权重值就会变小，乘以$d_{model}$之后，再将embedding之后的token对应的向量与下边的positional encoding层进行相加，会使得两个向量在一个大概相同的scale进行。</p><p><em><strong>positional encoding层</strong></em></p><p>有这个层的原因是：attention层是不会有时序信息的。具体的公式如下：</p><p><img src="/../images/Transformer/%E6%97%B6%E5%BA%8F%E4%BF%A1%E6%81%AF%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.jpg" alt="Transformer中positional encoding是如何计算的"></p><p>上式中，positional encoding是使用周期不一样的sin和cos计算出来的。</p><p><em><strong>为什么使用自注意力机制</strong></em></p><p><img src="/../images/Transformer/multi-comparision-table.jpg" alt="不同类型层的最大路径长度、每层复杂性和最小顺序操作数（将Attention和受限Atten与RNN和CNN进行比较）"></p><p>上表中，比较了四种不同类型的层的计算复杂度、顺序计算复杂度（就是说下一步计算需要等前边n步计算完成才能进行计算）、最大路径长度（一个信息从一个点走到另一个点需要走多远）。从表中可以看出，当序列的长度和整个模型宽度差不多的时候且深度都一样的话，实际上attention、rnn、cnn三个模型的复杂度基本上是差不多的。但是attention在信息的糅杂性上好一些。</p><p>实际上，attention由于对模型做的假设很少，所以需要更多的数据和更大的模型才可以训练收敛。所以现在基于Transformer的模型都是特别大和特别贵。</p><h3 id="训练设置（Training-Settings）"><a href="#训练设置（Training-Settings）" class="headerlink" title="训练设置（Training Settings）"></a>训练设置（Training Settings）</h3><p>文中指出，在训练的时候使用AdamW优化器对模型进行优化，同时使用drop out层对模型进行正则化操作，然后还使用Label Smoothing技术（最先出现在Inception V3中）。</p><p>Label Smoothing解释：在使用softmax做最后的输出的时候，传统操作是如果输出接近于1，那么才认为是正确的，但是这里采用设置阈值为0.1（表示只要对一个词预测的置信度等于或超过0.1，那么就认为是正确的。）</p><p>但是使用这种技术会导致最后的模型不确信度会增加。</p><p><em><strong>Transformer中超参数的比较</strong></em></p><p><img src="/../images/Transformer/Transformer%E4%B8%AD%E8%B6%85%E5%8F%82%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83.jpg" alt="Transformer中超参数的比较"></p><p>虽然上表中看上去很多超参数，但是在实际训练的时候，其中能调节的：N、$d_{model}$、h（多头注意力中的头的数量h），其他的超参数都是计算得到的。</p><h3 id="结论（Conclusion）"><a href="#结论（Conclusion）" class="headerlink" title="结论（Conclusion）"></a>结论（Conclusion）</h3><p>结论中首先说明，本文使用Transformer模型应用在机器翻译任务中，同时取代了之前使用较多的RNN layers，转而使用multi-headed slef-attention机制（这个也是Transformer模型的核心所在）。同时，结论又指出，在机器翻译任务上，Transformer相较于RNN或CNN架构的模型，具有更好性能和更快的训练收敛速度。然后，作者又说，对于Transformer这种纯注意力机制的模型感到激动（这在后边的爆发的基于Transformer的各种任务模型架构上得到了印证）。将Transformer模型架构用在输入形式不单纯为文本形式的其他形式，例如图片、视频等也是作者未来研究的方向。同时，使得生成不那么有序列也是未来的研究目标（个人举例：DETR中对N&#x3D;100个预测框的生成就是一次性得到的）。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>这篇文章写作很简洁，一段话基本上就是在写一件事情。在写文章的时候可以将一些不重要的东西放到附录里面。</p><p>Attention实际上只是做了整个序列信息的的聚合操作。后边的MLP等层是缺一不可的。如果缺少了这些Attention实际上是什么都学不到的。</p>]]></content>
    
    
    <categories>
      
      <category>Paper Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Object Detection</tag>
      
      <tag>Paper Reading</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>paper-reading-Conditional-DETR</title>
    <link href="/2023/08/26/paper-reading-Conditional-DETR/"/>
    <url>/2023/08/26/paper-reading-Conditional-DETR/</url>
    
    <content type="html"><![CDATA[<h2 id="Conditional-DETR"><a href="#Conditional-DETR" class="headerlink" title="Conditional DETR"></a>Conditional DETR</h2><p><a href="https://openaccess.thecvf.com/content/ICCV2021/papers/Meng_Conditional_DETR_for_Fast_Training_Convergence_ICCV_2021_paper.pdf">Conditional DETR for Fast Training Convergence</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Object Detection</tag>
      
      <tag>Paper Reading</tag>
      
      <tag>Conditional DETR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>paper-reading-DEFORMABLE-DETR</title>
    <link href="/2023/08/23/paper-reading-DEFORMABLE-DETR/"/>
    <url>/2023/08/23/paper-reading-DEFORMABLE-DETR/</url>
    
    <content type="html"><![CDATA[<h2 id="DEFORMABLE-DETR"><a href="#DEFORMABLE-DETR" class="headerlink" title="DEFORMABLE DETR"></a>DEFORMABLE DETR</h2><p><a href="https://arxiv.org/pdf/2010.04159.pdf">DEFORMABLE DETR: DEFORMABLE TRANSFORMERS FOR END-TO-END OBJECT DETECTION</a></p><p><em>参考：AI-杂货铺-<a href="https://www.bilibili.com/video/BV1He4y18711/?spm_id_from=333.337.search-card.all.click&vd_source=4f4d3466cdc2c5a2539504632c862ce7">Transformer跨界CV又一佳作！Deformable DETR：超强的小目标检测算法！</a></em></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>摘要部分，作者主要说明了如下几点：</p><ol><li>为了解决DETR中使用Transformer架构在处理图像特征图时的局限性而导致的收敛速度慢，特征空间分辨率有限的问题；</li><li>Deformable DETR只关注和参考周围的一小部分关键采样点（例如对一个输入到encoder中的图片拉直后的向量，每个像素点只关注其周围的几个像素点，互相计算相似度即可，不需要和所有的像素点计算相似度），并获得了更好的效果（尤其是在小目标任务当中），收敛时间相较于DETR减少了近10倍；</li></ol><p><strong>延伸：YOLO检测小目标效果不好是因为网络越深检测小目标的效果越不好，同时YOLO中图片的输入尺寸较小</strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><em><strong>DETR存在的问题</strong></em></p><p>原始的DETR需要更多的Epochs数量才收敛；DETR在检测小物体时性能不好，导致检测小物体性能不好的原因是因为Transformer架构在初始化时，其注意力模块对特征图中所有像素施加了几乎一致的注意力权重（即在初始化时，注意力机制没有被唤醒，特征图中的一些很有意义的像素点没有被注意力机制关注到），因此训练epochs数量很多（训练Epochs数量增加之后，就会激活注意力机制对图像特征的关注）。</p><p>同时，作者指出Transformer中的自注意力机制是针对于图像像素数量的二次计算，这在处理高分辨率特征图时会具有非常高的计算和记忆复杂性。（Transformer中计算复杂度与图像的宽度W和高度H成正相关，例如：一张图片为100x100，那么拉直之后输入到encoder的时候为10000，然后每个像素点与自己和其他像素点计算相似度，那么计算量就是10000x10000，就是十亿，计算代价太高，而且没有共享参数）这就导致原始的DETR是耗费大量资源的，同时还不能处理高分辨率图片。</p><p><em><strong>Deformable Convolution（可变形卷积）</strong></em></p><p>可变形卷积是一种处理稀疏空间位置的强大而有效的机制，这种机制可以很好地解决上述问题，但是可变形卷积缺少元素之间的关系建模机制，而关系建模（全局建模能力）是DETR成功的关键所在。</p><p><strong>Deformable DETR中，可变形卷积思想的作用就是将原来的注意力机制中，每个像素点和周围的像素点进行相似度计算转为，每个像素点注意力进行偏移（使得每个像素点注意力在一些重要的地方），但是这样带来一个问题就是可变性卷积无法关注注意力集中的地方相似的特征，即点与点之间的关系建模等（为什么可变形卷积关注的是重要特征，希望模型去学习重要特征之间有什么关系），这就需要结合DETR的全局建模能力来解决这一问题。</strong></p><p><em><strong>Deformable DETR</strong></em></p><p><img src="/../images/Deformable-DETR/Deformable-DETR-structure.jpg" alt="Deformable DETR"></p><p>Deformable DETR结合了可变形卷积的稀疏建模能力，同时又结合了DETR的关系建模能力。作者提出了<strong>可变形注意力模块</strong>，关注一小部分采样位置，作为所有特征图像素中突出关键元素的预滤波器。同时，该模块可以很轻松地扩展以聚合多尺度特征，而不需要FPN。</p><p><strong>可变形注意力模块</strong></p><p>针对某个像素点周边的像素进行采样，同时该模块还具有聚合多尺度特征的能力（<strong>在聚合多尺度特征的时候如果考虑细致的话需要进行特征对齐，如果考虑的不细致的话就是简单的拼接</strong>）。在该篇文章中，作者就做了对齐的操作。（<strong>延伸：使用FPN网络，例如类似于UNet一样，进行多尺度操作，这样的特征融合之后是没有对齐的，只是简单做了拼接操作</strong>）</p><p>作者提出的可变形注意力模块替代了传统的Transformer架构中的attention模块。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>相关工作对Transformer和DETR介绍较多，可以直接去读两者相关的论文。</p><h3 id="文章主体部分（第四章-Methods）"><a href="#文章主体部分（第四章-Methods）" class="headerlink" title="文章主体部分（第四章-Methods）"></a>文章主体部分（第四章-Methods）</h3><p><em><strong>Deformable Attention模块</strong></em></p><p><img src="/../images/Deformable-DETR/Deformable-attention-module.jpg" alt="Deformable Attention模块（来自原始论文）"></p><p>文中指出，传统的Transformer中的注意力机制存在遍历所有可能的空间位置。（<strong>论文中“the deformable attention module only attends to a small set of key sampling points around a reference point, regardless of the spatial size of the feature maps,”，这句话中的reference point可以理解为：图片特征map中的一些坐标点（特征Map中的一些初始化位置点）。在论文对应的源码中，在每个坐标点周围只设置了K&#x3D;4个采样点</strong>）</p><p><em><strong>Deformable Attention公式理解</strong></em></p><p>$DeformAttn(z_q, p_q, x)&#x3D;\sum_{m&#x3D;1}^M W_m[\sum_{k&#x3D;1}^K A_{mqk}\cdot W’<em>m x(p_q + \Delta p</em>{mqk})]$</p><p>其中，$x$文中说明为图片的特征Map，但是实际上更可以理解为输入到Encoder中的序列，然后该序列的宽为W，高为H。其中每个点对应的channel通道数为C。文中设定$q$索引一个叫做$z_q$的内容query。（这里的内容query就是每个点对应的通道数为channel的特征向量）然后，$p_q$表示特征图Map中的某个q索引位置上的点。m表示多头注意力机制中的头的数量（源码当中设置为M&#x3D;8）。k表示采样点数量，也就是从当前点开始与索引值在k这个范围内的所有点之间计算交互（源码中的K&#x3D;4）。</p><p>公式中，$\Delta p_{mqk}$表示采样偏移量，是需要通过训练得到的。$A_{mqk}$表示在第m个注意力头中的第q个参考点周围的共k个采样点中每个采样点分配的注意力权重（也就是说K个采样点权重相加应当为1），也是需要训练得到的。</p><p><img src="/../images/Deformable-DETR/%E5%8F%AF%E5%8F%98%E5%BD%A2DETR%E4%B8%ADdelta%E5%81%8F%E7%A7%BB%E7%9A%84%E8%A7%A3%E9%87%8A.jpg" alt="图片-可变形注意力机制中偏移量的解释（来自：AI-杂货铺-[Transformer跨界CV又一佳作！Deformable DETR：超强的小目标检测算法！](https://www.bilibili.com/video/BV1He4y18711/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4f4d3466cdc2c5a2539504632c862ce7)）"></p><p>其中，蓝色点表示当前点（reference point），然后按照K&#x3D;4的采样点数量，蓝色点周围的红色点是需要进行计算交互的，但是，由于红色点左上角的绿色点才是蓝色点真正地需要关注的，那么这个时候偏移量就是绿色点针对于蓝色点左边的红色点的偏移。</p><p><img src="/../images/Deformable-DETR/%E5%8F%AF%E5%8F%98%E5%BD%A2DETR%E4%B8%ADdelta%E5%81%8F%E7%A7%BB%E7%9A%84%E8%A7%A3%E9%87%8A-%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%82%B9%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%E6%97%B6%E9%87%87%E5%8F%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.jpg" alt="图片-可变形DETR中delta偏移的解释-以及注意力点没有索引时采取的解决方法（来自：AI-杂货铺-[Transformer跨界CV又一佳作！Deformable DETR：超强的小目标检测算法！](https://www.bilibili.com/video/BV1He4y18711/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4f4d3466cdc2c5a2539504632c862ce7)"></p><p>同时，还存在一个问题，如果上图中蓝色点关注右上角的黑色点的时候，注意力没有正好落在黑点上，那么这个时候，关注的点的权重是由其周围四个点根据距离加权之后得到的。</p><p><strong>偏移量是由$z_q$得到的，可变形机制就是说的偏移量可变。</strong></p><p>公式中，$W$和$W’$都是全连接层，也是需要训练来决定其中的权重的。偏移量是通过将feature map中每个点对应的特征$z_q$输入到一个FC（包含W和b）中，在反向传播过程中去更新FC中的W和b即可。</p><p>原始论文中有语句：Both $\Delta p_{mqk}$ and $A_{mqk}$ are obtained via linear projection over the query feature $z_q$.<br>其中，$\Delta p_{mqk}$和$A_{mqk}$是由$z_q$输入到FC层中得到的。然后在实现的时候，作者说明：In implementation, the query feature $z_q$ is fed to a linear projection operator of 3MK channels, where the first 2MK channels encode the sampling offsets $\Delta p_{mqk}$, and the remaining MK channels are fed to a softmax operator to obtain the attention weights $A_{mqk}$.</p><p><em><strong>Multi-scale Deformable Attention 模块理解（本篇论文的核心）</strong></em></p><p>作者首先强调，多尺度在很多任务当中都很work，然后又说Deformable Attention Module模块也可以扩展到多尺度。</p><p><img src="/../images/Deformable-DETR/MSDeformableAttention.jpg" alt="MSDeformableAttention Module(多尺度可变形模块)"></p><p>上式中，$\hat{p}_q \in [0, 1]^2$表示对q索引对应的query element中的参考点的归一化坐标（相当于多尺度对齐）。</p><p>多尺度可变形注意力模块中，计算方式基本上和单尺度的一样，只是从原来的对单个feature map进行操作改为对L层多尺度feature map进行操作。这里需要注意的是，其中的$\phi_l (\hat{p}_q)$表示将归一化之后的坐标针对l层特征的大小，进行缩放，从而找到对应l层特征的参考点的实际位置，然后在该层特征下计算可变形注意力。</p><p><img src="/../images/Deformable-DETR/MSDeformableAttention-DETR.jpg" alt="可变形DETR检测器总览"></p><p>上图中是对上述公式的一个详细的形象化概括。其中，对于不同level的特征，其位置编码（positional encoding）除了该层级对应的位置编码之外，还需要加上一个层级的位置编码（主要是用来区分归一化坐标相同的点在不同层级feature map上具有实际不同的位置编码）。此外，这篇文章中的位置编码也是可学习的。</p><p><em><strong>注意：上图中的Object Queries数量由传统的DETR的N&#x3D;100，增加到了N&#x3D;300</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>Paper Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Object Detection</tag>
      
      <tag>Paper Reading</tag>
      
      <tag>DEFORMABLE DETR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>paper-reading-DETR</title>
    <link href="/2023/08/23/paper-reading-DETR/"/>
    <url>/2023/08/23/paper-reading-DETR/</url>
    
    <content type="html"><![CDATA[<h2 id="DETR（基于Transformer架构的目标检测方法开山之作）"><a href="#DETR（基于Transformer架构的目标检测方法开山之作）" class="headerlink" title="DETR（基于Transformer架构的目标检测方法开山之作）"></a>DETR（基于Transformer架构的目标检测方法开山之作）</h2><p><a href="https://arxiv.org/pdf/2005.12872.pdf">End-to-End Object Detection with Transformers</a></p><p><em>参考：跟着李沐学AI-<a href="https://www.bilibili.com/video/BV1GB4y1X72R/?spm_id_from=333.788&vd_source=beab624366b929b20152279cfa775ff6">DETR 论文精读【论文精读】</a></em></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在摘要部分作者，主要说明了如下几点：</p><ol><li>DETR是一个端到端（end-to-end）框架，释放了传统基于CNN框架的一阶段（YOLO等）、二阶段（FasterRCNN等）目标检测器中需要大量的人工参与的步骤，例如：NMS后处理或proposals&#x2F;anchors&#x2F;centers生成等。使其成为一个真正意义上的端到端（end-to-end）的目标检测框架；</li><li>DETR还可以很方便地迁移到诸如全景分割等其他任务当中，只需要在最后的FFN（前向传播头）之后增加分割头等即可；</li><li>DETR在当时发表出来的时候（2020年5月左右）已经达到了和经过长时间调参的FasterRCNN基线一样的精度&#x2F;速度&#x2F;内存占用（基准为COCO2017）；</li><li></li></ol><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><em><strong>DETR模型架构</strong></em></p><p><img src="/../images/DETR/DETR_structure.jpg" alt="DETR"></p><p>第一步，将图片输入到一个CNN中，得到feature map。</p><p>第二步，将图片拉直，送入到transformer encoder-decoder。其中，encoder的作用是为了进一步学习全局的信息，为最后的decoder(也就是为最后的出预测框做铺垫)。使用transformer的encoder是为使得图片中每一个特征点与图片中的其他特征有交互，这样就知道了哪块是哪个物体。这种全局的特征非常有利于移除冗余的框（全局建模）。</p><p>第三步，decoder生成框的输出，其中输入decoder的不只有encoder的输出，还有object query（用来限制decoder输出多少个框），通过object query和特征不停的做交互（在decoder中间去做self-attention操作），从而得到最后输出的框（论文中，作者选择的框数量为N&#x3D;100）。</p><p>第四步，计算出来的N&#x3D;100个框与Ground Truth做匹配然后计算loss（本部分是DETR这篇文章中最重要的一个贡献）。作者使用二分图匹配的方法去计算loss，从而决定出在预测出来的100个框中，有哪几个框是与ground-truth框对应的。匹配之后，就会和普通的目标检测一样去计算分类的loss、再算bounding box的loss。剩下的没有匹配上的框就会被标记为没有物体，也就是所谓的背景类。</p><p><em><strong>DETR推理流程</strong></em></p><p>推理的时候前三步和训练时保持一样，第四步因为是test过程，因此只需要在最后的输出上设置一下置信度阈值即可得到预测框，（原始论文中，将置信度设置为0.7，即置信度大于0.7的预测就是前景物体，所有置信度小于0.7的就被当做背景）。</p><p><em><strong>DETR特性</strong></em></p><p>对大物体识别效果很好（归功于Transformer架构的全局建模能力，而不是像原来一样，预测的物体大小受限制于你设置的anchor大小），对小物体识别效果较差（后续的Deformable DETR就提出了多尺度的DETR，同时解决了DETR训练太慢的问题）；</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><ol><li>集合预测（因为使用集合预测来解决目标检测问题的工作其实并不多）；</li><li>Transformer架构（同时也介绍了parallel decoding，如何不像原来的transformer一样去做自回归预测）；</li><li>介绍了一下目标检测之前的相关工作，其中重点引用了一篇当时最近的工作，指出原来的一阶段或二阶段的目标检测器的性能与初始的猜测（proposals&#x2F;anchors&#x2F;centers等）密切相关，这里作者重点想讲的就是不想使用这些复杂的人工先验知识，因此DETR在这个方面具有优势；</li><li>然后作者介绍了基于RNN的目标检测方法，使用的是自回归模型，时效性就比较差，性能也会比较差；DETR使用了不带掩码信息的decoder之后，可以使得预测输出同时进行，所以DETR的时效性大大增强了；</li></ol><h3 id="文章主体部分"><a href="#文章主体部分" class="headerlink" title="文章主体部分"></a>文章主体部分</h3><p>作者首先介绍了基于二分图匹配的loss目标函数（因为这点比DETR这种架构来说更新，同时DETR架构是比较标准的，比较容易理解的，即便是其中的object query思想，也比较容易讲解，因此作者首先介绍了目标函数），也正是因为这种目标函数，DETR才能做到一对一的预测出框方式。</p><p><em><strong>二分图匹配</strong></em><br>举例理解：假如说有三个工人abc，然后需要完成三个工作xyz，因为所有工人的特点不一样，因此三个工人完成工作的时间等都不一致，因此对三个工人和三个不同的工作来说，会有一个$3\times3$的矩阵，矩阵中对应的每个格子具有不同的数值（这个矩阵就叫做cost matrix，也就是损失矩阵）；那么，这个二分图匹配的最终目的是：我可以给每个工人找到最擅长的工作，然后使得这三个人完成工作之后的代价最低；</p><p>匈牙利算法就是解决这样一个问题的比较好的方式。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scripy库中，包含匈牙利算法的实现：line_sum_assignment。DETR原始论文中使用的也是这个；</span><br><span class="hljs-keyword"></span>这个方法返回的结果就是一个全面的排列：告诉你哪个人应该做哪个事；<br></code></pre></td></tr></table></figure><p>其实，DETR将目标检测问题看成是集合预测问题，其中每个工人可以看成是对应的N&#x3D;100的预测框，然后xyz表示GroundTruth框；<br>那么，这个cost matrix矩阵的每个格子中放的就是每个预测框与GroundTruth框之间的cost（也就是loss）；</p><p>这里的每个格子中表示的loss，就是分类损失和bbox loss，总的来说就是遍历所有预测的框，将这些框与GroundTruth进行计算loss，然后使用匈牙利算法得到最匹配的对应的图片中目标数量的框；</p><p>然后，作者又说，这里与一阶段&#x2F;二阶段的目标检测器一样的道理，都是拿着预测出来的框与GroundTruth逐个计算loss。但是，唯一不同的地方在于DETR是只得到一对一的匹配关系，而不像之前方法一样得到一对多的匹配关系，这样DETR就不需要做后边的NMS后处理步骤。</p><p><em><strong>loss目标函数</strong></em><br>接下来，由于前边步骤得到了所有匹配的框，那么现在才计算真正的loss来做梯度回传。DETR在计算真正的loss（分类loss和bbox loss），其中对于分类loss，作者和原来的计算分类loss方法不一样，而是将DETR中这个地方的log去掉（作者发现去掉之后效果会更好一些）。然后对于bbox loss这里，与之前的loss计算方式也有所不同，原来计算bbox loss是使用L1 loss，但是l1 loss会出现框越大，计算出来的loss容易越大。而同时DETR这种基于Transformer架构的模型，对大目标（预测出大框很友好），那么得到的loss就会比较大，不利于优化。因此，作者不光使用了l1 loss，还使用了GIoU loss。这里的GIoU loss就是一个与框大小无关的loss函数。</p><p><em><strong>DETR详细架构</strong></em></p><p><img src="/../images/DETR/DETR-structure-detail.jpg" alt="DETR详细架构"></p><p>上图中，CONV卷积神经网络的输出向量维度为：2048x25x34，然后使用1x1的卷积将该向量维度减少到256，得到256x25x34的向量，然后使用positional embeddings进行位置编码得到的向量维度也是256x25x34，然后将两个向量相加。</p><p>相加之后，将对应的256x25x34这个向量的HW维度进行拉直得到850x256的向量，其中850就是序列的长度，256就是Transformer的head dimension。然后，经过encoder仍然得到850x256的向量。DETR中作者使用了6个encoder。</p><p>然后，将最后一个encoder的输出向量（维度为：850x256），输入到decoder中。这里，一同输入的还有object queries（可以看作是learned embeddings，可学习的嵌入），准确地说，它就是一个可学习的positional embeddings。其维度为100x256。这里可以将这个object queries作为一个条件condition，就是告诉模型，我给你一个条件，你需要得到什么结果。接着，将两个输入（一个来自encoder编码器的输出，一个来自object queries）反复做cross attention自注意力操作。最后得到一个100x256的特征。</p><p>然后，将最后一个decoder的输出100x256维度的向量通过一个FFN（feed forward network，标准检测头，全连接层）。然后FFN做出来两个预测，一个是类别，一个是bbox位置。原始的DETR是在COCO2017上进行实验的，因此，这里的类别数量就是91类。</p><p>最后，将FFN的输出与Ground Truth根据匈牙利算法计算最佳匹配，然后根据最佳匹配计算loss，然后将loss反向传播，更新模型权重。</p><p><em><strong>DETR中的一些细节</strong></em></p><ol><li><p>decoder部分，首先在object query做自注意力操作，目的是为了移除冗余的框。因为这些object query做自注意力操作之后，就大概之后每个query可能得到什么样的一个框。</p></li><li><p>最后做loss的时候，作者为了让这个模型收敛得更快或训练更稳定。作者在decoder之后加了auxiliary loss。作者在6个decoder的输出之后都做了这个loss。这里的FFN都是共享权重。</p></li></ol><h3 id="文章实验部分"><a href="#文章实验部分" class="headerlink" title="文章实验部分"></a>文章实验部分</h3><p><img src="/../images/DETR/DETR-FasterRCNN-on-COCO.jpg" alt="DETR与FasterRCNN在COCO数据集上的实验结果对比"></p><p>首先，作者介绍了DETR和FasterRCNN在COCO数据集上的结果。发现DETR在大物体上检测的性能更好，而小物体上还是FasterRCNN模型更好一些。这说明DETR使用了Transformer架构，具有较高的全局建模能力，因此DETR想检测多大的目标就检测多大的目标，所以对大目标友好一些。</p><p><em><strong>（延伸）写论文的技巧：当你的想法在一个数据集a上不work的时候，有可能在数据集b上work，如果你的想法很好，但是就是不work的时候，找到一个合适的研究动机其实也是很重要的，找到一个合适的切入点也很重要。</strong></em></p><p><img src="/../images/DETR/transformer-encoder-decoder-attention-display.jpg" alt="DETR中Encoder的自注意力机制可视化展示"></p><p>上图中，作者将Transformer encoder-decoder的自注意力机制可视化。可以看到自注意力机制的巨大威力，三只牛基本上的轮廓基本上都出来了。<br>实际上，当你使用transformer的encoder之后，图像上的东西就可以分的很开了，那么这个时候再去做检测、分割等任务就很简单了。</p><p><img src="/../images/DETR/encoder-size-effect-DETR.jpg" alt="DETR中encoder size对最后模型AP精度的影响"></p><p>上图展示了不同的encoder数量对DETR最后目标检测精度AP的影响。可以发现，随着encoder层数的增加，AP精度是一直在上升的，且没有饱和的趋势，但是层数的增加带来了计算量的增加。</p><p><img src="/../images/DETR/decoder-attention-display.jpg" alt="DETR中decoder中attention可视化结果"></p><p>上图中展示了DETR中decoder attention的分布情况，可以明显看到在遮挡很严重的情况下，大象和小象身上的不同颜色注意力也是很区分开来的。总之，DETR这里的encoder-decoder架构的作用与CNN的encoder-decoder架构的作用其实差不多是一致的。</p><p><img src="/../images/DETR/object-query-display.jpg" alt="DETR中object query的可视化（20个，共100个，N=100）"></p><p>上图展示了20个object query的可视化结果，其中每个正方形代表一个object query，每个object query中出现的多个点表示bounding box。其中，绿色的点表示<strong>小</strong>目标物体，红色点表示水平方向的目标物体，蓝色点表示垂直方向的目标物体。实际上，这里的object query和一阶段目标检测器中的anchors差不多，只不过anchors是预先设定的，而这里的object query是通过学习得到的。总之，这100个query中就像100个问问题的人一样，每个人都会有不同的问问题的方式。需要注意的是，这些object query中都在中间有一个红线，这表示，每个query都会去询问图片中间是否包含大的目标物体，这是因为COCO数据集的问题，因为COCO数据集中很多图片中心都会有一些大物体。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一些基于DETR改进的新工作：<br>Omni DETR, Up DETR, PnP DETR, Smac DETR, Deformable DETR, DAB DETR, Sam DETR, DN DETR, OW DETR, OV DETR,</p><p>pixel to sequence（把输入输出全部搞成序列形式，从而与NLP那边完美兼容）</p>]]></content>
    
    
    <categories>
      
      <category>Paper Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Object Detection</tag>
      
      <tag>Paper Reading</tag>
      
      <tag>DETR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230820</title>
    <link href="/2023/08/20/leetcode-notes-20230820/"/>
    <url>/2023/08/20/leetcode-notes-20230820/</url>
    
    <content type="html"><![CDATA[<h2 id="131-分割回文串（C-回溯法实现）"><a href="#131-分割回文串（C-回溯法实现）" class="headerlink" title="131. 分割回文串（C++回溯法实现）"></a>131. 分割回文串（C++回溯法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//判断字符串是否为回文串的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                <span class="hljs-comment">//截取字符串</span><br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果不是回文数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯过程，返回已经添加的子串</span><br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）93-复原-IP-地址（C-回溯实现）"><a href="#（复习）93-复原-IP-地址（C-回溯实现）" class="headerlink" title="（复习）93. 复原 IP 地址（C++回溯实现）"></a>（复习）93. 复原 IP 地址（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-comment">//判断是否合法的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断start对应的s中的字符是否为0</span><br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//然后进行判断</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end;i++)&#123;<br>            <span class="hljs-comment">//首先判断每个数字是否合法</span><br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果数组都合法，然后计算从start到end对应的数字之和是否超过了255</span><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span></span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span>(pointNum == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">//判断最后一个逗点之后的字符串是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//判断是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointNum += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//递归调用函数，由于加入了一个点，因此下一个开始index应该为i + 2</span><br>                <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">2</span>, pointNum);<br>                pointNum -= <span class="hljs-number">1</span>;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）78-子集（C-实现）"><a href="#（复习）78-子集（C-实现）" class="headerlink" title="（复习）78. 子集（C++实现）"></a>（复习）78. 子集（C++实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtraing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtraing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtraing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230817</title>
    <link href="/2023/08/17/leetcode-notes-20230817/"/>
    <url>/2023/08/17/leetcode-notes-20230817/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）40-组合总和-II（C-回溯算法实现）"><a href="#（复习）40-组合总和-II（C-回溯算法实现）" class="headerlink" title="（复习）40. 组合总和 II（C++回溯算法实现）"></a>（复习）40. 组合总和 II（C++回溯算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义两个数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-comment">//定义回溯函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum ==target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层循环逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i<span class="hljs-number">-1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示树的同层中的上一个一样的元素使用过了</span><br>            &#125;<br><br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//实现了函数中间</span><br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracing</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230802</title>
    <link href="/2023/08/02/leetcode-notes-20230802/"/>
    <url>/2023/08/02/leetcode-notes-20230802/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）131-分割回文串（C-回溯法实现，无优化版）"><a href="#（复习）131-分割回文串（C-回溯法实现，无优化版）" class="headerlink" title="（复习）131. 分割回文串（C++回溯法实现，无优化版）"></a>（复习）131. 分割回文串（C++回溯法实现，无优化版）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//设置函数判断输入字符串是否为回文串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; huiwen, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j;i++, j--)&#123;<br>            <span class="hljs-keyword">if</span>(huiwen[i] != huiwen[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯中单层逻辑实现</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="93-复原-IP-地址（C-回溯实现）"><a href="#93-复原-IP-地址（C-回溯实现）" class="headerlink" title="93. 复原 IP 地址（C++回溯实现）"></a>93. 复原 IP 地址（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-comment">//判断是否为合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//两个逗号之间的字符串的开始位置为0，表示不合法</span><br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//记录两个逗号之间的数字相加是否在255范围之内</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end;i ++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//num累加</span><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <br>            <span class="hljs-comment">//判断num是否大于255</span><br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">//设置的回溯算法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointSum)</span></span>&#123;<br>        <span class="hljs-comment">//判断pointSum等于3，表示是一个可能的结果</span><br>        <span class="hljs-keyword">if</span>(pointSum == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-comment">//首先判断是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                <span class="hljs-comment">//在i位置之后插入一个点</span><br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointSum += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//回溯调用</span><br>                <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">2</span>, pointSum);<br>                pointSum -= <span class="hljs-number">1</span>;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="78-子集（C-回溯法实现）"><a href="#78-子集（C-回溯法实现）" class="headerlink" title="78. 子集（C++回溯法实现）"></a>78. 子集（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230729</title>
    <link href="/2023/07/29/leetcode-notes-20230729/"/>
    <url>/2023/07/29/leetcode-notes-20230729/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）39-组合总和（C-回溯法实现）"><a href="#（复习）39-组合总和（C-回溯法实现）" class="headerlink" title="（复习）39. 组合总和（C++回溯法实现）"></a>（复习）39. 组合总和（C++回溯法实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-type">void</span> backtracing(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> index)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &gt; <span class="hljs-built_in">target</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>            result.push_back(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            path.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            path.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        result.clear();<br>        path.clear();<br>        <br>        backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和-II（C-回溯法实现）"><a href="#40-组合总和-II（C-回溯法实现）" class="headerlink" title="40. 组合总和 II（C++回溯法实现）"></a>40. 组合总和 II（C++回溯法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//核心思想：需要增加used数据，来判断是否使用过</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++)&#123;<br>            <span class="hljs-comment">//判断used数组中是否已经使用过i位置元素</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//先将candidates进行排序</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-built_in">backtracing</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串（C-回溯法实现，无优化版）"><a href="#131-分割回文串（C-回溯法实现，无优化版）" class="headerlink" title="131. 分割回文串（C++回溯法实现，无优化版）"></a>131. 分割回文串（C++回溯法实现，无优化版）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//判断是否为回文字符串的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; huiwen, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--)&#123;<br>            <span class="hljs-keyword">if</span>(huiwen[i] != huiwen[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯法中单层逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//回溯调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230728</title>
    <link href="/2023/07/28/leetcode-notes-20230728/"/>
    <url>/2023/07/28/leetcode-notes-20230728/</url>
    
    <content type="html"><![CDATA[<h2 id="复习：77-组合（C-回溯-剪枝实现）"><a href="#复习：77-组合（C-回溯-剪枝实现）" class="headerlink" title="复习：77. 组合（C++回溯+剪枝实现）"></a>复习：77. 组合（C++回溯+剪枝实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//定义保存路径的数组</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//定义保存整个结果的result数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//回溯实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="216-组合总和-III（C-回溯实现）"><a href="#216-组合总和-III（C-回溯实现）" class="headerlink" title="216. 组合总和 III（C++回溯实现）"></a>216. 组合总和 III（C++回溯实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-comment">//判断path.size()是否等于k</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            <span class="hljs-comment">//判断targetSum是否等于n</span><br>            <span class="hljs-keyword">if</span>(sum == n)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯单层逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>;i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            sum += i;<br>            <span class="hljs-built_in">backtracing</span>(k, n, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合（C-回溯实现）"><a href="#17-电话号码的字母组合（C-回溯实现）" class="headerlink" title="17. 电话号码的字母组合（C++回溯实现）"></a>17. 电话号码的字母组合（C++回溯实现）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义字母和数字之间的映射</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> num2str[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-comment">//0</span><br>        <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-comment">//1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-comment">//2</span><br>        <span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-comment">//3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-comment">//4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-comment">//5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-comment">//6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-comment">//7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-comment">//8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>,<span class="hljs-comment">//9</span><br>    &#125;;<br><br>    vector&lt;<span class="hljs-built_in">string</span>&gt; result;<br>    <span class="hljs-built_in">string</span> s;<span class="hljs-comment">//这个string类型变量就相当于path</span><br><br>    <span class="hljs-comment">//回溯算法实现</span><br>    <span class="hljs-comment">//参数为传入digits地址，起始index下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracing</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; digits, <span class="hljs-built_in">int</span> startIndex</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex == digits.size())&#123;<br>            result.push_back(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//将digits中对应startIndex位置的数字转为数字</span><br>        <span class="hljs-built_in">int</span> digit = digits[startIndex] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">string</span> letters = num2str[digit];<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; letters.size();i++)&#123;<br>            s.push_back(letters[i]);<br>            backtracing(digits, startIndex + <span class="hljs-number">1</span>);<br>            s.pop_back();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">letterCombinations</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> digits</span>)</span> &#123;<br>        s.clear();<br>        result.clear();<br>        <span class="hljs-keyword">if</span>(digits.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        backtracing(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和（C-回溯法实现）"><a href="#39-组合总和（C-回溯法实现）" class="headerlink" title="39. 组合总和（C++回溯法实现）"></a>39. 组合总和（C++回溯法实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    <span class="hljs-type">void</span> backtracing(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> index)&#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-built_in">target</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>            result.push_back(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            path.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        result.clear();<br>        path.clear();<br><br>        backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230727</title>
    <link href="/2023/07/27/leetcode-notes-20230727/"/>
    <url>/2023/07/27/leetcode-notes-20230727/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）108-将有序数组转换为二叉搜索树"><a href="#（复习）108-将有序数组转换为二叉搜索树" class="headerlink" title="（复习）108. 将有序数组转换为二叉搜索树"></a>（复习）108. 将有序数组转换为二叉搜索树</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//创建保存结点的队列</span><br>        queue&lt;TreeNode*&gt; nodeQ;<br>        <span class="hljs-comment">//创建保存左left边界的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQ;<br>        <span class="hljs-comment">//创建保存右right边界的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQ;<br><br>        <span class="hljs-comment">//初始化一个空结点并加入到队列中</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>        nodeQ.<span class="hljs-keyword">push</span>(root);<br><br>        <span class="hljs-comment">//将left和right加入到对应的队列中</span><br>        leftQ.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);<br>        rightQ.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//循环遍历实现对树的构造</span><br>        <span class="hljs-keyword">while</span>(!nodeQ.empty())&#123;<br>            <span class="hljs-comment">//首先得到nodeQ队列头部的结点进行赋值</span><br>            TreeNode* curr = nodeQ.front();<br>            nodeQ.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-comment">//得到left和right</span><br>            <span class="hljs-keyword">int</span> left = leftQ.front();<br>            leftQ.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> right = rightQ.front();<br>            rightQ.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>            curr-&gt;val = nums[mid];<br><br>            <span class="hljs-comment">//处理左子树</span><br>            <span class="hljs-keyword">if</span>(left &lt;= mid - <span class="hljs-number">1</span>)&#123;<br>                curr-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                leftQ.<span class="hljs-keyword">push</span>(left);<br>                rightQ.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>                nodeQ.<span class="hljs-keyword">push</span>(curr-&gt;left);<br>            &#125;<br><br>            <span class="hljs-comment">//处理右子树</span><br>            <span class="hljs-keyword">if</span>(right &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>                curr-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                leftQ.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>                rightQ.<span class="hljs-keyword">push</span>(right);<br>                nodeQ.<span class="hljs-keyword">push</span>(curr-&gt;right);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树（C-递归实现）"><a href="#538-把二叉搜索树转换为累加树（C-递归实现）" class="headerlink" title="538. 把二叉搜索树转换为累加树（C++递归实现）"></a>538. 把二叉搜索树转换为累加树（C++递归实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br><br>    void convertBSTHelper(TreeNode* root, int &amp;<span class="hljs-built_in">sum</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        // 遍历右子树<br>        convertBSTHelper(root-&gt;<span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>);<br><br>        // 更新当前节点的值为累加和<br>        <span class="hljs-built_in">sum</span> += root-&gt;val;<br>        root-&gt;val = <span class="hljs-built_in">sum</span>;<br><br>        // 遍历左子树<br>        convertBSTHelper(root-&gt;<span class="hljs-built_in">left</span>, <span class="hljs-built_in">sum</span>);<br>    &#125;<br><br>    TreeNode* convertBST(TreeNode* root) &#123;<br>        //使用递归实现<br>        int <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        convertBSTHelper(root, <span class="hljs-built_in">sum</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树（C-迭代法实现）"><a href="#538-把二叉搜索树转换为累加树（C-迭代法实现）" class="headerlink" title="538. 把二叉搜索树转换为累加树（C++迭代法实现）"></a>538. 把二叉搜索树转换为累加树（C++迭代法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre;<span class="hljs-comment">//pre保存当前累加值</span><br><br>    <span class="hljs-comment">//使用迭代法实现</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_new_BST</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        TreeNode* curr = root;<br>        <span class="hljs-comment">//使用栈保存树的结点，实现迭代遍历</span><br>        stack&lt;TreeNode*&gt; st;<br><br>        <span class="hljs-comment">//使用循环实现，按照右中左实现反中序遍历</span><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(curr);<br>                curr = curr-&gt;right;<span class="hljs-comment">//右</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//中</span><br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                curr-&gt;val += pre;<br><br>                pre = curr-&gt;val;<span class="hljs-comment">//更新累加之后的值</span><br><br>                <span class="hljs-comment">//左</span><br>                curr = curr-&gt;left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        pre = <span class="hljs-number">0</span>;<br>        TreeNode* resultNode = <span class="hljs-built_in">get_new_BST</span>(root);<br>        <span class="hljs-keyword">return</span> resultNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="77-组合（C-回溯法实现）"><a href="#77-组合（C-回溯法实现）" class="headerlink" title="77. 组合（C++回溯法实现）"></a>77. 组合（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置path保存当前层的满足题意结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//设置保存所有path的result结果数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//使用回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n;i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯回来之后，弹出最后一个元素</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//首先清空result数组</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//path清空</span><br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//调用回溯法</span><br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="77-组合（C-回溯法剪枝实现）"><a href="#77-组合（C-回溯法剪枝实现）" class="headerlink" title="77. 组合（C++回溯法剪枝实现）"></a>77. 组合（C++回溯法剪枝实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置path保存当前层的满足题意结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//设置保存所有path的result结果数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//使用回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>;i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯回来之后，弹出最后一个元素</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//首先清空result数组</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//path清空</span><br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//调用回溯法</span><br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230726</title>
    <link href="/2023/07/26/leetcode-notes-20230726/"/>
    <url>/2023/07/26/leetcode-notes-20230726/</url>
    
    <content type="html"><![CDATA[<h2 id="复习：669-修剪二叉搜索树（迭代法实现，C-）"><a href="#复习：669-修剪二叉搜索树（迭代法实现，C-）" class="headerlink" title="复习：669. 修剪二叉搜索树（迭代法实现，C++）"></a>复习：669. 修剪二叉搜索树（迭代法实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-comment">//修剪二叉树，迭代实现</span><br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//修剪root节点</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(root != NULL &amp;&amp; (root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root -&gt;</span> right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root -&gt;</span> left;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">//修剪root结点的左子树小于low的情况</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-comment">//循环找到左边界</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> right;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr -&gt;</span> left;<br>        &#125;<br><br>        curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-comment">//循环处理右子树大于high的情况</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>right;<br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树（C-递归法实现）"><a href="#108-将有序数组转换为二叉搜索树（C-递归法实现）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（C++递归法实现）"></a>108. 将有序数组转换为二叉搜索树（C++递归法实现）</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs excel">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     <span class="hljs-built_in">int</span> val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() <span class="hljs-symbol">:</span> val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(<span class="hljs-built_in">int</span> x) <span class="hljs-symbol">:</span> val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(<span class="hljs-built_in">int</span> x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) <span class="hljs-symbol">:</span> val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br><br>    //使用递归法实现<br>    TreeNode* digui(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span> &gt; <span class="hljs-built_in">right</span>)&#123;<br>            return NULL;<br>        &#125;<br><br>        //单层递归逻辑<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + ((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br>        TreeNode* root = new TreeNode(nums[<span class="hljs-built_in">mid</span>]);<br><br>        //递归调用<br>        root-&gt;<span class="hljs-built_in">left</span> = digui(nums, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>);<br>        root-&gt;<span class="hljs-built_in">right</span> = digui(nums, <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);<br><br>        return root;<br>    &#125;<br><br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        //使用迭代法实现<br>        return digui(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树（C-迭代法实现）"><a href="#108-将有序数组转换为二叉搜索树（C-迭代法实现）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（C++迭代法实现）"></a>108. 将有序数组转换为二叉搜索树（C++迭代法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//初始化根结点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>        queue&lt;TreeNode*&gt; nodeQueue;<span class="hljs-comment">//创建队列保存树结点</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQueue;<span class="hljs-comment">//创建保存left左下标的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQueue;<span class="hljs-comment">//创建保存right右下标的队列</span><br><br>        <span class="hljs-comment">//将left=0和right=nums.size()-1分别放到left和right队列中</span><br>        nodeQueue.<span class="hljs-keyword">push</span>(root);<br>        leftQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);<br>        rightQueue.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//使用while循环</span><br>        <span class="hljs-keyword">while</span>(!nodeQueue.empty())&#123;<br>            <span class="hljs-comment">//得到当前结点</span><br>            TreeNode* curr = nodeQueue.front();<br>            nodeQueue.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-comment">//拿到left和right下标</span><br>            <span class="hljs-keyword">int</span> left = leftQueue.front();<br>            leftQueue.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-keyword">int</span> right = rightQueue.front();<br>            rightQueue.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br><br>            curr-&gt;val = nums[mid];<span class="hljs-comment">//将nums[mid]值复制给curr-&gt;val</span><br><br><br>            <span class="hljs-comment">//处理左子树</span><br>            <span class="hljs-keyword">if</span>(left &lt;= mid - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//向nodeQueue中加入left空结点，用于下次赋值</span><br>                curr-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQueue.<span class="hljs-keyword">push</span>(curr-&gt;left);<br>                leftQueue.<span class="hljs-keyword">push</span>(left);<br>                rightQueue.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//处理右子树</span><br>            <span class="hljs-keyword">if</span>(right &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//向nodeQueue中加入right空结点，用于下次赋值</span><br>                curr-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQueue.<span class="hljs-keyword">push</span>(curr-&gt;right);<br>                rightQueue.<span class="hljs-keyword">push</span>(right);<br>                leftQueue.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230719</title>
    <link href="/2023/07/19/leetcode-notes-20230719/"/>
    <url>/2023/07/19/leetcode-notes-20230719/</url>
    
    <content type="html"><![CDATA[<h2 id="669-修剪二叉搜索树（递归实现，C-）"><a href="#669-修剪二叉搜索树（递归实现，C-）" class="headerlink" title="669. 修剪二叉搜索树（递归实现，C++）"></a>669. 修剪二叉搜索树（递归实现，C++）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* trim<span class="hljs-constructor">BST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span> &#123;<br>        <span class="hljs-comment">//迭代实现</span><br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//当前结点的值小于low，那么遍历root的right右子树</span><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; low)&#123;<br>            TreeNode* node = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>            return node;<br>        &#125;<br><br>        <span class="hljs-comment">//当前结点的值大于high，那么遍历root的左子树</span><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; high)&#123;<br>            TreeNode* node = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>            return node;<br>        &#125;<br><br>        root-&gt;left = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>        root-&gt;right = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树（迭代法实现，C-）"><a href="#669-修剪二叉搜索树（迭代法实现，C-）" class="headerlink" title="669. 修剪二叉搜索树（迭代法实现，C++）"></a>669. 修剪二叉搜索树（迭代法实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//处理根结点，将新树的root结点调节到low,hight之间</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(root != NULL &amp;&amp; (root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//继续处理</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<span class="hljs-comment">//处理左子树小于low的情况</span><br>            <span class="hljs-comment">//循环找到左边界</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>right;<br>            &#125;<br>            <span class="hljs-comment">//处理curr结点的</span><br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>left;<br>        &#125;<br><br>        <span class="hljs-comment">//处理root结点的右边，将大于high的结点删除掉</span><br>        curr = root;<br><br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>right;<br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230718</title>
    <link href="/2023/07/18/leetcode-notes-20230718/"/>
    <url>/2023/07/18/leetcode-notes-20230718/</url>
    
    <content type="html"><![CDATA[<h2 id="701-二叉搜索树中的插入操作（递归实现，C-）"><a href="#701-二叉搜索树中的插入操作（递归实现，C-）" class="headerlink" title="701. 二叉搜索树中的插入操作（递归实现，C++）"></a>701. 二叉搜索树中的插入操作（递归实现，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        //用递归方法实现<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            TreeNode* node = new TreeNode(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val)&#123;<br>            root-&gt;<span class="hljs-built_in">left</span> = insertIntoBST(root-&gt;<span class="hljs-built_in">left</span>, val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val)&#123;<br>            root-&gt;<span class="hljs-built_in">right</span> = insertIntoBST(root-&gt;<span class="hljs-built_in">right</span>,val);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="701-二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C-）"><a href="#701-二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C-）" class="headerlink" title="701. 二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C++）"></a>701. 二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        //使用迭代法实现<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            TreeNode* node = new TreeNode(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        TreeNode* curr = root;<br>        TreeNode* parent = root;<br>        while(curr != NULL)&#123;//while循环当curr等于NULL时弹出，就是需要插入的节点位置<br>            parent = curr;<br>            <span class="hljs-keyword">if</span>(curr-&gt;val &lt; val)&#123;<br>                curr = curr-&gt;<span class="hljs-built_in">right</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = curr-&gt;<span class="hljs-built_in">left</span>;<br>            &#125;<br>        &#125;<br><br>        //处理parent和新插入的节点位置的关系<br>        TreeNode* node = new TreeNode(val);<br>        <span class="hljs-keyword">if</span>(parent-&gt;val &gt; val)&#123;//表示插入点在parent的左<br>            parent-&gt;<span class="hljs-built_in">left</span> = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent-&gt;<span class="hljs-built_in">right</span> = node;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点（递归实现，C-）"><a href="#450-删除二叉搜索树中的节点（递归实现，C-）" class="headerlink" title="450. 删除二叉搜索树中的节点（递归实现，C++）"></a>450. 删除二叉搜索树中的节点（递归实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* deleteNode(TreeNode* root, int key) &#123;<br><br>        <span class="hljs-comment">//删除二叉搜索树的结点</span><br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-comment">//第一种情况，key对应的结点为叶子结点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(root -&gt;</span> <span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> == NULL &amp;&amp; root-&gt;</span>right == NULL)&#123;<br>            delete root;<br>            return NULL;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; root-&gt;</span>right == NULL)&#123;<span class="hljs-comment">//第二种情况，删除节点有左子树</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* node = root-&gt;</span>left;<br>            delete root;<br>            return node;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> == NULL &amp;&amp; root-&gt;</span>right != NULL)&#123;<span class="hljs-comment">//第三种情况，删除节点有右子树</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* node = root-&gt;</span>right;<br>            delete root;<br>            return node;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; root-&gt;</span>right != NULL)&#123;<span class="hljs-comment">//第四种情况，删除节点左右子树都存在</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* curr = root-&gt;</span>right;<span class="hljs-comment">//遍历要删除的结点的右子树</span><br>            <span class="hljs-comment">//找到要删除结点的右子树的最左边子树的结点</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span>left != NULL)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>left;<br>            &#125;<br><br>            <span class="hljs-comment">//将删除节点的左子树移动到上述curr对应的结点的左子树上</span><br>            <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = root-&gt;</span>left;<br>            <span class="hljs-comment">//记录要删除的节点</span><br>            TreeNode* tmp = root;<br>            <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<span class="hljs-comment">//返回结点的右子树作为根节点</span><br>            delete tmp;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-comment">//然后用root-&gt;left/right来接着对应的递归返回节点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; key)&#123;<br>            <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = deleteNode(root-&gt;</span>right, key);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &gt; key)&#123;<br>            <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = deleteNode(root-&gt;</span>left, key);<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230716</title>
    <link href="/2023/07/16/leetcode-notes-20230716/"/>
    <url>/2023/07/16/leetcode-notes-20230716/</url>
    
    <content type="html"><![CDATA[<h2 id="98-验证二叉搜索树（迭代，C-）"><a href="#98-验证二叉搜索树（迭代，C-）" class="headerlink" title="98.验证二叉搜索树（迭代，C++）"></a>98.验证二叉搜索树（迭代，C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//使用栈来进行迭代法实现（中序遍历迭代）</span><br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* currNode = root;<br>        TreeNode* preNode = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">//使用同一迭代法遍历树结点</span><br>        <span class="hljs-keyword">while</span>(currNode != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(currNode != <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-comment">//将当前结点加入到栈中</span><br>                st.<span class="hljs-built_in">push</span>(currNode);<br>                currNode = currNode -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currNode = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//中</span><br>                <span class="hljs-keyword">if</span>(preNode != <span class="hljs-literal">NULL</span> &amp;&amp; currNode-&gt;val &lt;= preNode-&gt;val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//保存前一个结点</span><br>                preNode = currNode;<br>                <span class="hljs-comment">//右</span><br>                currNode = currNode -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="530-二叉搜索树的最小绝对差（迭代，C-）"><a href="#530-二叉搜索树的最小绝对差（迭代，C-）" class="headerlink" title="530. 二叉搜索树的最小绝对差（迭代，C++）"></a>530. 二叉搜索树的最小绝对差（迭代，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    //设置最小插值默认为最大<br>    long long result = LONG_MAX;<br>    int getMinimumDifference(TreeNode* root) &#123;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* pre = NULL;<br>        TreeNode* curr = root;<br><br>        while(curr != NULL |<span class="hljs-type">| !st</span>.empty())&#123;<br>            <span class="hljs-keyword">if</span>(curr != NULL)&#123;<br>                st.push(curr);<br>                curr = curr -&gt; <span class="hljs-built_in">left</span>;//左中右<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.pop();<br>                <span class="hljs-keyword">if</span>(pre != NULL &amp;&amp; abs(pre-&gt;val - curr-&gt;val) &lt; result)&#123;<br>                    result = abs(pre-&gt;val - curr-&gt;val);<br>                &#125;<br>                pre = curr;<br>                curr = curr -&gt; <span class="hljs-built_in">right</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（迭代，C-）"><a href="#501-二叉搜索树中的众数（迭代，C-）" class="headerlink" title="501.二叉搜索树中的众数（迭代，C++）"></a>501.二叉搜索树中的众数（迭代，C++）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        TreeNode* curr = root;<br>        <span class="hljs-comment">//创建Map以保存每个树结点对应的次数</span><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(curr);<br>                curr = curr -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//中</span><br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                dict[curr-&gt;val]++;<br><br>                <span class="hljs-comment">//右边</span><br>                curr = curr -&gt; right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到最大的出现次数</span><br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : dict) &#123;<br>            <span class="hljs-keyword">if</span> (entry.second &gt; maxCount) &#123;<br>                maxCount = entry.second;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 找到出现次数等于最大值的数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : dict) &#123;<br>            <span class="hljs-keyword">if</span> (entry.second == maxCount) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(entry.first);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（递归，C-）"><a href="#501-二叉搜索树中的众数（递归，C-）" class="headerlink" title="501.二叉搜索树中的众数（递归，C++）"></a>501.二叉搜索树中的众数（递归，C++）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> max_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大出现次数</span><br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前count</span><br>    TreeNode* pre = NULL;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; result;<br><br>    void <span class="hljs-constructor">BSTdigui(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-comment">//按照左中右的顺序遍历</span><br>        <span class="hljs-comment">//遍历左子树</span><br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br><br>        <span class="hljs-comment">//处理本次遍历内部逻辑</span><br>        <span class="hljs-keyword">if</span>(pre<span class="hljs-operator"> == </span>NULL)&#123;<span class="hljs-comment">//第一个结点，因为之前的结点都是1</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre != NULL<span class="hljs-operator"> &amp;&amp; </span>pre-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>root-&gt;<span class="hljs-keyword">val</span>)&#123;<span class="hljs-comment">//判断pre和curr的值是否相等</span><br>            count++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//与前一个结点数值不相同</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//更新pre</span><br>        pre = root;<br><br>        <span class="hljs-comment">//判断count和max_count的大小，相等，直接将root-&gt;val放入到返回的结果数组中</span><br>        <span class="hljs-keyword">if</span>(count<span class="hljs-operator"> == </span>max_count)&#123;<br>            result.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断是否为最大值</span><br>        <span class="hljs-keyword">if</span>(count &gt; max_count)&#123;<br>            max_count = count;<br>            <span class="hljs-comment">//result中结果都失效了</span><br>            result.clear<span class="hljs-literal">()</span>;<br>            result.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历右子树</span><br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        return ;<br>    &#125;<br><br>    vector&lt;<span class="hljs-built_in">int</span>&gt; find<span class="hljs-constructor">Mode(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（迭代法，C-实现）"><a href="#501-二叉搜索树中的众数（迭代法，C-实现）" class="headerlink" title="501.二叉搜索树中的众数（迭代法，C++实现）"></a>501.二叉搜索树中的众数（迭代法，C++实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; findMode(TreeNode* root) &#123;<br>        <span class="hljs-comment">//使用迭代遍历法实现</span><br>        TreeNode* pre = <span class="hljs-keyword">NULL</span>;<br>        TreeNode* curr = root;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">int</span> max_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-keyword">NULL</span> || !st.empty())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">NULL</span>)&#123;<br>                st.<span class="hljs-keyword">push</span>(curr);<br>                curr = curr -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = st.top();<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//开始和递归法一样</span><br>                <span class="hljs-keyword">if</span>(pre == <span class="hljs-keyword">NULL</span>)&#123;<span class="hljs-comment">//首个结点</span><br>                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre-&gt;val == curr-&gt;val)&#123;<br>                    <span class="hljs-keyword">count</span>++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//和前一个结点不一样</span><br>                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//更新前一个结点</span><br>                pre = curr;<br><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> == max_count)&#123;<br>                    result.push_back(curr-&gt;val);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &gt; max_count)&#123;<br>                    max_count = <span class="hljs-keyword">count</span>;<br>                    result.clear();<br>                    result.push_back(curr-&gt;val);<br>                &#125;<br><br>                curr = curr -&gt; right;<span class="hljs-comment">//右结点</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先（递归调用，C-实现）"><a href="#236-二叉树的最近公共祖先（递归调用，C-实现）" class="headerlink" title="236.二叉树的最近公共祖先（递归调用，C++实现）"></a>236.二叉树的最近公共祖先（递归调用，C++实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(NULL), <span class="hljs-built_in">right</span>(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-keyword">if</span>(root == p |<span class="hljs-type">| root</span> == q |<span class="hljs-type">| root</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        TreeNode* <span class="hljs-built_in">left</span> = lowestCommonAncestor(root-&gt;<span class="hljs-built_in">left</span>, p, q);<br>        TreeNode* <span class="hljs-built_in">right</span> = lowestCommonAncestor(root-&gt;<span class="hljs-built_in">right</span>, p, q);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> != NULL &amp;&amp; <span class="hljs-built_in">right</span> != NULL)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> != NULL &amp;&amp; <span class="hljs-built_in">right</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> == NULL &amp;&amp; <span class="hljs-built_in">right</span> != NULL)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">right</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> NULL;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先（递归法，C-实现，充分利用二叉搜索树的特征）"><a href="#235-二叉搜索树的最近公共祖先（递归法，C-实现，充分利用二叉搜索树的特征）" class="headerlink" title="235. 二叉搜索树的最近公共祖先（递归法，C++实现，充分利用二叉搜索树的特征）"></a>235. 二叉搜索树的最近公共祖先（递归法，C++实现，充分利用二叉搜索树的特征）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br><br>    TreeNode* <span class="hljs-constructor">BSTdigui(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; p-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &gt; q-&gt;<span class="hljs-keyword">val</span>)&#123;<br>            TreeNode* left = <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>            <span class="hljs-keyword">if</span>(left != NULL)&#123;<br>                return left;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; p-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &lt; q-&gt;<span class="hljs-keyword">val</span>)&#123;<br>            TreeNode* right = <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>            <span class="hljs-keyword">if</span>(right != NULL)&#123;<br>                return right;<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125; <br><br><br>    TreeNode* lowest<span class="hljs-constructor">CommonAncestor(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span> &#123;<br>        return <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先（迭代法，C-实现，充分利用二叉搜索树的特征）"><a href="#235-二叉搜索树的最近公共祖先（迭代法，C-实现，充分利用二叉搜索树的特征）" class="headerlink" title="235. 二叉搜索树的最近公共祖先（迭代法，C++实现，充分利用二叉搜索树的特征）"></a>235. 二叉搜索树的最近公共祖先（迭代法，C++实现，充分利用二叉搜索树的特征）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br>class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; p-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; p-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                return root;<br>            &#125;<br>        &#125;<br>        return NULL;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230711</title>
    <link href="/2023/07/11/leetcode-notes-20230711/"/>
    <url>/2023/07/11/leetcode-notes-20230711/</url>
    
    <content type="html"><![CDATA[<h2 id="700-二叉搜索树中的搜索（层序遍历法）"><a href="#700-二叉搜索树中的搜索（层序遍历法）" class="headerlink" title="700.二叉搜索树中的搜索（层序遍历法）"></a>700.二叉搜索树中的搜索（层序遍历法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-keyword">val</span> <span class="hljs-operator">==</span> <span class="hljs-keyword">val</span>)&#123;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索（递归法）"><a href="#700-二叉搜索树中的搜索（递归法）" class="headerlink" title="700.二叉搜索树中的搜索（递归法）"></a>700.二叉搜索树中的搜索（递归法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode huisu(TreeNode root, int <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.<span class="hljs-keyword">val</span> == <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">//表示在root的左子树中</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> &lt; root.<span class="hljs-keyword">val</span>)&#123;<br>            <span class="hljs-keyword">return</span> huisu(root.left, <span class="hljs-keyword">val</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> huisu(root.right, <span class="hljs-keyword">val</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">return</span> huisu(root, <span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（递归法实现）"><a href="#98-验证二叉搜索树（递归法实现）" class="headerlink" title="98.验证二叉搜索树（递归法实现）"></a>98.验证二叉搜索树（递归法实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>    <span class="hljs-comment">//递归实现中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> digui(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//中序遍历：右中左</span><br>        digui(root.left);<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        digui(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> boolean isValidBST(TreeNode root) &#123;<br>        digui(root);<br>        <span class="hljs-comment">//使用中序遍历，同时保存树的结点的值，判断是否为升序即可</span><br>        <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i <span class="hljs-operator">&lt;</span> result.size(); i <span class="hljs-operator">++</span>)&#123;<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">get</span>(i) <span class="hljs-operator">&lt;=</span> result.<span class="hljs-built_in">get</span>(i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（迭代法实现）"><a href="#98-验证二叉搜索树（迭代法实现）" class="headerlink" title="98.验证二叉搜索树（迭代法实现）"></a>98.验证二叉搜索树（迭代法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isValidBST(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            stack.<span class="hljs-keyword">push</span>(root);<br>        &#125;<br>        TreeNode pre = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">//循环迭代</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-comment">//得到栈顶结点</span><br>            TreeNode curr = stack.peek();<br>            <span class="hljs-comment">//判断curr是否为null</span><br>            <span class="hljs-comment">//按照右中左的顺序加入到栈中</span><br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>                stack.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出栈顶结点</span><br>                <span class="hljs-keyword">if</span>(curr.right != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//判断当前结点的右结点是否为null，不为null</span><br>                    stack.<span class="hljs-keyword">push</span>(curr.right);<br>                &#125;<br>                stack.<span class="hljs-keyword">push</span>(curr);<br>                stack.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(curr.left != <span class="hljs-keyword">null</span>)&#123;<br>                    stack.<span class="hljs-keyword">push</span>(curr.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//弹出栈顶null（占位）结点</span><br>                stack.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//对结点进行操作</span><br>                TreeNode tmp = stack.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span> &amp;&amp; pre.val &gt;= tmp.val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（递归，C-）"><a href="#98-验证二叉搜索树（递归，C-）" class="headerlink" title="98.验证二叉搜索树（递归，C++）"></a>98.验证二叉搜索树（递归，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    long long max_value = LONG_MIN;<br>    bool isValidBST(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            <span class="hljs-keyword">return</span> true;<br>        &#125;<br><br>        bool <span class="hljs-built_in">left</span> = isValidBST(root-&gt;<span class="hljs-built_in">left</span>);<br>        <span class="hljs-keyword">if</span>(max_value &lt; root-&gt;val)&#123;<br>            max_value = root-&gt;val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> false;<br>        &#125;<br>        bool <span class="hljs-built_in">right</span> = isValidBST(root-&gt;<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span> &amp;&amp; <span class="hljs-built_in">right</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>C++</tag>
      
      <tag>二叉树（从700. 二叉搜索树中的搜索开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230710.md</title>
    <link href="/2023/07/10/leetcode-notes-20230710/"/>
    <url>/2023/07/10/leetcode-notes-20230710/</url>
    
    <content type="html"><![CDATA[<h2 id="513-找树左下角的值（递归写法）"><a href="#513-找树左下角的值（递归写法）" class="headerlink" title="513.找树左下角的值（递归写法）"></a>513.找树左下角的值（递归写法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    int max_depth <span class="hljs-operator">=</span> <span class="hljs-number">-1</span>;<br>    int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> huisu(TreeNode root, int depth)&#123;<br>        <span class="hljs-comment">//设置递归终止条件</span><br>        <span class="hljs-keyword">if</span>(root.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> root.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(max_depth <span class="hljs-operator">&lt;</span> depth)&#123;<br>                max_depth <span class="hljs-operator">=</span> depth;<br>                result <span class="hljs-operator">=</span> root.<span class="hljs-keyword">val</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归左子树条件</span><br>        <span class="hljs-keyword">if</span>(root.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            depth<span class="hljs-operator">++</span>;<br>            huisu(root.left, depth);<br>            depth<span class="hljs-operator">--</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归右子树</span><br>        <span class="hljs-keyword">if</span>(root.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            depth<span class="hljs-operator">++</span>;<br>            huisu(root.right, depth);<br>            depth<span class="hljs-operator">--</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int findBottomLeftValue(TreeNode root) &#123;<br>        huisu(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="513-找树左下角的值（迭代法）"><a href="#513-找树左下角的值（迭代法）" class="headerlink" title="513.找树左下角的值（迭代法）"></a>513.找树左下角的值（迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> findBottomLeftValue(TreeNode root) &#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//使用二叉树层序遍历</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-comment">///如果队列不是空的，那么进入循环</span><br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到当前队列的长度</span><br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">size</span>;i ++)&#123;<br>                <span class="hljs-comment">//得到每层的结点</span><br>                TreeNode node = que.poll();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                    result = node.val;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路经总和（递归法）"><a href="#112-路经总和（递归法）" class="headerlink" title="112.路经总和（递归法）"></a>112.路经总和（递归法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//设置的回溯算法</span><br>    <span class="hljs-keyword">public</span> boolean huisu(TreeNode root, int currSum)&#123;<br>        <span class="hljs-comment">//判断是否为targetSum</span><br>        <span class="hljs-comment">//遇到叶子结点且currSum==0，这表示找到了满足题意的结果</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; currSum == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遇到叶子节点直接返回false</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            currSum -= root.left.<span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">if</span>(huisu(root.left, currSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            currSum += root.left.<span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            currSum -= root.right.<span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">if</span>(huisu(root.right, currSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            currSum += root.right.<span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> boolean hasPathSum(TreeNode root, int targetSum) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> huisu(root, targetSum - root.<span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路径总和（迭代法）"><a href="#112-路径总和（迭代法）" class="headerlink" title="112.路径总和（迭代法）"></a>112.路径总和（迭代法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-comment">//自定义类</span><br>public <span class="hljs-keyword">class</span> MyNode&#123;<br>     TreeNode treeNode;<br>     <span class="hljs-built_in">int</span> currSum = <span class="hljs-number">0</span>;<br>     <span class="hljs-constructor">MyNode(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">currSum</span>)</span>&#123;<br>         this.treeNode = root;<br>         this.currSum = currSum;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean has<span class="hljs-constructor">PathSum(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">targetSum</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用非递归方法做</span><br>        Stack&lt;MyNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        MyNode rootNode = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">root</span>, <span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span>;<br>        st.push(rootNode);<br><br>        <span class="hljs-keyword">while</span>(!st.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            MyNode node = st.peek<span class="hljs-literal">()</span>;<br>            st.pop<span class="hljs-literal">()</span>;<br><br>            <span class="hljs-keyword">if</span>(targetSum<span class="hljs-operator"> == </span>node.currSum<span class="hljs-operator"> &amp;&amp; </span>node.treeNode.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>node.treeNode.right<span class="hljs-operator"> == </span>null)&#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//压入右结点栈中</span><br>            <span class="hljs-keyword">if</span>(node.treeNode.right != null)&#123;<br>                st.push(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">right</span>, <span class="hljs-params">node</span>.<span class="hljs-params">currSum</span> + <span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">right</span>.<span class="hljs-params">val</span>)</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//将左结点压入栈中</span><br>            <span class="hljs-keyword">if</span>(node.treeNode.left != null)&#123;<br>                st.push(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">left</span>, <span class="hljs-params">node</span>.<span class="hljs-params">currSum</span> + <span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">left</span>.<span class="hljs-params">val</span>)</span>);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路经总和2（回溯法）"><a href="#113-路经总和2（回溯法）" class="headerlink" title="113.路经总和2（回溯法）"></a>113.路经总和2（回溯法）</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用回溯方法做<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> huisu(TreeNode root, <span class="hljs-type">int</span> targetSum, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; targetSum == root.val)&#123;<br>            result.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(<span class="hljs-type">path</span>));<br>        &#125;<br><br>        huisu(root.left, targetSum - root.val, result, <span class="hljs-type">path</span>);<br>        huisu(root.right, targetSum - root.val, result, <span class="hljs-type">path</span>);<br><br>        <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; pathSum(TreeNode root, <span class="hljs-type">int</span> targetSum) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        huisu(root, targetSum, result, <span class="hljs-type">path</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路经总和2（DFS法）"><a href="#113-路经总和2（DFS法）" class="headerlink" title="113.路经总和2（DFS法）"></a>113.路经总和2（DFS法）</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; res = new ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; pathSum(TreeNode root, <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>) &#123;<br>        List&lt;<span class="hljs-keyword">Integer</span>&gt; cur = new ArrayList&lt;&gt;();<br>        dfs(root, cur, <span class="hljs-number">0</span>, <span class="hljs-built_in">sum</span>);            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br><br>    <span class="hljs-keyword">public</span> void dfs(TreeNode node, List&lt;<span class="hljs-keyword">Integer</span>&gt; cur, <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>)&#123;<br>        <span class="hljs-keyword">if</span>(node == null)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left == null &amp;&amp; node.right == null &amp;&amp; node.val + <span class="hljs-built_in">sum</span> == <span class="hljs-keyword">target</span>)&#123;<br>            cur.add(node.val);<br>            res.add(new ArrayList&lt;&gt;(cur));<br>            cur.remove(cur.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;            <br>        cur.add(node.val);<br>        dfs(node.left, cur, <span class="hljs-built_in">sum</span> + node.val, <span class="hljs-keyword">target</span>);<br>        dfs(node.right, cur, <span class="hljs-built_in">sum</span> + node.val, <span class="hljs-keyword">target</span>);<br>        cur.remove(cur.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//参数：中序遍历数组和后续遍历数组</span><br>    public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">postorder</span>)</span> &#123;<br>        <span class="hljs-comment">//获得分割结点</span><br>        <span class="hljs-built_in">int</span> in_length = inorder.length;<br>        <span class="hljs-built_in">int</span> post_length = postorder.length;<br><br>        <span class="hljs-comment">//判断是否为空结点</span><br>        <span class="hljs-keyword">if</span>(in_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>post_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-comment">//通过后续序列找到切割结点</span><br>        <span class="hljs-built_in">int</span> root_val = postorder<span class="hljs-literal">[<span class="hljs-identifier">post_length</span> - <span class="hljs-number">1</span>]</span>;<br>        <span class="hljs-comment">//构造根结点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历中序序列，找到切割结点在其中的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; in_length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root_val<span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                k = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//按照分割结点将中序序列和后续序列进行分割</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_post = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-comment">//递归调用函数</span><br>        root.left = build<span class="hljs-constructor">Tree(<span class="hljs-params">left_in</span>, <span class="hljs-params">left_post</span>)</span>;<br><br>        <span class="hljs-comment">//按照分割结点构造右子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">in_length</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_post = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>, <span class="hljs-params">k</span>, <span class="hljs-params">post_length</span> - 1)</span>;<br>        root.right = build<span class="hljs-constructor">Tree(<span class="hljs-params">right_in</span>, <span class="hljs-params">right_post</span>)</span>;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">preorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> pre_length = preorder.length;<br>        <span class="hljs-built_in">int</span> in_length = inorder.length;<br>        <span class="hljs-keyword">if</span>(pre_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>in_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> root_val = preorder<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <br>        <span class="hljs-comment">//得到左子树对应的前序和中序序列</span><br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; in_length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root_val<span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                k = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_pre = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>, 1, <span class="hljs-params">k</span> + 1)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        root.left = build<span class="hljs-constructor">Tree(<span class="hljs-params">left_pre</span>, <span class="hljs-params">left_in</span>)</span>;<br><br>        <span class="hljs-comment">//构造右子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_pre = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">pre_length</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">in_length</span>)</span>;<br>        root.right = build<span class="hljs-constructor">Tree(<span class="hljs-params">right_pre</span>, <span class="hljs-params">right_in</span>)</span>;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public TreeNode construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n_length = nums.length;<br>        <span class="hljs-keyword">if</span>(n_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> max_value = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//首先找到最大值和最大值对应的index</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max_value &lt; nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                max_value = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>                k = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建根结点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">max_value</span>)</span>;<br>        <br>        <span class="hljs-comment">//从根结点左边构造左子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">n_length</span>)</span>;<br>        root.left = construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">left_nums</span>)</span>;<br>        root.right = construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">right_nums</span>)</span>;<br><br>        return root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树（递归实现）"><a href="#617-合并二叉树（递归实现）" class="headerlink" title="617. 合并二叉树（递归实现）"></a>617. 合并二叉树（递归实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode <span class="hljs-built_in">left</span>;<br> *     TreeNode <span class="hljs-built_in">right</span>;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123;<br> *         this.val = val;<br> *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;<br> *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode huisu(TreeNode root1, TreeNode root2)&#123;<br>        <span class="hljs-keyword">if</span>(root1 == null)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root2 == null)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        root1.val += root2.val;<br>        root1.<span class="hljs-built_in">left</span> = huisu(root1.<span class="hljs-built_in">left</span>, root2.<span class="hljs-built_in">left</span>);<br>        root1.<span class="hljs-built_in">right</span> = huisu(root1.<span class="hljs-built_in">right</span>, root2.<span class="hljs-built_in">right</span>);<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;    <br>    <br>    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>        <span class="hljs-keyword">return</span> huisu(root1, root2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树（迭代实现）"><a href="#617-合并二叉树（迭代实现）" class="headerlink" title="617. 合并二叉树（迭代实现）"></a>617. 合并二叉树（迭代实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>        <span class="hljs-comment">//使用层序遍历迭代法</span><br>        <span class="hljs-keyword">if</span>(root1 <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root2 <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        <span class="hljs-comment">//使用层序遍历</span><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-comment">//加入root1</span><br>        que.offer(root1);<br>        <span class="hljs-comment">//加入root2</span><br>        que.offer(root2);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到两个队列中的结点</span><br>            TreeNode node1 <span class="hljs-operator">=</span> que.poll();<br>            TreeNode node2 <span class="hljs-operator">=</span> que.poll();<br><br>            <span class="hljs-comment">//将两个结点的val相加</span><br>            node1.<span class="hljs-keyword">val</span> <span class="hljs-operator">+=</span> node2.<span class="hljs-keyword">val</span>;<br><br>            <span class="hljs-comment">//将树的左结点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(node1.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node1.left);<br>                que.offer(node2.left);<br>            &#125;<br><br>            <span class="hljs-comment">//将树的右结点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(node1.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node1.right);<br>                que.offer(node2.right);<br>            &#125;<br><br>            <span class="hljs-comment">//如果node1的左节点为空直接将node2的左结点赋值给node1</span><br>            <span class="hljs-keyword">if</span>(node1.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                node1.left <span class="hljs-operator">=</span> node2.left;<br>            &#125;<br><br>            <span class="hljs-comment">//如果node1的右节点为空，将node2的有结点赋值给node1</span><br>            <span class="hljs-keyword">if</span>(node1.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                node1.right <span class="hljs-operator">=</span> node2.right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230610</title>
    <link href="/2023/06/17/leetcode-notes-20230617/"/>
    <url>/2023/06/17/leetcode-notes-20230617/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和（迭代法）"><a href="#404-左叶子之和（迭代法）" class="headerlink" title="404.左叶子之和（迭代法）"></a>404.左叶子之和（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//判断下一个结点是不是左叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                result <span class="hljs-operator">+=</span> node.left.<span class="hljs-keyword">val</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//按照右左中的顺序加入到stack中</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230610</title>
    <link href="/2023/06/10/leetcode-notes-20230610/"/>
    <url>/2023/06/10/leetcode-notes-20230610/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和（迭代法）"><a href="#404-左叶子之和（迭代法）" class="headerlink" title="404.左叶子之和（迭代法）"></a>404.左叶子之和（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//判断下一个结点是不是左叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                result <span class="hljs-operator">+=</span> node.left.<span class="hljs-keyword">val</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//按照右左中的顺序加入到stack中</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230607</title>
    <link href="/2023/06/07/leetcode-notes-20230607/"/>
    <url>/2023/06/07/leetcode-notes-20230607/</url>
    
    <content type="html"><![CDATA[<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">//二叉树层序遍历</span><br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt;&gt; result = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">//BFS搜索</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-built_in">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-comment">//借助队列实现</span><br>        <span class="hljs-built_in">Queue</span>&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//将第一个节点加入队列中</span><br>        <span class="hljs-built_in">queue</span>.offer(root);<br><br>        <span class="hljs-comment">//循环进行遍历</span><br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">queue</span>.isEmpty())&#123;<br>            <span class="hljs-comment">//设置内部的保存结点的list数组</span><br>            <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; tmp = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>            int size = <span class="hljs-built_in">queue</span>.size();<span class="hljs-comment">//获得tmp list的长度</span><br><br>            <span class="hljs-comment">//遍历当前所有的节点</span><br>            for(int i = <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>                <span class="hljs-comment">//弹出队列首结点</span><br>                TreeNode node = <span class="hljs-built_in">queue</span>.poll();<br>                <span class="hljs-comment">//向tmp list中添加弹出结点的val</span><br>                tmp.add(node.val);<br>                <span class="hljs-comment">//将左右结点加入到queue中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-built_in">null</span>)&#123;<br>                    <span class="hljs-built_in">queue</span>.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-built_in">null</span>)&#123;<br>                    <span class="hljs-built_in">queue</span>.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//将本次得到的结点list加入到最后的结果list中</span><br>            result.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（递归法）"><a href="#226-翻转二叉树（递归法）" class="headerlink" title="226.翻转二叉树（递归法）"></a>226.翻转二叉树（递归法）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode <span class="hljs-built_in">left</span>;<br> *     TreeNode <span class="hljs-built_in">right</span>;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123;<br> *         this.val = val;<br> *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;<br> *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode invertTree(TreeNode root) &#123;<br>        //使用递归<br>        <span class="hljs-keyword">if</span>(root == null)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        //交换root的左右结点<br>        TreeNode tmpNode = root.<span class="hljs-built_in">left</span>;<br>        root.<span class="hljs-built_in">left</span> = root.<span class="hljs-built_in">right</span>;<br>        root.<span class="hljs-built_in">right</span> = tmpNode;<br>        invertTree(root.<span class="hljs-built_in">left</span>);<br>        invertTree(root.<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（前序遍历迭代法）"><a href="#226-翻转二叉树（前序遍历迭代法）" class="headerlink" title="226.翻转二叉树（前序遍历迭代法）"></a>226.翻转二叉树（前序遍历迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode invertTree(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            <span class="hljs-comment">//弹出栈顶结点</span><br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//交换左右结点</span><br>            TreeNode tmp <span class="hljs-operator">=</span> node.left;<br>            node.left <span class="hljs-operator">=</span> node.right;<br>            node.right <span class="hljs-operator">=</span> tmp;<br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（统一迭代法，前序遍历实现）"><a href="#226-翻转二叉树（统一迭代法，前序遍历实现）" class="headerlink" title="226.翻转二叉树（统一迭代法，前序遍历实现）"></a>226.翻转二叉树（统一迭代法，前序遍历实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode invertTree(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用统一迭代法</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode curr = st.peek();<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出结点</span><br>                <span class="hljs-comment">//按照右中左进栈（前序遍历）</span><br>                <span class="hljs-keyword">if</span>(curr.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(curr.right);<br>                &#125;<br>                <span class="hljs-comment">//中结点入栈</span><br>                st.<span class="hljs-keyword">push</span>(curr);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(curr.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(curr.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//先弹出null结点</span><br>                curr = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//交换结点</span><br>                TreeNode tmp = curr.left;<br>                curr.left = curr.right;<br>                curr.right = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树（递归写法）"><a href="#101-对称二叉树（递归写法）" class="headerlink" title="101.对称二叉树（递归写法）"></a>101.对称二叉树（递归写法）</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//设置递归函数，传入参数分别为root的左右结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>        <span class="hljs-comment">//确定终止条件</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left == <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left.val != right.val)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//确定递归的内容</span><br>        <span class="hljs-comment">//传入为左节点的左子树和右节点的右子树</span><br>        <span class="hljs-keyword">boolean</span> outside = compare(left.left, right.right);<br>        <span class="hljs-comment">//传入为左节点的右子树和右节点的左子树</span><br>        <span class="hljs-keyword">boolean</span> inside = compare(left.right, right.left);<br>        <span class="hljs-keyword">boolean</span> eq = outside &amp;&amp; inside;<br>        <span class="hljs-keyword">return</span> eq;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">//使用递归实现</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">compare</span><span class="hljs-params">(root.left, root.right)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树（迭代写法，使用队列实现）"><a href="#101-对称二叉树（迭代写法，使用队列实现）" class="headerlink" title="101.对称二叉树（迭代写法，使用队列实现）"></a>101.对称二叉树（迭代写法，使用队列实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> boolean isSymmetric(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//使用迭代法进行遍历</span><br>        <span class="hljs-comment">//使用队列每次保存左右子树的同外侧结点和同内侧结点</span><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root.left);<br>        que.offer(root.right);<br><br>        <span class="hljs-comment">//while循环遍历que进行比较</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到que中的两个节点判断是否相同</span><br>            TreeNode leftNode <span class="hljs-operator">=</span> que.peek();<br>            que.poll();<br>            TreeNode rightNode <span class="hljs-operator">=</span> que.peek();<br>            que.poll();<br><br>            <span class="hljs-comment">//进行判断的逻辑</span><br>            <span class="hljs-keyword">if</span>(leftNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> rightNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                continue;<span class="hljs-comment">//表示两个结点都是空的，那么continue</span><br>            &#125;<br><br>            <span class="hljs-comment">//判断两个结点是否相同</span><br>            <span class="hljs-comment">// if(leftNode != null &amp;&amp; rightNode == null)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;else if(leftNode == null &amp;&amp; rightNode != null)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;else if(leftNode.val != rightNode.val)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;</span><br><br>            <span class="hljs-keyword">if</span>((leftNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> rightNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> (leftNode.<span class="hljs-keyword">val</span> <span class="hljs-operator">!=</span> rightNode.<span class="hljs-keyword">val</span>)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//然后将leftNode的左子树和rightNode的右子树加入到que中</span><br>            que.offer(leftNode.left);<br>            que.offer(rightNode.right);<br><br>            <span class="hljs-comment">//将leftNode的右子树和rightNode的左子树加入到que中</span><br>            que.offer(leftNode.right);<br>            que.offer(rightNode.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度（递归方法）"><a href="#104-二叉树的最大深度（递归方法）" class="headerlink" title="104.二叉树的最大深度（递归方法）"></a>104.二叉树的最大深度（递归方法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//递归方法</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> leftDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-built_in">int</span> rightDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>        <span class="hljs-built_in">int</span> maxDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftDepth, rightDepth);<br>        return maxDepth;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度（使用迭代法，队列实现层次遍历）"><a href="#104-二叉树的最大深度（使用迭代法，队列实现层次遍历）" class="headerlink" title="104.二叉树的最大深度（使用迭代法，队列实现层次遍历）"></a>104.二叉树的最大深度（使用迭代法，队列实现层次遍历）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDepth(TreeNode root) &#123;<br>        <span class="hljs-comment">//迭代法求二叉树深度</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxResult = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//设置队列存储结点</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-comment">//深度加1</span><br>            maxResult++;<br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">size</span>;i++)&#123;<br>                TreeNode node = que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559.N 叉树的最大深度"></a>559.N 叉树的最大深度</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-keyword">class</span> Node &#123;<br>    <span class="hljs-keyword">public</span> int <span class="hljs-keyword">val</span>;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> children;<br><br>    <span class="hljs-keyword">public</span> Node() &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> Node(int _val) &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> _val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node(int _val, List<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> _children) &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> _val;<br>        children <span class="hljs-operator">=</span> _children;<br>    &#125;<br>&#125;;<br><span class="hljs-operator">*/</span><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int maxDepth(Node root) &#123;<br>        <span class="hljs-comment">//使用迭代法+队列实现层次遍历</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义队列</span><br>        Queue<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            result<span class="hljs-operator">++</span>;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                Node node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br><br>                <span class="hljs-keyword">for</span>(int j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j <span class="hljs-operator">&lt;</span> node.children.size();j<span class="hljs-operator">++</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(node.children.<span class="hljs-built_in">get</span>(j) <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                        que.offer(node.children.<span class="hljs-built_in">get</span>(j));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度（使用递归法）"><a href="#111-二叉树的最小深度（使用递归法）" class="headerlink" title="111.二叉树的最小深度（使用递归法）"></a>111.二叉树的最小深度（使用递归法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">minDepth</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> leftDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">minDepth</span>)</span>;<br>        <span class="hljs-built_in">int</span> rightDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">minDepth</span>)</span>;<br><br>        <span class="hljs-keyword">if</span>(root.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>root.right<span class="hljs-operator"> == </span>null)&#123;<br>            minDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftDepth, rightDepth);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(leftDepth, rightDepth);<br>        &#125;<br>        return minDepth;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度（使用迭代法-队列实现层次遍历）"><a href="#111-二叉树的最小深度（使用迭代法-队列实现层次遍历）" class="headerlink" title="111.二叉树的最小深度（使用迭代法+队列实现层次遍历）"></a>111.二叉树的最小深度（使用迭代法+队列实现层次遍历）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int minDepth(TreeNode root) &#123;<br>        <span class="hljs-comment">//迭代法得到最小深度，使用队列实现</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            result<span class="hljs-operator">++</span>;<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数（使用层次遍历实现）"><a href="#222-完全二叉树的节点个数（使用层次遍历实现）" class="headerlink" title="222.完全二叉树的节点个数（使用层次遍历实现）"></a>222.完全二叉树的节点个数（使用层次遍历实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int countNodes(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        result<span class="hljs-operator">++</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    result<span class="hljs-operator">++</span>;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    result<span class="hljs-operator">++</span>;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（递归方法）"><a href="#110-平衡二叉树（递归方法）" class="headerlink" title="110.平衡二叉树（递归方法）"></a>110.平衡二叉树（递归方法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//使用递归方法</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Height(TreeNode <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">int</span> leftHeight = get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-keyword">if</span>(leftHeight<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//表示不满足平衡二叉树</span><br>        return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> rightHeight = get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>        <span class="hljs-keyword">if</span>(rightHeight<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftHeight, rightHeight);<br>        return result;<br>    &#125;<br>    public boolean is<span class="hljs-constructor">Balanced(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        return get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>)</span><span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> ? <span class="hljs-literal">false</span>: <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）"><a href="#110-平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）" class="headerlink" title="110.平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）"></a>110.平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义求以root结点作为根节点的最大高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getHeight(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> len = que.<span class="hljs-keyword">size</span>();<br>            result++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>                TreeNode node = que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalanced(TreeNode root) &#123;<br>        <span class="hljs-comment">//遍历的时候求当前左右节点的最大高度，然后求之间的差的绝对值，将该值和1比较</span><br>        <span class="hljs-comment">//外层使用二叉树的统一迭代遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//按照后序遍历方法</span><br>                st.<span class="hljs-keyword">push</span>(node);<span class="hljs-comment">//中</span><br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//添加进去之前需要判断是否为平衡树</span><br>                <span class="hljs-keyword">int</span> leftHeight = getHeight(node.left);<br>                <span class="hljs-keyword">int</span> rightHeight = getHeight(node.right);<br>                <span class="hljs-keyword">if</span>(Math.<span class="hljs-keyword">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//首先弹出标记用的空结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（递归得到树的最大高度-遍历当前结点判断该结点的左右子树高度差是否大于1）"><a href="#110-平衡二叉树（递归得到树的最大高度-遍历当前结点判断该结点的左右子树高度差是否大于1）" class="headerlink" title="110.平衡二叉树（递归得到树的最大高度+遍历当前结点判断该结点的左右子树高度差是否大于1）"></a>110.平衡二叉树（递归得到树的最大高度+遍历当前结点判断该结点的左右子树高度差是否大于1）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getHeight(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> leftHeight = getHeight(root.left);<br>        <span class="hljs-keyword">int</span> rightHeight = getHeight(root.right);<br>        <span class="hljs-keyword">int</span> maxDepth = <span class="hljs-number">1</span> + Math.max(leftHeight, rightHeight);<br>        <span class="hljs-keyword">return</span> maxDepth;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalanced(TreeNode root) &#123;<br>        <span class="hljs-comment">//遍历的时候求当前左右节点的最大高度，然后求之间的差的绝对值，将该值和1比较</span><br>        <span class="hljs-comment">//外层使用二叉树的统一迭代遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//按照后序遍历方法</span><br>                st.<span class="hljs-keyword">push</span>(node);<span class="hljs-comment">//中</span><br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//添加进去之前需要判断是否为平衡树</span><br>                <span class="hljs-keyword">int</span> leftHeight = getHeight(node.left);<br>                <span class="hljs-keyword">int</span> rightHeight = getHeight(node.right);<br>                <span class="hljs-keyword">if</span>(Math.<span class="hljs-keyword">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//首先弹出标记用的空结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用递归调用实现<br>    //参数分别为传入的结点，本次的单条路径，所有路径结果数组<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> travelTreeAllPath(TreeNode root, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;String&gt; result)&#123;<br>        //将中结点加入到<span class="hljs-type">path</span>中，这样才算遍历到了叶子结点<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        //递归条件，到叶子节点结束递归<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            //结束递归的时候将<span class="hljs-type">path</span>中对应的结果添加到result list中<br>            String path_str = &quot;&quot;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>;i++)&#123;<br>                path_str += String.valueOf(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i));<br>                path_str += &quot;-&gt;&quot;;<br>            &#125;<br>            path_str += <span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);<br>            //将当前结果加入到result list中<br>            result.<span class="hljs-keyword">add</span>(path_str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        //每次递归需要执行的代码<br>        //不是空结点才进行递归<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.left, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.right, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        travelTreeAllPath(root, <span class="hljs-type">path</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><br>//使用StringBuilder进行字符串的构造，效率提升很大<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用递归调用实现<br>    //参数分别为传入的结点，本次的单条路径，所有路径结果数组<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> travelTreeAllPath(TreeNode root, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;String&gt; result)&#123;<br>        //将中结点加入到<span class="hljs-type">path</span>中，这样才算遍历到了叶子结点<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        //递归条件，到叶子节点结束递归<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            //结束递归的时候将<span class="hljs-type">path</span>中对应的结果添加到result list中<br>            StringBuilder sb = <span class="hljs-built_in">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>;i++)&#123;<br>                sb.append(String.valueOf(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i)));<br>                sb.append(&quot;-&gt;&quot;);<br>            &#125;<br>            sb.append(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>));<br>            //将当前结果加入到result list中<br>            result.<span class="hljs-keyword">add</span>(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        //每次递归需要执行的代码<br>        //不是空结点才进行递归<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.left, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.right, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        travelTreeAllPath(root, <span class="hljs-type">path</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径（使用迭代方法实现）"><a href="#257-二叉树的所有路径（使用迭代方法实现）" class="headerlink" title="257.二叉树的所有路径（使用迭代方法实现）"></a>257.二叉树的所有路径（使用迭代方法实现）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public List&lt;String&gt; binary<span class="hljs-constructor">TreePaths(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-comment">//使用前序迭代法</span><br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return result;<br>        &#125;<br>        <span class="hljs-comment">//保存当前对应的tmp path</span><br>        Stack&lt;String&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//保存前序遍历时的树结点</span><br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        st.push(root);<br>        path.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span>);<br>        <span class="hljs-keyword">while</span>(!st.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            TreeNode node = st.peek<span class="hljs-literal">()</span>;<br>            st.pop<span class="hljs-literal">()</span>;<span class="hljs-comment">//弹出栈顶结点</span><br><br>            <span class="hljs-comment">//去除该节点对应的path</span><br>            String str = path.peek<span class="hljs-literal">()</span>;<br>            path.pop<span class="hljs-literal">()</span>;<br><br>            <span class="hljs-comment">//入栈之前先判断当前是否为叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>node.right<span class="hljs-operator"> == </span>null)&#123;<br>                <span class="hljs-comment">//将path放入到result数组中</span><br>                result.add(str);<br>            &#125;<br><br>            <span class="hljs-comment">//右左中顺序入栈</span><br>            <span class="hljs-keyword">if</span>(node.right != null)&#123;<br>                st.push(node.right);<br>                StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">str</span>)</span>;<br>                sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.append(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">node</span>.<span class="hljs-params">right</span>.<span class="hljs-params">val</span>)</span>);<br>                path.push(sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(node.left != null)&#123;<br>                st.push(node.left);<br>                StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">str</span>)</span>;<br>                sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.append(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">node</span>.<span class="hljs-params">left</span>.<span class="hljs-params">val</span>)</span>);<br>                path.push(sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="404-左叶子之和（使用迭代法）"><a href="#404-左叶子之和（使用迭代法）" class="headerlink" title="404.左叶子之和（使用迭代法）"></a>404.左叶子之和（使用迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//二叉树迭代遍历得到左右左叶子之和</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//判断条件需要重新理解</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span> &amp;&amp; node.left.left == <span class="hljs-keyword">null</span> &amp;&amp; node.left.right == <span class="hljs-keyword">null</span>)&#123;<br>                    result += node.left.val;<br>                &#125;<br>                <span class="hljs-comment">//按照右左中的顺序加入栈中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230605</title>
    <link href="/2023/06/05/leetcode-notes-20230605/"/>
    <url>/2023/06/05/leetcode-notes-20230605/</url>
    
    <content type="html"><![CDATA[<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义递归函数</span><br>    void preorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-comment">//将当前root节点的值存入到result中</span><br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br>    public List&lt;Integer&gt; preorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义后续遍历递归函数</span><br>    void tree<span class="hljs-constructor">PostOrderTraversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>    &#125;<br><br>    public List&lt;Integer&gt; postorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    void tree<span class="hljs-constructor">InorderTraversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br><br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br><br>    public List&lt;Integer&gt; inorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历（迭代方式）"><a href="#144-二叉树的前序遍历（迭代方式）" class="headerlink" title="144.二叉树的前序遍历（迭代方式）"></a>144.二叉树的前序遍历（迭代方式）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//非递归方式遍历二叉树</span><br>        <span class="hljs-comment">//定义一个保存节点值的栈</span><br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-comment">//定义返回的结果数组</span><br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <br>        st.add(root);<br>        <span class="hljs-comment">//while循环Stack栈，将其中的val添加到result数组中</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode tmpNode <span class="hljs-operator">=</span> st.pop();<br>            <span class="hljs-comment">//将当前节点加入到result中</span><br>            result.add(tmpNode.<span class="hljs-keyword">val</span>);<br>            <span class="hljs-comment">//然后将tmpNode节点的右节点现加入到st中</span><br>            <span class="hljs-keyword">if</span>(tmpNode.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(tmpNode.right);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(tmpNode.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(tmpNode.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历（迭代法）"><a href="#94-二叉树的中序遍历（迭代法）" class="headerlink" title="94.二叉树的中序遍历（迭代法）"></a>94.二叉树的中序遍历（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> inorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法得到二叉树的中序遍历节点值</span><br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        TreeNode curr <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">while</span>(curr <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> <span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            <span class="hljs-keyword">if</span>(curr <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(curr);<br>                curr <span class="hljs-operator">=</span> curr.left;<span class="hljs-comment">//得到左节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//表示左子树到底了，需要开始向result中添加节点值</span><br>                curr <span class="hljs-operator">=</span> st.pop();<span class="hljs-comment">//弹出节点</span><br>                result.add(curr.<span class="hljs-keyword">val</span>);<span class="hljs-comment">//将弹出的节点加入到result数组中</span><br>                curr <span class="hljs-operator">=</span> curr.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历（迭代法）"><a href="#145-二叉树的后序遍历（迭代法）" class="headerlink" title="145.二叉树的后序遍历（迭代法）"></a>145.二叉树的后序遍历（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> postorderTraversal(TreeNode root) &#123;<br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.pop();<br>            result.add(node.<span class="hljs-keyword">val</span>);<br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        Collections.reverse(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历（统一迭代法）"><a href="#144-二叉树的前序遍历（统一迭代法）" class="headerlink" title="144.二叉树的前序遍历（统一迭代法）"></a>144.二叉树的前序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//统一模板进行二叉树遍历</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//判断右节点是否为空，不为空加入到stack中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果遇到节点为null，首先弹出null节点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<span class="hljs-comment">//弹出不是null的节点（标记的结点）</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                result.add(node.val);<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历（统一迭代法）"><a href="#94-二叉树的中序遍历（统一迭代法）" class="headerlink" title="94.二叉树的中序遍历（统一迭代法）"></a>94.二叉树的中序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//将右节点添加到st中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br><br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//弹出空节点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出被标记节点</span><br>                result.add(node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历（统一迭代法）"><a href="#145-二叉树的后序遍历（统一迭代法）" class="headerlink" title="145.二叉树的后序遍历（统一迭代法）"></a>145.二叉树的后序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//先将中间节点放进st中</span><br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//再将右节点放入stack中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左节点放入stack中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//弹出null结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>                result.add(node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230604</title>
    <link href="/2023/06/04/leetcode-notes-20230604/"/>
    <url>/2023/06/04/leetcode-notes-20230604/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针相关题目"><a href="#双指针相关题目" class="headerlink" title="双指针相关题目"></a>双指针相关题目</h1><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-keyword">val</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125;<br>            fast++;<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>双指针法中出现的题目均为前边几个章节中已经出现过的，这里就不再赘述，可以查看本人之前的博客进行学习。</em></p><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;<br><br>    <span class="hljs-comment">//定义两个栈</span><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        <span class="hljs-comment">//调用得到stackOut</span><br>        isStackOut();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>()</span> &#123;<br>        isStackOut();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">//判断stackOut是否为空，如果是空的，直接将stackIn中的元素放到stackOut中</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isStackOut</span>()</span>&#123;<br>        <span class="hljs-comment">//如果栈不是空的</span><br>        <span class="hljs-keyword">if</span>(!stackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>            stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;<br><br>    Queue&lt;Integer&gt; q1;<br>    Queue&lt;Integer&gt; q2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span>()</span> &#123;<br>        q1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        q2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        <span class="hljs-comment">//先放在q2辅助队列中，为了保证最后进入的元素最先出来</span><br>        q2.offer(x);<br>        <span class="hljs-comment">//将q1队列中的其他元素加入到q2中</span><br>        <span class="hljs-keyword">while</span>(!q1.isEmpty())&#123;<br>            q2.offer(q1.poll());<br>        &#125;<br>        <span class="hljs-comment">//最后将q2和q1进行交换</span><br>        Queue&lt;Integer&gt; qTemp = q1;<br>        q1 = q2;<br>        q2 = qTemp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.poll();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">top</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化栈</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dict用于表示匹配关系</span><br>        Map&lt;Character, Character&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.<span class="hljs-built_in">toCharArray</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">containsKey</span>(ch)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果此时栈为空，那么表示此时符号进栈之后不可能再找到与之匹配的符号，直接返回false；</span><br>                <span class="hljs-comment">//或者栈不为空，但是此时即将入栈的符号和栈顶的符号不匹配，也直接返回false即可；</span><br>                <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>() || dict.<span class="hljs-built_in">get</span>(stack.<span class="hljs-built_in">pop</span>()) != ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">isEmpty</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化定义栈</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stack</span>&lt;Character&gt;();<br><br>        <span class="hljs-keyword">for</span>(Character ch : s.<span class="hljs-built_in">toCharArray</span>())&#123;<br>            <span class="hljs-comment">//判断栈顶元素是否和当前元素相同，相同同时都删除</span><br>            <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">isEmpty</span>() &amp;&amp; stack.<span class="hljs-built_in">peek</span>() == ch)&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//最终得到stack中的字符串</span><br>        <span class="hljs-type">String</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">isEmpty</span>())&#123;<br>            result = stack.<span class="hljs-built_in">pop</span>() + result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//优化版本，使用了StringBuilder加快了代码执行的效率</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.<span class="hljs-built_in">toCharArray</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!stack.<span class="hljs-built_in">isEmpty</span>() &amp;&amp; stack.<span class="hljs-built_in">peek</span>() == ch) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            sb.<span class="hljs-built_in">append</span>(stack.<span class="hljs-built_in">pop</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">toString</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> eval<span class="hljs-constructor">RPN(String[] <span class="hljs-params">tokens</span>)</span> &#123;<br>        <span class="hljs-comment">//定义保存符号的Stack</span><br>        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        Map&lt;String, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        dict.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">1</span>);<br>        dict.put(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">2</span>);<br>        dict.put(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">3</span>);<br>        dict.put(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">for</span>(String str : tokens)&#123;<br>            <span class="hljs-keyword">if</span>(dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">str</span>)</span>)&#123;<br>                <span class="hljs-built_in">int</span> second = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>                <span class="hljs-built_in">int</span> first = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>                <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>                    result = first + second;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">2</span>)&#123;<br>                    result = first - second;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">3</span>)&#123;<br>                    result = first<span class="hljs-operator"> * </span>second;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    result = first<span class="hljs-operator"> / </span>second;<br>                &#125;<br>                stack.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">result</span>)</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.push(str);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//优化之后的代码</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> eval<span class="hljs-constructor">RPN(String[] <span class="hljs-params">tokens</span>)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinkedList()</span>;<br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="hljs-comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br>                stack.push(stack.pop<span class="hljs-literal">()</span> + stack.pop<span class="hljs-literal">()</span>);      <span class="hljs-comment">// 注意 - 和/ 需要特殊处理</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(s)) &#123;<br>                stack.push(-stack.pop<span class="hljs-literal">()</span> + stack.pop<span class="hljs-literal">()</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(s)) &#123;<br>                stack.push(stack.pop<span class="hljs-literal">()</span><span class="hljs-operator"> * </span>stack.pop<span class="hljs-literal">()</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/&quot;</span>.equals(s)) &#123;<br>                <span class="hljs-built_in">int</span> temp1 = stack.pop<span class="hljs-literal">()</span>;<br>                <span class="hljs-built_in">int</span> temp2 = stack.pop<span class="hljs-literal">()</span>;<br>                stack.push(temp2<span class="hljs-operator"> / </span>temp1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">s</span>)</span>);<br>            &#125;<br>        &#125;<br>        return stack.pop<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义自己实现的一个基于双端队列的单调队列类</span><br><span class="hljs-keyword">class</span> MyQueue&#123;<br>    Deque&lt;Integer&gt; dequeue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">//设置poll方法</span><br>    void poll(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-comment">//移除的时候判断当前移除的元素是否和队列的头部相同，相同则弹出</span><br>        <span class="hljs-keyword">if</span>(!dequeue.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>dequeue.peek<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)&#123;<br>            dequeue.poll<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置的add方法</span><br>    <span class="hljs-comment">//add的时候需要判断和当前队列中的元素的大小关系，需要维持递减的顺序</span><br>    void add(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">while</span>(!dequeue.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>dequeue.get<span class="hljs-constructor">Last()</span> &lt; <span class="hljs-keyword">val</span>)&#123;<br>            dequeue.remove<span class="hljs-constructor">Last()</span>;<span class="hljs-comment">//移除最后的元素</span><br>        &#125;<br>        <span class="hljs-comment">//增加到队列中</span><br>        dequeue.add(<span class="hljs-keyword">val</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获得队列头部元素值</span><br>    <span class="hljs-built_in">int</span> peek<span class="hljs-literal">()</span>&#123;<br>        return dequeue.peek<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> max<span class="hljs-constructor">SlidingWindow(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>            return nums;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> len = nums.length -k + <span class="hljs-number">1</span>;<span class="hljs-comment">//定义最后结果数组的长度</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置的结果数组对应的index索引值</span><br><br>        MyQueue myqueue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyQueue()</span>;<br><br>        <span class="hljs-comment">//先将前k个元素放入队列中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            myqueue.add(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//得到第一个前k个元素中最大值</span><br>        result<span class="hljs-literal">[<span class="hljs-identifier">index</span><span class="hljs-operator">++</span>]</span> = myqueue.peek<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">//循环遍历后边的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-comment">//滑动窗口往后移动一格，首先判断队列中的第一个元素是否需要弹出</span><br>            myqueue.poll(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-identifier">k</span>]</span>);<br>            <span class="hljs-comment">//然后判断，增加的元素是否需要到达队顶</span><br>            myqueue.add(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>            <span class="hljs-comment">//记录最大值</span><br>            result<span class="hljs-literal">[<span class="hljs-identifier">index</span><span class="hljs-operator">++</span>]</span> = myqueue.peek<span class="hljs-literal">()</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> top<span class="hljs-constructor">KFrequent(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">//key为元素，value为元素出现的频率</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i: nums)&#123;<br>            map.put(i, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">i</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//按照map的value进行排序</span><br>        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; sortedList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.entry<span class="hljs-constructor">Set()</span>);<br>        <span class="hljs-comment">// 使用 Comparator 和流式操作按照 value 进行降序排序</span><br>        sortedList.sort(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Map</span>.</span><span class="hljs-module"><span class="hljs-identifier">Entry</span>.</span></span>comparing<span class="hljs-constructor">ByValue(Comparator.<span class="hljs-params">reverseOrder</span>()</span>));<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i ++)&#123;<br>            result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sortedList.get(i).get<span class="hljs-constructor">Key()</span>;    <br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//使用小顶堆实现</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> top<span class="hljs-constructor">KFrequent(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">//保存key-value对应的字典</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> num: nums)&#123;<br>            map.put(num, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">num</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//创建优先级队列</span><br>        <span class="hljs-comment">//后边设置插入的顺序为构建小顶堆</span><br>        PriorityQueue&lt;<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair1<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>-pair2<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>);<br>        <br>        <span class="hljs-comment">//遍历map，开始插入</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entry<span class="hljs-constructor">Set()</span>)&#123;<br>            <span class="hljs-comment">//首先，判断小顶堆中元素个数，如果小于k，直接插入即可</span><br>            <span class="hljs-keyword">if</span>(pq.size<span class="hljs-literal">()</span> &lt; k)&#123;<br>                pq.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;entry.get<span class="hljs-constructor">Key()</span>, entry.get<span class="hljs-constructor">Value()</span>&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//判断当前准备插入的元素对是否大于当前顶点，如果是，删除顶点，然后直接插入当前节点</span><br>                <span class="hljs-keyword">if</span>(entry.get<span class="hljs-constructor">Value()</span> &gt; pq.peek<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>)&#123;<br>                    <span class="hljs-comment">//先弹出顶点元素</span><br>                    pq.poll<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">//然后插入</span><br>                    pq.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;entry.get<span class="hljs-constructor">Key()</span>, entry.get<span class="hljs-constructor">Value()</span>&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建返回数组结果</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>        <span class="hljs-comment">//循环pq队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = pq.poll<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>双指针</tag>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230602</title>
    <link href="/2023/06/02/leetcode-notes-20230602/"/>
    <url>/2023/06/02/leetcode-notes-20230602/</url>
    
    <content type="html"><![CDATA[<h2 id="459-重复的子字符串（需要不定时回顾，使用了KMP算法）"><a href="#459-重复的子字符串（需要不定时回顾，使用了KMP算法）" class="headerlink" title="459.重复的子字符串（需要不定时回顾，使用了KMP算法）"></a>459.重复的子字符串（需要不定时回顾，使用了KMP算法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//得到前缀表的函数</span><br>    void get<span class="hljs-constructor">Next(<span class="hljs-params">int</span>[] <span class="hljs-params">next</span>, String <span class="hljs-params">s</span>)</span>&#123;<br>        next<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                j = next<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>;<br>            &#125;<br>            <span class="hljs-comment">//判断字符串s中对应位置为i和j是否包含相等的字符</span><br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                j++;<br>            &#125;<br>            next<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = j;<br>        &#125;<br>    &#125;<br><br>    public boolean repeated<span class="hljs-constructor">SubstringPattern(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">//使用KMP字符串匹配算法实现</span><br>        <span class="hljs-keyword">if</span>(s.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//构造长度为s.length()的next数组</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">s</span>.<span class="hljs-identifier">length</span>()]</span>;<br>        get<span class="hljs-constructor">Next(<span class="hljs-params">next</span>, <span class="hljs-params">s</span>)</span>;<br>        <span class="hljs-built_in">int</span> len = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(next<span class="hljs-literal">[<span class="hljs-identifier">len</span> - <span class="hljs-number">1</span>]</span> != <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>len % (len - next<span class="hljs-literal">[<span class="hljs-identifier">len</span> - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>字符串处理相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230601</title>
    <link href="/2023/06/01/leetcode-notes-20230601/"/>
    <url>/2023/06/01/leetcode-notes-20230601/</url>
    
    <content type="html"><![CDATA[<h2 id="350-两个数组的交集"><a href="#350-两个数组的交集" class="headerlink" title="350.两个数组的交集"></a>350.两个数组的交集</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] <span class="hljs-keyword">intersect</span>(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span>[] record1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-type">int</span>[] record2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br><br>        <span class="hljs-type">int</span> nums1Length = nums1.length;<br>        <span class="hljs-type">int</span> nums2Length = nums2.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1Length;i++)&#123;<br>            record1[nums1[i]]++; <br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; nums2Length;i++)&#123;<br>            record2[nums2[i]]++;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; tmp = <span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        <br>        <span class="hljs-type">int</span> n = Math.max(record1.length, record2.length);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(record1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; record2[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> m = Math.min(record1[i], record2[i]);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>                    tmp.<span class="hljs-keyword">add</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[tmp.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.size();i++)&#123;<br>            result[i] = tmp.<span class="hljs-keyword">get</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//得到数字n的每个位置上的数字平方和</span><br>    <span class="hljs-built_in">int</span> getSum(<span class="hljs-built_in">int</span> n)&#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">sum</span> += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isHappy(<span class="hljs-built_in">int</span> n) &#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-built_in">int</span> currSum = getSum(n);<br>            <span class="hljs-keyword">if</span>(currSum == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(dict.containsKey(currSum) &amp;&amp; dict.get(currSum) != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dict.put(currSum, <span class="hljs-number">1</span>);<br>            &#125;<br>            n = currSum;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums2.length;j++)&#123;<br>                map.<span class="hljs-built_in">put</span>(nums1[i] + nums2[j], map.<span class="hljs-built_in">getOrDefault</span>(nums1[i] + nums2[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums3.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums4.length;j++)&#123;<br>                count += map.<span class="hljs-built_in">getOrDefault</span>(<span class="hljs-number">0</span> - (nums3[i] + nums4[j]), <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//首先对nums进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//判断第一个nums是否为大于0，如果是直接返回空的list</span><br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br><br>        <span class="hljs-comment">//然后使用双指针循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-comment">//从i=1开始，判断当前元素和前一个元素是否相同，相同直接跳过</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//然后使用双指针</span><br>            <span class="hljs-built_in">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//当left&lt;right时进入循环</span><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-comment">//判断三者之和与0的大小关系</span><br>                <span class="hljs-comment">//当三者之和大于0时，right--</span><br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//三者之和等于0，那么作为一个结果添加到result中</span><br>                    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    tmp.<span class="hljs-keyword">add</span>(nums[i]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[left]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[right]);<br>                    result.<span class="hljs-keyword">add</span>(tmp);<span class="hljs-comment">//将当前的结果list添加到result中</span><br><br>                    <span class="hljs-comment">//然后去除和left/right重复的元素</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br><br>                    left++;<span class="hljs-comment">//左指针向右++</span><br>                    right--;<span class="hljs-comment">//右指针向左--</span><br>                    <br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;i ++)&#123;<br>            <span class="hljs-comment">//进行剪枝处理</span><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-keyword">target</span> &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//进入第二层循环</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length;j++)&#123;<br>                <span class="hljs-comment">//剪枝</span><br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; <span class="hljs-keyword">target</span> &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//对j进行去重</span><br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//准备使用双指针</span><br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i] + nums[j] + nums[left] + nums[right] &gt; <span class="hljs-keyword">target</span>)&#123;<br>                        right--;<br>                    &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[i] + nums[j] + nums[left] + nums[right] &lt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                        left++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        tmp.add(nums[i]);<br>                        tmp.add(nums[j]);<br>                        tmp.add(nums[left]);<br>                        tmp.add(nums[right]);<br>                        result.add(tmp);<br><br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                            right--;<br>                        &#125;<br><br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                            left++;<br>                        &#125;<br><br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public void reverseString(<span class="hljs-built_in">char</span>[] s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = s.length - <span class="hljs-number">1</span>;<br><br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">char</span> tmp = s[<span class="hljs-built_in">left</span>];<br>            s[<span class="hljs-built_in">left</span>] = s[<span class="hljs-built_in">right</span>];<br>            s[<span class="hljs-built_in">right</span>] = tmp;<br>            <span class="hljs-built_in">left</span>++;<br>            <span class="hljs-built_in">right</span>--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541.反转字符串 II"></a>541.反转字符串 II</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-type">void</span> reverse(<span class="hljs-type">char</span>[] s_char, <span class="hljs-type">int</span> <span class="hljs-keyword">begin</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-type">char</span> tmp = s_char[<span class="hljs-keyword">end</span>];<br>            s_char[<span class="hljs-keyword">end</span>] = s_char[<span class="hljs-keyword">begin</span>];<br>            s_char[<span class="hljs-keyword">begin</span>] = tmp;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> String reverseStr(String s, <span class="hljs-type">int</span> k) &#123;<br>        //将String字符串转换为<span class="hljs-type">char</span>数组<br>        <span class="hljs-type">char</span>[] s_char = s.toCharArray();<br>        <span class="hljs-type">int</span> n = s.length();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(;i &lt; n;i = i + <span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-type">int</span> start = i;<br>            <span class="hljs-type">int</span> end = Math.min(n - <span class="hljs-number">1</span>, <span class="hljs-keyword">start</span> + k - <span class="hljs-number">1</span>);<br>            reverse(s_char, <span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(s_char);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String replace<span class="hljs-constructor">Space(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s<span class="hljs-operator"> == </span>null)&#123;<br>            return null;<br>        &#125;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>            &#125;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br><br>    void reverse<span class="hljs-constructor">String(StringBuilder <span class="hljs-params">sb</span>, <span class="hljs-params">int</span> <span class="hljs-params">begin</span>, <span class="hljs-params">int</span> <span class="hljs-params">end</span>)</span>&#123;<br>        <span class="hljs-comment">//然后反转字符串</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-built_in">char</span> tmp = sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">begin</span>)</span>;<br>            sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">begin</span>, <span class="hljs-params">sb</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">end</span>)</span>);<br>            sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">end</span>, <span class="hljs-params">tmp</span>)</span>;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span>--;<br>        &#125;<br>    &#125;<br><br>    public String reverse<span class="hljs-constructor">Words(String <span class="hljs-params">s</span>)</span> &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-comment">//先删除字符串中前边或后边的空格</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = s.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-comment">//去除字符串中间多余的空格</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span> != <span class="hljs-character">&#x27; &#x27;</span><span class="hljs-operator"> || </span>sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">sb</span>.<span class="hljs-params">length</span>()</span> - <span class="hljs-number">1</span>) != <span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>);<br>            &#125;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">begin</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = sb.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>, <span class="hljs-params">begin</span>, <span class="hljs-params">end</span>)</span>;<br><br>        <span class="hljs-comment">//反转字符串之后，反转字符串中每个单词</span><br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> inner_end = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> n = sb.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; n)&#123;<br>            <span class="hljs-keyword">while</span>(inner_end &lt; n<span class="hljs-operator"> &amp;&amp; </span>sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">inner_end</span>)</span> != <span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                inner_end++;<br>            &#125;<br>            <span class="hljs-comment">//反转从start到end的字符串</span><br>            reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>, <span class="hljs-params">start</span>, <span class="hljs-params">inner_end</span> - 1)</span>;<br>            <span class="hljs-comment">//然后进入下一个单词</span><br>            start = inner_end + <span class="hljs-number">1</span>;<br>            inner_end = start + <span class="hljs-number">1</span>;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String reverse<span class="hljs-constructor">LeftWords(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> l = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//得到实际左旋转的格数</span><br>        <span class="hljs-built_in">int</span> k = n % l;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k;i &lt; l;i++)&#123;<br>            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>        &#125;<br><br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a>28.找出字符串中第一个匹配项的下标</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> str<span class="hljs-constructor">Str(String <span class="hljs-params">haystack</span>, String <span class="hljs-params">needle</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack.length<span class="hljs-literal">()</span> &lt; needle.length<span class="hljs-literal">()</span>) return -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length<span class="hljs-literal">()</span>)&#123;<br>            <span class="hljs-comment">//每次设置j从0开始</span><br>            j = <span class="hljs-number">0</span>;<br>            result = i;<br>            <span class="hljs-comment">//判断是否成功，成功直接返回true，否则返回false</span><br>            <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                <span class="hljs-keyword">while</span>(j &lt; needle.length<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>i &lt; haystack.length<span class="hljs-literal">()</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                        i++;<br>                        j++;<br>                        continue;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        break;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-operator"> == </span>needle.length<span class="hljs-literal">()</span>)&#123;<br>                    return result;<br>                &#125;<br>            &#125;<br>            i = result + <span class="hljs-number">1</span>;<br>        &#125;<br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230531</title>
    <link href="/2023/05/31/leetcode-notes-20230531/"/>
    <url>/2023/05/31/leetcode-notes-20230531/</url>
    
    <content type="html"><![CDATA[<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//慢指针每次走一步</span><br>            slow = slow.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//快指针每次走两步</span><br>            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//如果两个指针相遇，那么一个指针从相遇结点出发，一个指针从头节点出发，等到下次两个节点相遇的时候就是链表环形入口结点</span><br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                ListNode index1 = fast;<br>                ListNode index2 = head;<br>                <span class="hljs-keyword">while</span>(index1 != index2)&#123;<br>                    index1 = index1.<span class="hljs-keyword">next</span>;<br>                    index2 = index2.<span class="hljs-keyword">next</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD##"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>##</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> isAnagram(String s, String t) &#123;<br>        //设置<span class="hljs-type">record</span>数组的长度大小为<span class="hljs-number">26</span>（<span class="hljs-number">26</span>个小写字母）<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; s.length();i++)&#123;<br>            <span class="hljs-type">record</span>[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; t.length();i++)&#123;<br>            <span class="hljs-type">record</span>[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> canConstruct(String ransomNote, String magazine) &#123;<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.length();i++)&#123;<br>            <span class="hljs-type">record</span>[ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; magazine.length();i++)&#123;<br>            <span class="hljs-type">record</span>[magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        //数组作为map<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length;i++)&#123;<br>            //map只记录是否有，并不需要记录每个key值对应的<span class="hljs-keyword">values</span>数量<br>            <span class="hljs-type">record</span>[nums1[i]] = <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[nums2[i]] == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">record</span>[nums2[i]] = <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; tmpList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;(); <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] == <span class="hljs-number">3</span>)&#123;<br>                tmpList.<span class="hljs-keyword">add</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[tmpList.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: tmpList)&#123;<br>            result[<span class="hljs-keyword">index</span>] = tmpList.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">index</span>);<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>0faf98f2fe074769adf459ed307fb014a35a9876</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wsl-win10-setup-logs</title>
    <link href="/2023/05/31/wsl-win10-setup-logs/"/>
    <url>/2023/05/31/wsl-win10-setup-logs/</url>
    
    <content type="html"><![CDATA[<h1 id="本篇博客主要记录本人在windows10系统中安装WSL（用于windows的linux子系统）的详细过程"><a href="#本篇博客主要记录本人在windows10系统中安装WSL（用于windows的linux子系统）的详细过程" class="headerlink" title="本篇博客主要记录本人在windows10系统中安装WSL（用于windows的linux子系统）的详细过程"></a>本篇博客主要记录本人在windows10系统中安装WSL（用于windows的linux子系统）的详细过程</h1><h2 id="WSL是什么？-–from-chatGPT"><a href="#WSL是什么？-–from-chatGPT" class="headerlink" title="WSL是什么？*–from chatGPT*"></a>WSL是什么？*–from chatGPT*</h2><p>WSL（Windows Subsystem for Linux）是一种在 Windows 操作系统上运行 Linux 环境的兼容层。它允许用户在 Windows 上使用原生的 Linux shell 和命令行工具，以及在 Linux 上运行的应用程序和工具。WSL 提供了一个完整的 Linux 内核接口，可以在 Windows 系统上运行 Linux 发行版，如 Ubuntu、Debian、Fedora 等。</p><p>WSL 的设计目标是提供一个无需双启动、虚拟机或容器的方式，在 Windows 上进行 Linux 开发和运行 Linux 应用程序。通过 WSL，开发人员可以利用 Windows 的生态系统和工具，并使用 Linux 的开发环境和工具链。WSL 提供了与 Linux 完全兼容的系统调用，可以在 Windows 上运行许多 Linux 软件包和应用程序。</p><p>WSL 分为两个主要版本：WSL 1 和 WSL 2。WSL 1 是通过将 Windows 和 Linux 之间的系统调用转换为 Windows API 实现的，而 WSL 2 则基于 Hyper-V 虚拟化技术，在 Windows 中运行一个完整的 Linux 内核。</p><p>使用 WSL，用户可以在 Windows 上进行各种任务，如开发和调试应用程序、运行脚本、使用命令行工具等，同时享受到 Windows 操作系统的优势和便利性。</p><h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><ol><li>首先，保证windows10原生，不然后续会有很多错误出现；</li><li>在微软商店安装WSL之前，请先设置Windows10系统中两个选项，打开“控制面板\程序\程序和功能\启用或关闭windows功能”，在弹出的窗口中勾选“适用于Linux的Windows子系统”、“虚拟机平台”两个选项；</li><li>然后，为了保证WSL默认安装version&#x3D;2，使用管理员身份打开windows10中的PowerShell，然后运行如下命令：</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">wsl --<span class="hljs-keyword">set</span>-<span class="hljs-keyword">default</span>-version <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ol start="5"><li>此时，前序工作已经完成。然后，在Microsoft Store中搜索Ubuntu（建议下载18.04版本，本教程基于Ubuntu-18.04安装），并安装（默认安装位置在C:\Windows\System32下面，后边会介绍将WSL镜像迁移到其他系统盘）；</li><li>使用管理员身份打开cmd&#x2F;PowerShell，在命令行输入：</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wsl -l -v</span><br></code></pre></td></tr></table></figure><p>查看当前WSL状态，如果看到如下所示，状态为stopped，那么继续进行下一步操作：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">  NAME            STATE           <span class="hljs-keyword">VERSION</span><br>* Ubuntu-<span class="hljs-number">18.04</span>    <span class="hljs-literal">Stopped</span>         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果看到状态为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <span class="hljs-type">NAME</span>            STATE           <span class="hljs-keyword">VERSION</span><br>* Ubuntu<span class="hljs-number">-18.04</span>    Running         <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那么，请在窗口运行如下命令将状态更改为Stopped；</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">wsl <span class="hljs-comment">--shutdown</span><br></code></pre></td></tr></table></figure><h2 id="将WSL迁移到其他系统盘（不放在C盘），并重新装载"><a href="#将WSL迁移到其他系统盘（不放在C盘），并重新装载" class="headerlink" title="将WSL迁移到其他系统盘（不放在C盘），并重新装载"></a>将WSL迁移到其他系统盘（不放在C盘），并重新装载</h2><ol><li>经过上述步骤之后，目前Ubuntu-18.04镜像已经被shutdown，同时存在于C盘下，然后使用管理员身份打开cmd&#x2F;PowerShell，然后运行如下命令：</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wsl</span> --export Ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">04</span> F:\ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.tar<br></code></pre></td></tr></table></figure><p>接着注销Ubuntu-18.04：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wsl</span> --unregister Ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure><p>然后，从路径F:\ubuntu-18.04.tar下重新导入镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wsl</span> --import Ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">04</span> F:\Ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">04</span>\ F:\ubuntu-<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.tar --version <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="配置WSL"><a href="#配置WSL" class="headerlink" title="配置WSL"></a>配置WSL</h2><ol><li>使用管理员身份打开PowerShell，然后按照如下步骤进行；</li><li>首先检查WSL是否装载成功</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wsl -l -v</span><br></code></pre></td></tr></table></figure><ol start="3"><li>然后，运行如下命令进入到WSL中：</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wsl</span><br></code></pre></td></tr></table></figure><ol start="4"><li>接着会让你设置root密码，随便设置即可</li><li>后续操作同在Linux中一样，创建用户&#x2F;配置python开发环境&#x2F;配置C++开发环境&#x2F;配置java开发环境（哈哈java开发还是推荐windows10+IDEA，太爽了）</li></ol><h2 id="WSL容量扩充-1-（我个人理解相当于，将WSL系统能够使用的虚拟磁盘大小进行扩充，推荐1T，当然这取决于你自己主机的硬盘大小）"><a href="#WSL容量扩充-1-（我个人理解相当于，将WSL系统能够使用的虚拟磁盘大小进行扩充，推荐1T，当然这取决于你自己主机的硬盘大小）" class="headerlink" title="WSL容量扩充[1]（我个人理解相当于，将WSL系统能够使用的虚拟磁盘大小进行扩充，推荐1T，当然这取决于你自己主机的硬盘大小）"></a>WSL容量扩充[1]（我个人理解相当于，将WSL系统能够使用的虚拟磁盘大小进行扩充，推荐1T，当然这取决于你自己主机的硬盘大小）</h2><ol><li>首先，运行如下命令关闭Ubuntu-18.04：</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">wsl <span class="hljs-comment">--shutdown</span><br>wsl -l -v （检查是否关闭）<br></code></pre></td></tr></table></figure><ol start="2"><li>然后，运行如下命令查看wsl默认分配的空间大小（默认分配了256GB）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl <span class="hljs-built_in">df</span> -h /.<br></code></pre></td></tr></table></figure><ol start="3"><li>进入到wsl镜像安装目录: F:\Ubuntu-18.04\ext4.vhdx</li><li>然后，使用管理员身份打开PowerShell，运行如下命令以扩充WSL所依赖的虚拟磁盘的最大大小（也就是最大容量）</li></ol><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">diskpart</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Select</span> vdisk file=<span class="hljs-string">&quot;F:\Ubuntu-18.04\ext4.vhdx&quot;</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">expand vdisk maximum=xxxxxxxx <span class="hljs-comment">//MB为单位</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>然后启动wsl，进入wsl，并运行如下命令[1]：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">mount</span> <span class="hljs-literal">-t</span> devtmpfs none /dev<br><span class="hljs-built_in">mount</span>: /dev: none already mounted on /mnt/wsl.<br><span class="hljs-variable">$</span> <span class="hljs-built_in">mount</span> | grep ext4<br>/dev/sdb on / <span class="hljs-built_in">type</span> ext4 (rw,relatime,discard,errors=re<span class="hljs-built_in">mount-ro</span>,<span class="hljs-keyword">data</span>=ordered)<br><span class="hljs-variable">$</span> sudo resize2fs /dev/sdb //这里是sdb sdc还是其他，取决于你自己的电脑<br></code></pre></td></tr></table></figure><p><em>至此，WSL Ubuntu-18.04安装完成，现在就可以以管理员身份打开PowerShell，运行wsl进入Linux进行体验了，后续还会陆续讲解如何使用windows10上vscode来连接wsl进行代码调试以及python&#x2F;cpp&#x2F;npm&#x2F;nvm&#x2F;nodejs等环境的搭建，敬请期待。</em></p><p><strong>参考文章</strong><br>[1] <a href="https://blog.csdn.net/StarRain2016/article/details/122803337">https://blog.csdn.net/StarRain2016/article/details/122803337</a></p>]]></content>
    
    
    <categories>
      
      <category>WSL setup logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL Usages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230528</title>
    <link href="/2023/05/28/leetcode-notes-20230528/"/>
    <url>/2023/05/28/leetcode-notes-20230528/</url>
    
    <content type="html"><![CDATA[<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode removeElements(ListNode head, int val) &#123;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>();<br>        ListNode resultHead = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = head;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val != val)&#123;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = head;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> resultHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义链表的结点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br>     int <span class="hljs-keyword">val</span>;<span class="hljs-comment">//定义链表中的值</span><br>     ListNode next;<br>     <span class="hljs-comment">//创建构造函数</span><br>     ListNode()&#123;&#125;<br>     <span class="hljs-comment">//创建自定义构造函数</span><br>     ListNode(int <span class="hljs-keyword">val</span>)&#123;<br>         <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>    <span class="hljs-comment">//定义链表的成员变量</span><br>    int size;<br>    <span class="hljs-comment">//定义一个虚拟的头结点</span><br>    ListNode head;<br><br>    <span class="hljs-comment">//在默认构造函数中初始化链表</span><br>    <span class="hljs-keyword">public</span> MyLinkedList() &#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.head = new ListNode(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> int <span class="hljs-keyword">get</span>(int index) &#123;<br>        <span class="hljs-comment">//首先判断index是否无效，如果无效返回-1</span><br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        ListNode resultNode = <span class="hljs-keyword">this</span>.head;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt;= index;i ++)&#123;<br>            resultNode = resultNode.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode.<span class="hljs-keyword">val</span>; <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtHead(int <span class="hljs-keyword">val</span>) &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, <span class="hljs-keyword">val</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtTail(int <span class="hljs-keyword">val</span>) &#123;<br>        addAtIndex(<span class="hljs-keyword">this</span>.size, <span class="hljs-keyword">val</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtIndex(int index, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-keyword">this</span>.size)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>            index = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.size++;<br><br>        ListNode predNode = <span class="hljs-keyword">this</span>.head;<br>        <span class="hljs-comment">//得到predNode（要插入结点的前驱）</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; index;i++)&#123;<br>            predNode = predNode.next;<br>        &#125;<br><br>        ListNode addNode = new ListNode(<span class="hljs-keyword">val</span>);<br>        addNode.next = predNode.next;<br>        predNode.next = addNode;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void deleteAtIndex(int index) &#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-keyword">this</span>.size || index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.size--;<br>        <span class="hljs-comment">//判断index是否为0</span><br>        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode predNode = head;<br>        <span class="hljs-comment">//找到需要删除结点的前驱结点</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; index;i++)&#123;<br>            predNode = predNode.next;<br>        &#125;<br><br>        predNode.next = predNode.next.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj.get(index);</span><br><span class="hljs-comment"> * obj.addAtHead(val);</span><br><span class="hljs-comment"> * obj.addAtTail(val);</span><br><span class="hljs-comment"> * obj.addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> singly<span class="hljs-operator">-</span>linked list.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     ListNode next;<br> <span class="hljs-operator">*</span>     ListNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>, ListNode next) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; this.next <span class="hljs-operator">=</span> next; &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;<br>        ListNode currNode <span class="hljs-operator">=</span> head;<br>        ListNode resultNode <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        ListNode tmpNode <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span>(currNode <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            tmpNode <span class="hljs-operator">=</span> currNode.next;<br>            currNode.next <span class="hljs-operator">=</span> resultNode;<br>            resultNode <span class="hljs-operator">=</span> currNode;<br>            currNode <span class="hljs-operator">=</span> tmpNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-两两交换链表中的结点"><a href="#24-两两交换链表中的结点" class="headerlink" title="24.两两交换链表中的结点"></a>24.两两交换链表中的结点</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;<br>        ListNode xuniHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        xuniHead.<span class="hljs-keyword">next</span> = head;<br>        ListNode curr = xuniHead;<br><br>        <span class="hljs-keyword">while</span>(curr.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp = curr.<span class="hljs-keyword">next</span>;<br>            ListNode tmp1 = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>            curr.<span class="hljs-keyword">next</span> = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = tmp;<br>            curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = tmp1;<br><br>            curr = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> xuniHead.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy.<span class="hljs-keyword">next</span> = head;<br>        ListNode fast = dummy;<br>        ListNode slow = dummy;<br><br>        <span class="hljs-comment">//先移动快指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            fast = fast.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//同时移动快慢指针</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.<span class="hljs-keyword">next</span>;<br>            slow = slow.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;<br>        ListNode currA = headA;<br>        ListNode currB = headB;<br>        <span class="hljs-built_in">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> lenB = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(currA != <span class="hljs-literal">null</span>)&#123;<br>            currA = currA.<span class="hljs-keyword">next</span>;<br>            lenA++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(currB != <span class="hljs-literal">null</span>)&#123;<br>            currB = currB.<span class="hljs-keyword">next</span>;<br>            lenB++;<br>        &#125;<br><br>        currA = headA;<br>        currB = headB;<br><br>        <span class="hljs-comment">//使得currA指向较长链表的那个</span><br>        <span class="hljs-keyword">if</span>(lenA &lt; lenB)&#123;<br>            <span class="hljs-built_in">int</span> tmpL = lenA;<br>            lenA = lenB;<br>            lenB = tmpL;<br>            <br>            ListNode tmpNode = currA;<br>            currA = currB;<br>            currB = tmpNode;<br>        &#125;<br><br>        <span class="hljs-comment">//求两者的长度差</span><br>        <span class="hljs-built_in">int</span> gap = lenA - lenB;<br><br>        <span class="hljs-comment">//然后使得较长的指针移动到较短的链表的尾部位置</span><br>        <span class="hljs-keyword">while</span>(gap-- &gt; <span class="hljs-number">0</span>)&#123;<br>            currA = currA.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//同时移动两个链表的指针</span><br>        <span class="hljs-keyword">while</span>(currA != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(currA == currB)&#123;<br>                <span class="hljs-keyword">return</span> currA;<br>            &#125;<br><br>            currA = currA.<span class="hljs-keyword">next</span>;<br>            currB = currB.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230527</title>
    <link href="/2023/05/27/leetcode-notes-20230527/"/>
    <url>/2023/05/27/leetcode-notes-20230527/</url>
    
    <content type="html"><![CDATA[<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[][] generateMatrix(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-comment">//定义一个动态增加的list，最后转换为int即可</span><br>        <span class="hljs-built_in">int</span>[][] matrixResult = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n][n];<br><br>        <span class="hljs-comment">//设置给每个格子赋值的值</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始值设置为1</span><br>        <span class="hljs-built_in">int</span> offset = <span class="hljs-number">1</span>;<span class="hljs-comment">//设置的每圈应该在右开的时候减少的偏移量</span><br>        <span class="hljs-built_in">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> loop = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> mid = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(loop &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-comment">//上行：从左到右进行填充</span><br>            <span class="hljs-keyword">for</span>(j = startY;j &lt; n - offset;j++)&#123;<br>                matrixResult[startX][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-comment">//右列：从上到下及逆行填充</span><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; n - offset; i++)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; j &gt; startY;j--)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; i &gt; startX;i--)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-comment">//将对应的startX和startY进行更新</span><br>            startX++;<br>            startY++;<br><br>            offset++;<br>            loop--;<br>        &#125;<br><br>        <span class="hljs-comment">//最后判断是否需要填充中心位置的元素</span><br>        <span class="hljs-comment">//也就是n为奇数时需要填充</span><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            matrixResult[mid][mid] = <span class="hljs-keyword">count</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrixResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.length;<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">loop</span> = Math.min(m, n) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">loop</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>;j++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>;i++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(;j &gt; startY; j<span class="hljs-comment">--)&#123;</span><br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(;i &gt; startX;i<span class="hljs-comment">--)&#123;</span><br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            startX++;<br>            startY++;<br>            <span class="hljs-keyword">offset</span>++;<br><br>            <span class="hljs-keyword">loop</span> <span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(result.size() == n * m)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <br>        //添加<br>        <span class="hljs-keyword">if</span>(m &gt; n)&#123;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>;i++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][startY]);<br>            &#125;<br>            result.<span class="hljs-keyword">add</span>(matrix[i][startY]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[startX][j]);<br>            &#125;<br>            result.<span class="hljs-keyword">add</span>(matrix[startX][j]);        <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; n == m)&#123;<br>            result.<span class="hljs-keyword">add</span>(matrix[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指offer29-顺时针打印矩阵"><a href="#剑指offer29-顺时针打印矩阵" class="headerlink" title="剑指offer29.顺时针打印矩阵"></a>剑指offer29.顺时针打印矩阵</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.length;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m*n];<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">loop</span> = Math.min(m, n) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">loop</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j ++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>; i ++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; j &gt; startY; j<span class="hljs-comment">--)&#123;</span><br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; i &gt; startX; i<span class="hljs-comment">--)&#123;</span><br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            startX++;<br>            startY++;<br>            <span class="hljs-keyword">offset</span>++;<br>            <span class="hljs-keyword">loop</span><span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> == m*n)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;here&quot;);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(m &gt; n)&#123;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>; i++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][startY];<br>            &#125;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[m - <span class="hljs-keyword">offset</span>][startY];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[startX][j];<br>            &#125;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[startX][n - <span class="hljs-keyword">offset</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == n &amp;&amp; m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[m / <span class="hljs-number">2</span>][m / <span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230525</title>
    <link href="/2023/05/25/leetcode-notes-20230525/"/>
    <url>/2023/05/25/leetcode-notes-20230525/</url>
    
    <content type="html"><![CDATA[<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//滑动窗口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> target, <span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">1000000001</span>;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">sum</span> &gt;= target)&#123;<br>                <span class="hljs-built_in">int</span> in_result = (i - start) + <span class="hljs-number">1</span>;<br>                result = result &lt; in_result ? result : in_result;<br>                <span class="hljs-keyword">sum</span> -= nums[start++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == <span class="hljs-number">1000000001</span> ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//超时写法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> total<span class="hljs-constructor">Fruit(<span class="hljs-params">int</span>[] <span class="hljs-params">fruits</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = fruits.length;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max_num = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">while</span>(is<span class="hljs-constructor">AboveTwo(<span class="hljs-params">fruits</span>, <span class="hljs-params">start</span>, <span class="hljs-params">i</span>)</span><span class="hljs-operator"> &amp;&amp; </span>start &lt; i)&#123;<br>                start ++;<br>            &#125;<br>            max_num = max_num &lt; (i - start) + <span class="hljs-number">1</span> ? (i - start) + <span class="hljs-number">1</span> : max_num;<br>        &#125;<br>        return max_num;<br>    &#125;<br><br>    <span class="hljs-comment">//判断从start到i之间是否有超过两种不同类型的水果</span><br>    boolean is<span class="hljs-constructor">AboveTwo(<span class="hljs-params">int</span>[] <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span>&#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = left; i &lt;= right;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span><span class="hljs-operator"> &amp;&amp; </span>dict.size<span class="hljs-literal">()</span> &lt; <span class="hljs-number">2</span>)&#123;<br>                dict.put(<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, <span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span><span class="hljs-operator"> &amp;&amp; </span>dict.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">2</span>)&#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span>)&#123;<br>                continue;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//滑动窗口写法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> total<span class="hljs-constructor">Fruit(<span class="hljs-params">int</span>[] <span class="hljs-params">fruits</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = fruits.length;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max_num = -<span class="hljs-number">1</span>;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-comment">//获得原来存在map中的对应的水果种类的水果树数量</span><br>            dict.put(fruits<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">fruits</span>[<span class="hljs-params">i</span>], 0)</span> + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//然后判断当前窗口中是否存在超过两种水果</span><br>            <span class="hljs-keyword">while</span>(dict.size<span class="hljs-literal">()</span> &gt; <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">//设置start对应的位置水果种类对应的树木数量 - 1</span><br>                dict.put(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>, dict.get(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>) - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果在当前滑动窗口中不存在对应的种类的树木（即树木数量为0）</span><br>                <span class="hljs-keyword">if</span>(dict.get(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//那么直接删除dict字典中对应的key</span><br>                    dict.remove(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>);<br>                &#125;<br>                <span class="hljs-comment">//然后滑动窗口左边start向左移动一位</span><br>                start ++;<br>            &#125;<br>            <span class="hljs-comment">//然后，更新最大值</span><br>            max_num = max_num &lt; (i - start) + <span class="hljs-number">1</span> ? (i - start) + <span class="hljs-number">1</span> : max_num;<br>        &#125;<br>        return max_num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String min<span class="hljs-constructor">Window(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> sn = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> tn = t.length<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> minLen = Integer.MAX_VALUE;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br><br>        Map&lt;Character, Integer&gt; tDict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; tn; i++) &#123;<br>            tDict.put(t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>, tDict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">t</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        Map&lt;Character, Integer&gt; windowDict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> formed = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录窗口中满足条件的字符数量</span><br><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sn) &#123;<br>            <span class="hljs-built_in">char</span> c = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>;<br>            windowDict.put(c, windowDict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">c</span>, 0)</span> + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (tDict.contains<span class="hljs-constructor">Key(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> &amp;&amp; </span>windowDict.get(c).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span><span class="hljs-operator"> == </span>tDict.get(c).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>) &#123;<br>                formed++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (left &lt;= right<span class="hljs-operator"> &amp;&amp; </span>formed<span class="hljs-operator"> == </span>tDict.size<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-comment">// 更新最小窗口长度和结果</span><br>                <span class="hljs-built_in">int</span> curLen = right - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (curLen &lt; minLen) &#123;<br>                    minLen = curLen;<br>                    result = s.substring(left, right + <span class="hljs-number">1</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 缩小窗口左边界</span><br>                <span class="hljs-built_in">char</span> leftChar = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>;<br>                windowDict.put(leftChar, windowDict.get(leftChar) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (tDict.contains<span class="hljs-constructor">Key(<span class="hljs-params">leftChar</span>)</span><span class="hljs-operator"> &amp;&amp; </span>windowDict.get(leftChar).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span> &lt; tDict.get(leftChar).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>) &#123;<br>                    formed--;<br>                &#125;<br><br>                left++;<br>            &#125;<br><br>            right++;<br>        &#125;<br><br>        return result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs</title>
    <link href="/2023/05/24/leetcode-notes-20230524/"/>
    <url>/2023/05/24/leetcode-notes-20230524/</url>
    
    <content type="html"><![CDATA[<h1 id="My-LeetCode-HOT-100-logs"><a href="#My-LeetCode-HOT-100-logs" class="headerlink" title="My LeetCode HOT 100 logs"></a>My LeetCode HOT 100 logs</h1><p><em>use language: java</em></p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == <span class="hljs-keyword">target</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-built_in">String</span>[] strs) &#123;<br>        Map&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>: strs)&#123;<br>            <span class="hljs-type">char</span>[] array = <span class="hljs-built_in">str</span>.<span class="hljs-property">toCharArray</span>();<br>            Arrays.<span class="hljs-property">sort</span>(array);<br>            <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(array);<br>            List&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-built_in">map</span>.<span class="hljs-property">getOrDefault</span>(<span class="hljs-built_in">key</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;<span class="hljs-built_in">String</span>&gt;());<br>            list.<span class="hljs-property">add</span>(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">key</span>, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt;(<span class="hljs-built_in">map</span>.<span class="hljs-property">values</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-built_in">int</span> longestConsecutive(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">Set</span>&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>            <span class="hljs-keyword">set</span>.add(<span class="hljs-built_in">num</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">set</span>.contains(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">int</span> currNum = <span class="hljs-built_in">num</span>;<br>                <span class="hljs-built_in">int</span> inner_result = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">set</span>.contains(currNum + <span class="hljs-number">1</span>))&#123;<br>                    inner_result += <span class="hljs-number">1</span>;<br>                    currNum += <span class="hljs-number">1</span>;<br>                &#125;<br>                <br>                result = Math.max(result, inner_result);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span> &#123;<br>    public void moveZeroes(int[] nums) &#123;<br>        int n = nums.length;<br>        <br>        int <span class="hljs-built_in">lp</span> = <span class="hljs-number">0</span>;<br>        int <span class="hljs-built_in">rp</span> = <span class="hljs-built_in">lp</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">lp</span> != n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-type">lp</span>] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-built_in">rp</span> != n)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[<span class="hljs-type">rp</span>] != <span class="hljs-number">0</span>)&#123;<br>                        int tmp = nums[<span class="hljs-type">rp</span>];<br>                        nums[<span class="hljs-type">rp</span>] = nums[<span class="hljs-type">lp</span>];<br>                        nums[<span class="hljs-type">lp</span>] = tmp;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">rp</span> += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">lp</span> += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rp</span> = <span class="hljs-built_in">lp</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> maxArea(<span class="hljs-built_in">int</span>[] height) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = height.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> area = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">int</span> h = Math.min(height[<span class="hljs-built_in">left</span>], height[<span class="hljs-built_in">right</span>]);<br>            area = Math.max(area, h * (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>));<br>            <span class="hljs-built_in">if</span>(height[<span class="hljs-built_in">left</span>] &lt; height[<span class="hljs-built_in">right</span>])&#123;<br>                <span class="hljs-built_in">left</span> ++;<br>            &#125;else&#123;<br>                <span class="hljs-built_in">right</span> -- ;<br>            &#125;<br>        &#125;<br>        return area;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; threeSum(<span class="hljs-type">int</span>[] nums) &#123;<br>        //首先先排序（升序）<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> n = nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            //判断i位置的元素是否和其前一个元素相同，相同那么进入下一次循环<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>)&#123;<br>                    right<span class="hljs-comment">--;</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; tmp = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>                    tmp.<span class="hljs-keyword">add</span>(nums[i]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[left]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[right]);<br>                    result.<span class="hljs-keyword">add</span>(tmp);<br><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right - <span class="hljs-number">1</span>] == nums[right])&#123;<br>                        right<span class="hljs-comment">--;</span><br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left + <span class="hljs-number">1</span>] == nums[left])&#123;<br>                        left++;<br>                    &#125;<br><br>                    right<span class="hljs-comment">--;</span><br>                    left++;<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> lengthOfLongestSubstring(String s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = s.length();<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>)&#123;<br>            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();<br>            map.put(s.charAt(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">left</span>);<br>            while(<span class="hljs-built_in">right</span> &lt; <span class="hljs-built_in">n</span> &amp;&amp; !map.containsKey(s.charAt(<span class="hljs-built_in">right</span>)))&#123;<br>                map.put(s.charAt(<span class="hljs-built_in">right</span>), <span class="hljs-built_in">right</span>);<br>                <span class="hljs-built_in">right</span>++;<br>            &#125;<br>            result = Math.max(result, <span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>);<br>            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">char</span>[] p_chars = p.<span class="hljs-built_in">toCharArray</span>(); <span class="hljs-comment">// 转换为字符数组</span><br>        Arrays.<span class="hljs-built_in">sort</span>(p_chars); <span class="hljs-comment">// 对字符数组进行排序</span><br>        <span class="hljs-type">String</span> sorted_p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(p_chars); <span class="hljs-comment">// 将字符数组转换回字符串</span><br>        <span class="hljs-comment">//System.out.println(&quot;sorted_p: &quot; + sorted_p);</span><br><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-keyword">while</span>(left &lt;= l - n)&#123;<br>            <span class="hljs-type">String</span> tmp = s.<span class="hljs-built_in">substring</span>(left, left + n);<br>            <span class="hljs-type">char</span>[] tmp_chars = tmp.<span class="hljs-built_in">toCharArray</span>(); <span class="hljs-comment">// 转换为字符数组</span><br>            Arrays.<span class="hljs-built_in">sort</span>(tmp_chars); <span class="hljs-comment">// 对字符数组进行排序</span><br>            <span class="hljs-type">String</span> sorted_tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(tmp_chars); <span class="hljs-comment">// 将字符数组转换回字符串</span><br>            <span class="hljs-comment">//System.out.println(&quot;sorted_tmp: &quot; + sorted_tmp);</span><br>            <span class="hljs-keyword">if</span>(sorted_tmp.<span class="hljs-built_in">equals</span>(sorted_p))&#123;<br>                result.<span class="hljs-built_in">add</span>(left);<br>            &#125;<br>            left += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560.和为 K 的子数组"></a>560.和为 K 的子数组</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Solution &#123;<br>    public int subarraySum(int[] nums, int k) &#123;<br>        Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> HashMap&lt;Integer, Integer&gt;();<br>        int <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        int result = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">length</span>;i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">sum</span> - k))&#123;<br>                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span> - k, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            result += <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">sum</span> - k);<br><br>            <br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">sum</span>))&#123;<br>                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span>, <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">sum</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>] || <span class="hljs-keyword">target</span> &gt; nums[nums.length - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-keyword">target</span>)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &gt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &gt; nums[nums.length - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-keyword">target</span>)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &lt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &gt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//暴力解法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                    nums<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>                &#125;<br>                i--;<br>                n--;<br>            &#125;<br>        &#125;<br>        return n;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//快慢指针法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; n; fast ++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-keyword">val</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125; <br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//快慢指针</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Duplicates(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">nums</span>[<span class="hljs-params">fast</span>])</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>                dict.put(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零-1"><a href="#283-移动零-1" class="headerlink" title="283.移动零"></a>283.移动零</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//使用快慢指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> moveZeroes(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow ++] = nums[fast];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(; slow &lt; n; slow ++)&#123;<br>            nums[slow] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//使用快慢指针</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean backspace<span class="hljs-constructor">Compare(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span> s_arr = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br>        <span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span> t_arr = t.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><br>        <span class="hljs-keyword">if</span>(rebuild<span class="hljs-constructor">String(<span class="hljs-params">s_arr</span>)</span>.equals(rebuild<span class="hljs-constructor">String(<span class="hljs-params">t_arr</span>)</span>))&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//重建字符串函数</span><br>    String rebuild<span class="hljs-constructor">String(<span class="hljs-params">char</span>[] <span class="hljs-params">c</span>)</span>&#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; c.length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(c<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-character">&#x27;#&#x27;</span>)&#123;<br>                c<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = c<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(slow &gt; <span class="hljs-number">0</span>)&#123;<br>                    slow--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">c</span>)</span>.substring(<span class="hljs-number">0</span>,slow);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//使用前后双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">sortedSquares</span>(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> end = nums.length;<br>       <span class="hljs-type">int</span>[] new_nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[end];<br>       <span class="hljs-type">int</span> i = end - <span class="hljs-number">1</span>;<br>       end --;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            new_nums[i--] = nums[start] * nums[start] &gt; nums[end] * nums[end] ? nums[start]*nums[start++] : nums[end]*nums[end--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> new_nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-knowledge-blogs</title>
    <link href="/2023/05/23/my-knowledge-blogs/"/>
    <url>/2023/05/23/my-knowledge-blogs/</url>
    
    <content type="html"><![CDATA[<h1 id="my-knowledge-blogs"><a href="#my-knowledge-blogs" class="headerlink" title="my-knowledge-blogs"></a><strong>my-knowledge-blogs</strong></h1><h2 id="Repository-Introduction"><a href="#Repository-Introduction" class="headerlink" title="Repository Introduction"></a>Repository Introduction</h2><p>&#x1F60A;This repository retains relevant records of technology accumulation in computer vision and other related fields during my postgraduate stage, which are only used for learning purposes.</p><h2 id="Related-Links"><a href="#Related-Links" class="headerlink" title="Related Links"></a>Related Links</h2><p>&#x1F60A;Welcome to visit my Zhihu homepage, Likou homepage, and CSDN blog homepage to get the latest computer vision technology blogs related to defect detection&#x2F;diffusion model&#x2F;comparative learning and front-end&#x2F;back-end development related technology blogs.</p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999">My CSDN Blog Home Page</a><br>&#x1F449;<a href="https://www.zhihu.com/people/the-wang-15">Zhihu homepage</a><br>&#x1F449;<a href="https://leetcode.cn/u/wyypersist">LeetCode Home Page</a></p><h2 id="x1F4E3-New-Blogs-Update-x2757-20230828-Update-x2757-Recently-Posted-First-Show"><a href="#x1F4E3-New-Blogs-Update-x2757-20230828-Update-x2757-Recently-Posted-First-Show" class="headerlink" title="&#x1F4E3;New Blogs Update &#x2757; [20230828 Update] &#x2757; [Recently Posted First Show]"></a>&#x1F4E3;New Blogs Update &#x2757; [20230828 Update] &#x2757; [Recently Posted First Show]</h2><p><strong>Following articles are what I recently shared on my CSDN blog. If you are interested, you can take a look.</strong></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/132540512?spm=1001.2014.3001.5502">Transformer (Attention Is All You Need) 论文精读笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/132515119?spm=1001.2014.3001.5502">DEFORMABLE DETR: DEFORMABLE TRANSFORMERS FOR END-TO-END OBJECT DETECTION 论文精度笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/132449864">DETR论文精读笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130791744">使用MMdeploy编译得到dll动态链接库之后，使用C++文件调用dll动态链接库实现推理</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130771315">加载自己做的coco格式实例标注出现TypeError: Argument ‘bb‘ has incorrect type (expected numpy.ndarray, got list)报错解决</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130586873?spm=1001.2014.3001.5501">《SQUID: Deep Feature In-Painting for Unsupervised Anomaly Detection》论文阅读理解</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130661199?spm=1001.2014.3001.5501">机器学习中高维组合特征的处理方法+推荐系统使用矩阵分解为用户推荐的原理解析，《百面机器学习》学习笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130686221?spm=1001.2014.3001.5501">基于梯度提升决策树的组合特征方法，《百面机器学习》学习笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130660900?spm=1001.2014.3001.5501">机器学习中对类别型特征的编码方法，《百面机器学习》学习笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130660382?spm=1001.2014.3001.5501">机器学习任务中对数值类型做特征归一化的必要性，《百面机器学习》学习笔记</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130476261">《SimpleNet: A Simple Network for Image Anomaly Detection and Localization》论文阅读理解</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130307058?spm=1001.2014.3001.5501">使用MMDeploy（预编译包）转换MMxx(MMDeploy支持库均可)pth权重到onnx，并使用python SDK进行部署验证</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130308470?spm=1001.2014.3001.5501">使用MMDeploy（预编译包）转换MMxx(MMDeploy支持库均可)pth权重到onnx，并使用C++ SDK加载onnx得到dll动态链接库，实现在windows平台中调用（linux也适用）</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130312466?spm=1001.2014.3001.5501">图像融合方向：《Deep Image Blending》论文理解</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130372603?spm=1001.2014.3001.5501">图像融合方向：《GP-GAN: Towards realistic high-resolution image blending》论文理解</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130373860?spm=1001.2014.3001.5501">图像拼接《Leveraging Line-Point Consistence To Preserve Structures for Wide Parallax Image Stitching》论文理解</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130375844?spm=1001.2014.3001.5501">图像拼接方向：《Unsupervised Deep Image Stitching: Reconstructing Stitched Features to Images》论文阅读理解</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/130413951?spm=1001.2014.3001.5501">python中使用ctypes库调用使用MMDeploy C++ SDK编译得到的dll文件时，出现WinError126的解决方法</a></p><p>&#x1F449;<a href="https://blog.csdn.net/weixin_43749999/article/details/129915838?spm=1001.2014.3001.5501">《MedSegDiff Medical Image Segmentation with Diffusion Probabilistic Model》论文阅读理解</a></p><br><br><h3 id="Papers-and-related-links-added-from-2022-10-9-to-Now"><a href="#Papers-and-related-links-added-from-2022-10-9-to-Now" class="headerlink" title="Papers and related links added from 2022.10.9 to Now"></a>Papers and related links added from 2022.10.9 to Now</h3><p>&#x261D;&#x261D;&#x261D;Please see my latest technical blog update on the top&#x261D;&#x261D;&#x261D;</p><br><br><h2 id="Previously-read-articles-related-to-defect-detection"><a href="#Previously-read-articles-related-to-defect-detection" class="headerlink" title="Previously read articles related to defect detection"></a>Previously read articles related to defect detection</h2><p>&#x1F449;<strong>The future will follow the latest update format shown above</strong>&#x2757;&#x2757;&#x2757;</p><p>&#x1F449;<strong>Attention: Simply click on the paper title to get the pdf download link</strong>&#x2757;&#x2757;&#x2757;</p><h3 id="Papers-and-related-links-read-before-2022-10-9"><a href="#Papers-and-related-links-read-before-2022-10-9" class="headerlink" title="Papers and related links read before 2022.10.9"></a>Papers and related links read before 2022.10.9</h3><h3 id="基于深度学习的表面缺陷检测方法综述"><a href="#基于深度学习的表面缺陷检测方法综述" class="headerlink" title="基于深度学习的表面缺陷检测方法综述"></a><a href="http://www.aas.net.cn/cn/article/doi/10.16383/j.aas.c190811">基于深度学习的表面缺陷检测方法综述</a></h3><h4 id="Content-Summary"><a href="#Content-Summary" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>介绍了表面缺陷检测中不同场景下的成像方案，又从四个方向说明了表面缺陷检测的方法：基于全监督学习、半监督、其他；</li><li>在全监督学习方面，作者介绍了基于表征的学习和基于度量学习的方法；</li><li>在基于表征的学习方法中，文章从分类网络、检测网络、分割网络三个方面进行介绍（一阶段和二阶段网络：YOLO&#x2F;AlexNet&#x2F;SSD&#x2F;Faster<br>RCNN等）；</li><li>在基于度量学习的方法中，作者介绍了孪生网络的原理和应用案例；</li><li>在无监督方面，作者介绍了正常样本学习（其中包含有具体的GAN和Otsu方法对应的具体论文），其中又分为：基于图像空间的方法和基于特征空间的方法；</li><li>文中还介绍了半监督和弱监督方面的知识，但尚未总结概括；</li><li>在文章结束部分，作者还介绍了基于深度学习的缺陷检测方法和传统的基于原始图像的方法的对比以及未来缺陷检测领域可能发展的方向；</li></ul><h4 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>更换网络结构；</li><li>网络训练学习（引入类脑等知识指导网络训练）；</li><li>异域联邦学习（对于不同工业场景数据集尽心充分地利用问题）；</li></ul><h3 id="Autonomous-Structural-Visual-Inspection-Using-Region-Based-Deep-Learning-for-Detecting-Multiple-Damage-Types"><a href="#Autonomous-Structural-Visual-Inspection-Using-Region-Based-Deep-Learning-for-Detecting-Multiple-Damage-Types" class="headerlink" title="Autonomous Structural Visual Inspection Using Region-Based Deep Learning for Detecting Multiple Damage Types"></a><a href="https://onlinelibrary.wiley.com/doi/10.1111/mice.12334">Autonomous Structural Visual Inspection Using Region-Based Deep Learning for Detecting Multiple Damage Types</a></h3><h4 id="Content-Summary-1"><a href="#Content-Summary-1" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章使用改进后的Faster R-CNN网络对多种类型的结构损伤进行检测；</li><li>改进点：将作为RPN网络的ZF-net进行了修改，将其最后的max-pooling和FC层使用滑动卷积层CONV代替，然后接着设置了一个深度为256层的FC层，softmax层使用softmax层和回归层代替；</li><li>图像采集注意点：使用单反相机拍摄图片（500*375）、GeForce GTX 1080 GPU；</li><li>文中作者研究了9种不同比例的27种锚组合和6种不同锚尺寸的两种尺寸组合；</li><li>作者还增加了softmax分类概率为正类的阈值，将原始文献中的0.6增加为0.9，将帮助提高检测的精确度；</li><li>没有使用缩放；</li><li>同时作者还使用了Faster R-CNN在视频帧上进行测试，其中视频帧率为30.0，尺寸为1920*1080；</li></ul><h3 id="Visualizing-and-Understanding-Convolutional-Networks"><a href="#Visualizing-and-Understanding-Convolutional-Networks" class="headerlink" title="Visualizing and Understanding Convolutional Networks"></a><a href="https://arxiv.org/pdf/1311.2901.pdf">Visualizing and Understanding Convolutional Networks</a></h3><h4 id="Content-Summary-2"><a href="#Content-Summary-2" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章引入了一种新的可视化技术-反卷积，使用该技术可以详细看到卷积神经网络中特征层的功能和分类器的操作；</li><li>文中指出：更大训练数据集&#x2F;强大的GPU&#x2F;更好的模型正则化策略等促使了CNN技术的进步；</li><li>作者基于多层反卷积网络提出了可视化技术，将特征映射重新输入到原像素中；</li><li>作者还通过遮挡输入图像的部分从而判断模型对输入中的哪个部分比较灵敏；</li><li>文中使用的反卷积可视化技术可以对整个特征图自上而下的投影，解释了每个patch中的结构；</li><li>文中的一些具体点：在卷积网络中，max pooling层的操作是不可逆的，但是文中作者通过记录在一组开关变量中每个pooling区域的最大值的位置来获得一个近似的逆，在反卷积网络中，反池化操作使用这些开关将来自上一层的重建数据放置到合适的位置，同时保留激活的结构。</li><li>在校正部分：卷积神经网络使用relu非线性校正特征映射，从而确保特征映射总是正的。为了在每一层获得有效的特征重构(这也应该是正的)，作者通过relu非线性传递重构信号。</li><li>在过滤部分：卷积神经网络使用学习过的滤波器对前一层的特征映射进行卷积。反过来，反卷积网络使用相同滤波器的转置版本，但应用于校正后的地图，而不是下方图层的输出。实际上，这意味着垂直和水平地翻转每个过滤器；</li><li>训练细节：在ImageNet2012训练集上进行训练的（130万张图片，分布在1000多个不同的class）。每个图像经过预处理，尺寸为256<em>256，然后使用大小为224</em>224的10个不同的子作物（角度+中心，水平翻转获得），使用128个mini-batch的随机梯度下降来更新参数，从10^-2 learning rate开始，加上0.9的momentum，同时设置dropout用于fc层，概率为0.5，所有权重初始化为10^-2；偏差bias设置为0；</li><li>重点：对训练过程中第一层过滤器可视化显示，其中一些过滤器占主导地位，那么使用RMS将值超过10^-1的固定半径的卷积层中每个filter重新归一化；</li><li>训练过程中的特征演化：作者使用不同的样本，并在特定epoch的不同层次的特征图上进行可视化，得到结论：在底层的特征图中需要经过较多的epoch才可以看到收敛，但是对高层的特征，只需几个epoch就可以收敛；</li><li>特征变换：作者又测试了5张样本图像被使用了平移、旋转、缩放、对比模型的上下两层特征向量相对于未使用变换的变化差别，小的转换在模型的第一层有显著的效果，但在顶层特征层的影响较小，对于平移和缩放来说是准线性的。网络输出对平移和缩放是稳定的。一般来说，输出不是旋转不变的，除了旋转对称的物体(如娱乐中心)；</li><li>可视化之后对网络结构的选择：第一层滤波器是极高频和低频信息的混合，几乎不覆盖中频。此外，第2层可视化显示了由第1层卷积中使用的大跨度4引起的混叠效应。为了解决这些问题，作者(i)将第一层过滤器的尺寸从11x11减少到7x7， (ii)将卷积的范围从4步扩大到2步；</li><li>遮挡敏感性研究：作者为了进一步探究网络究竟是否识别出了物体的具体位置，还是仅仅使用了物体周围的特征作为可视化来源，采用遮挡一部分图像像素的方法，发现分类器的准确率显著下降并且在第5层中的激活强度也发生了一些变化。同时，作者还根据最顶层的特征图的可视化和图中的活动与遮挡位置的函数关系，发现当封堵器覆盖在可视化中出现的图像区域时，作者会看到特征图中活动的强烈下降。这表明可视化确实对应于刺激该特征映射的图像结构，因此验证了图4和图2中显示的其他可视化；</li><li>作者还进行了相关性分析：作者通过在图像中遮盖不同的部分，来判定不同图像中特定部位之间的关系；</li><li>文中通过修改模型的不同层次从而得到了模型的整体深度对于获得良好的性能非常重要，改变FC层对性能影响不是很大，但是增加中间CONV层的大小可以在性能上获得有用的增益；</li><li>特征分析：作者发现随着在更深层次的特征层上使用支持向量机等分类器进行预测，得到的准确率会逐渐增大，也就是说随着特征层次的加深，可以学习到更加强大的特征；</li></ul><h4 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用反卷积方法进行不同特征图的可视化，可以及时发现实验设置的某些参数的正确与否，及时调整训练配置；</li><li>使用遮挡不同图像的不同部位来判断模型对那些部分具有较强的敏感性；</li><li>遮盖图像不同部分，来判定不同图像中特定部委之间存在的特定关系；</li><li>通过在模型不同的层次上进行预测，从而判断模型的深度对图像预测性能的影响；</li></ul><h3 id="VERY-DEEP-CONVOLUTIONAL-NETWORKS-FOR-LARGE-SCALE-IMAGE-RECOGNITION"><a href="#VERY-DEEP-CONVOLUTIONAL-NETWORKS-FOR-LARGE-SCALE-IMAGE-RECOGNITION" class="headerlink" title="VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION"></a><a href="https://link.csdn.net/?target=https://arxiv.org/pdf/1409.1556.pdf">VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION</a></h3><h4 id="Content-Summary-3"><a href="#Content-Summary-3" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章主要研究了CNN的深度对网络识别图像的影响，并提出了VGG网络；</li><li>网络输入设置为234*224；</li><li>其中的一种网络架构设置：在其中一种网络架构中，作者使用了3x3的conv层，设置stride&#x3D;1，在每次conv之后，进行padding&#x3D;1的零填充，保持了featuremap的分辨率固定。使用5个max pooling进行空间池化操作，池化层跟在一些conv层后边，但不是所有的conv层后边都有池化层。Max pooling层选择2x2的窗口，stride&#x3D;2。</li><li>网络的整体结构：一系列的卷积层conv堆栈，然后紧跟着三个FC层，前两个FC层维度为4096，最后一层FC的维度为1000（对应的ImageNet数据集中1000个类），最后一层是一个softmax层（为了实现分类）；</li><li>作者使用了更小的conv层且使用了更深的深度，训练开始时初始化了网络的权重，使得网络的收敛速度更快；</li><li>训练配置：采用带动量的小批量梯度下降优化多项logistic回归目标进行，批量大小设置为batch_size&#x3D;256，动量设置为0.9，通过权重衰减（L2惩罚乘数设置为5*10^-4）并在前两个FC层之间添加了dropout层（概率设置为0.5），学习率初始化为10^-2；</li><li>作者表示文中提出的网络可以在更少的epoch后收敛；</li><li>对每个图像进行多次裁剪得到多个crops，然后对于每个crop，进行随机水平反转和随机RGB颜色变换；</li><li>在作者的实验中，评估了在尺度为256和384下的结果；在训练尺度为384的模型时，作者使用S&#x3D;256时的权重对模型进行了初始化，且设置learning_rate_init&#x3D;10^-3；</li><li>使用多尺度进行训练：每个训练图像从一定范围随机采样S，分别进行缩放，使用固定的S&#x3D;384进行预训练；</li><li>在网络中使用额外的非线性确实有帮助，但是使用具有非平凡接受域的CONV filters来捕获空间上下文也很重要；</li><li>作者又得到了结论：带有小过滤器的深网络的性能要高于带有大过滤器的浅网络；</li><li>对于固定尺度训练的模型，使用多尺度数据测试的结果也会表现的更好；</li><li>多个crop评估性能高于密集评估，但是两者是互相补充的，因为两者共同使用的时候，性能会更好于分别使用两者的情况；</li><li>使用网络融合将多个性能较好的模型的评估结果进行平均之后得到的结果更好；</li></ul><h4 id="Ideas-2"><a href="#Ideas-2" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>增加网络深度有时候可以实现更好的性能；</li><li>使用1*1 CONV层有时候可以提高网络的性能，这和在网络中添加额外的非线性相关；</li><li>可以对每个图像进行多次裁剪得到多个crops来扩充数据集，或者水平翻转和随机RGB颜色变换等；</li><li>多尺度训练可以提高模型的性能，同时在测试时，无论模型是使用多尺度训练还是单一固定尺度训练，都会使得测试性能增加；</li><li>使用多个网络预测结果的平均会使得结果更加准确；</li></ul><h3 id="An-End-to-End-Steel-Surface-Defect-Detection-Approach-via-Fusing-Multiple-Hierarchical-Features"><a href="#An-End-to-End-Steel-Surface-Defect-Detection-Approach-via-Fusing-Multiple-Hierarchical-Features" class="headerlink" title="An End-to-End Steel Surface Defect Detection Approach via Fusing Multiple Hierarchical Features"></a><a href="https://ieeexplore.ieee.org/document/8709818">An End-to-End Steel Surface Defect Detection Approach via Fusing Multiple Hierarchical Features</a></h3><h4 id="Content-Summary-4"><a href="#Content-Summary-4" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>本文中，作者通过使用ResNet34&#x2F;50作为骨干网络对于并结合MFN将不同等级的特征图进行融合，并使用RPN网络在融合后的完整特征图上进行预测，从而形成了本文中的DNN检测系统；</li><li>作者在NEU-DET数据集上进行了分类和检测任务的实验，并探究了MFN网络在区域建议数量不同时和使用的IoU交并比不同时的实验结果；</li><li>保持CONV层前后维度一致可以使用1*1CONV层；</li><li>提出了一个MFN网络，将baseline网络（这里是ResNet网络）中的不同层次的特征进行融合；</li><li>在融合不同层次的特征时，不使用相邻的两个层，因为相邻的层具有高度的局部相关性和覆盖范围；</li><li>作者在文中采用了组合ResNet每个Redisual残差块的最后一层特征进行融合；</li><li>作者提出的MFN网络可以修改1*1CONV层的数量来减少所需要的参数，可能会影响精度，但是可以在train_data不足的情况下防止过度拟合；</li><li>作者比较了不同proposals的数量下，使用MFN网络和使用其他网络的模型Recall，MFN可以帮助RPN从低级和中级特征中获得位置信息，使得RPN对严格的IoU阈值有更高的容忍度；</li><li>同时，作者比较了对于相同的proposals来说，使用MFN和传统的RPN等在不同的IoU阈值下的测试结果，得到了MFN只需要更少的proposals就可以得到类似的性能；</li><li>同时，作者为了测试融合哪几层特征会使得模型的性能更好，还测试了融合不同层次特征时模型的mAP（包含L2和不包含L2）；</li><li>使用前置1<em>1 CONV来增加维度，可以减少融合之后的特征的参数量，同时使用前置1</em>1 CONV可以保留更完整的信息；</li><li>DDN在ImageNet上进行了微调；</li></ul><h4 id="Ideas-3"><a href="#Ideas-3" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>如果需要进行特征融合，那么使用前置1*1 CONV层来统一维度比较好，可以减少特征的参数量；</li><li>特征融合时，不使用相邻的两个层；</li><li>可以修改1*1 CONV层的数量来减少模型的参数；</li></ul><h3 id="Automatic-surface-defect-detection-for-mobile-phone-screen-glass-based-on-machine-vision"><a href="#Automatic-surface-defect-detection-for-mobile-phone-screen-glass-based-on-machine-vision" class="headerlink" title="Automatic surface defect detection for mobile phone screen glass based on machine vision"></a><a href="http://pdf.xuebalib.com:1262/grvLJPB6UR2.pdf">Automatic surface defect detection for mobile phone screen glass based on machine vision</a></h3><h4 id="Content-Summary-5"><a href="#Content-Summary-5" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章主要贡献：文中提出了一个MPSG配准算法，并提出了一种基于轮廓的配准（CR）方法生成用于对齐MPSG图像的模板图像，且采用减法和投影相结合的方法对MPSG图像进行缺陷识别，消除了环境光照波动的影响，同时为了从含噪MPSG图像中分割出具有模糊灰色边界的缺陷，本文提出了一种改进的模糊c均值聚类算法（IFCM）；</li><li>分类缺陷检测（正常和异常的二元分类算法）、背景重建和移除、模板参考；</li><li>最初使用模板匹配检测的方法，是比较有效的方法，且运算速度较快，只涉及像素的算术运算；</li><li>模板匹配方法中存在的问题：图像失调、周围光照变化和模糊边界缺陷分割；</li><li>不使用对齐算法，在图像减法过程中会导致严重的错误；如果使用多个自由缺陷图像的平均值来创建模板，这些自由缺陷图像的错位会产生不准确的模板；</li><li>图像配准的方法：基于灰度的方法（速度慢且对光照变化非常敏感）和基于特征的方法（轮廓是用于对齐的常见特征之一）；GMM高斯混合模型可以较好地解决光照带来的变化；</li><li>使用灰度投影检测法，该方法与图像周围的光照水平无关；</li><li>文章通过将MPSG和模板对齐之后，再采用灰度投影的方法确定缺陷的存在与否；</li><li>提出的MPSG自动缺陷检测系统包括三个阶段：配准、缺陷检测和分割。在第一阶段，对齐多个无缺陷MPSG图像以生成模板；然后，将测试图像与模板对齐以进行缺陷检测。在第二阶段中，从测试图像中减去模板以产生残余图像。然后，使用残差图像的灰度投影来确定缺陷的存在或不存在。如果存在缺陷，将MPSG从制造过程中移除，并将相应的数据发送到下一阶段进行缺陷分割。在第三阶段，采用改进的FCM方法对缺陷进行精确分割；</li><li>阈值法是从图像背景中分割物体的常用技术；</li></ul><h4 id="Ideas-4"><a href="#Ideas-4" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>缺陷检测可以从模板匹配方法上入手，先将原始图像和模板进行配准，然后使用像素相减和基于灰度的投影方法来判断缺陷是否存在，而后使用改进的C均值聚类算法（IFCM）来分割出具有模糊灰色边界的缺陷；</li><li>使用Otsu方法可以将图像转换为二值图像（只有黑色或白色的图像，没有中间过滤值）;</li></ul><h3 id="An-improved-Otsu-method-using-the-weighted-object-variance-for-defect-detection"><a href="#An-improved-Otsu-method-using-the-weighted-object-variance-for-defect-detection" class="headerlink" title="An improved Otsu method using the weighted object variance for defect detection"></a><a href="https://www.sciencedirect.com/science/article/pii/S0169433215011319">An improved Otsu method using the weighted object variance for defect detection</a></h3><h4 id="Content-Summary-6"><a href="#Content-Summary-6" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一种目标加权目标方差WOV（等于缺陷发生累积概率的参数根据类间方差的对象方差进行加权。）；</li><li>当对象和图像背景具有相似的方差时，Otsu方法可以获得满意的分割效果，但是，如果对象和图像背景的大小相差很大，该方法将失败；</li><li>Otsu方法对于双峰分布直方图的图像阈值化提供了令人满意的结果，但对于单峰分布或接近单峰分布的图像直方图，Otsu方法失败；</li><li>一维Otsu方法：只考虑灰度信息而不考虑空间邻域信息的Otsu方法；</li><li>只有当目标和图像背景具有相似的方差时，Otsu方法才能获得满意的分割效果；</li><li>针对缺陷检测的自动阈值方法，如VE和NVE方法的研究主要集中在缺陷图像的阈值选择上。忽略了无缺陷图像的分割，导致大多数阈值方法都能正确地将缺陷从背景中分离出来，但却错误地将无缺陷图像归纳为检测图像。如果检测到无缺陷图像是有缺陷的图像，则会导致错误的检测。理想的视觉检测系统应具有高DR和低FAR缺陷；</li><li>使用自适应权重解决权重变化问题；</li></ul><h4 id="Ideas-5"><a href="#Ideas-5" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>对于图像分割问题来说，需要同时考虑有缺陷图像和无缺陷图像；</li><li>使用自适应权重来解决权重变化问题；</li></ul><h3 id="Multi-Scale-Pyramidal-Pooling-Network-for-Generic-Steel-Defect-Classification"><a href="#Multi-Scale-Pyramidal-Pooling-Network-for-Generic-Steel-Defect-Classification" class="headerlink" title="Multi-Scale Pyramidal Pooling Network for Generic Steel Defect Classification"></a><a href="https://ieeexplore.ieee.org/document/6706920">Multi-Scale Pyramidal Pooling Network for Generic Steel Defect Classification</a></h3><h4 id="Content-Summary-7"><a href="#Content-Summary-7" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一个多尺度金字塔池网络，提出了一个新的多尺度金字塔池层和一个新的编码层，且可以看作一个全监督的bag-of-features的扩展；</li><li>传统的CV系统都会采用BoF方法，对数据集中的图像提取一组特征然后使用基于词典的技术将这些特征编码为超完备的稀疏表示；</li><li>有监督的ML方法尝试将基于像素的表示直接映射到标签向量，从标签数据集中学习特征提取和编码；</li><li>特征编码最常用的方法为：选择一个基的矢量量化（VQ）、保持小子集的稀疏编码（SC）、局部约束线性编码（LLC）等；</li><li>使用具有最大池化层的金字塔池层，可以使得金字塔池化层操作更加有效，且可以加快网络的学习速度；</li></ul><h4 id="Ideas-6"><a href="#Ideas-6" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>金字塔多尺度池化层对不同尺度大小的特征都有比较好的提取能力；</li><li>对特征进行再编码，使用MLPDict字典进行编码，从而得到更有效的特征表示方式；</li></ul><h3 id="Convolutional-Networks-for-Voting-based-Anomaly-Classification-in-Metal-Surface-Inspection"><a href="#Convolutional-Networks-for-Voting-based-Anomaly-Classification-in-Metal-Surface-Inspection" class="headerlink" title="Convolutional Networks for Voting-based Anomaly Classification in Metal Surface Inspection"></a><a href="https://ieeexplore.ieee.org/document/7915495">Convolutional Networks for Voting-based Anomaly Classification in Metal Surface Inspection</a></h3><h4 id="Content-Summary-8"><a href="#Content-Summary-8" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一种多数投票机制的SVM分类器，该SVM分类器可以融合卷积神经网络的最后三层（不包含FC层和softmax分类层）特征；</li><li>典型的特征提取技术包括Gabor滤波器组、尺度不变特征变换（SIFT）和模糊特征；</li><li>使用卷积神经网络用作小型数据集强大的特征提取器；</li><li>使用了多个SVM分类器：SVM LC、SVM FFC、SVM SFC，分别从LC FFC SFC层训练深层次的特征并得到不同的分类结果，然后在预测之后，进行投票机制，最后票数多的SVM得到的类别即为最后的输出类别；</li><li>同时，最后的结果为三种不同SVM预测结果的大多数结果，条件优先级设置为大多数卷积神经网络中具有最佳平均性能的层，基于实验作者设置了FFC作为条件优先级；</li></ul><h4 id="Ideas-7"><a href="#Ideas-7" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用多数投票机制可以使得模型的性能更加泛化；</li></ul><h3 id="TDD-net-a-tiny-defect-detection-network-for-printed-circuit-boards"><a href="#TDD-net-a-tiny-defect-detection-network-for-printed-circuit-boards" class="headerlink" title="TDD-net: a tiny defect detection network for printed circuit boards"></a><a href="https://ietresearch.onlinelibrary.wiley.com/doi/10.1049/trit.2019.0019">TDD-net: a tiny defect detection network for printed circuit boards</a></h3><h4 id="Content-Summary-9"><a href="#Content-Summary-9" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一种微型的缺陷网络（TDD-NET），使用金字塔层和多尺度特征提取方法，使用k-means聚类的方法得到proposals相关的锚点，加强了CONV网络中不同层次之间的联系，使用硬示例挖掘技术更好地解决了小数据集的问题；</li><li>使用参考方法来检测PCB表面缺陷存在测试图像和检测模板需完全对齐的难点；</li><li>使用密度切片、区域分割和区域过滤等典型特征处理方法可以客服CONV网络在检测小缺陷方面的弱点；</li><li>在线示例挖掘（OHEM）可以用于训练任何基于区域的CONVNET，自动选择硬示例；</li><li>使用权重衰减0.0001和动量0.9，同时30k小批量的学习率为0.001；</li><li>设计了消融实验来验证设计；</li></ul><h4 id="Ideas-8"><a href="#Ideas-8" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>金字塔层和多尺度特征提取方法结合；</li><li>使用k-means聚类方法在train_set上进行聚类得到锚框的位置；</li><li>使用OHEM（在线硬示例挖掘方法）解决了小数据集的问题；</li></ul><h3 id="A-CNN-Based-Defect-Inspection-Method-for-Catenary-Split-Pins-in-High-Speed-Railway"><a href="#A-CNN-Based-Defect-Inspection-Method-for-Catenary-Split-Pins-in-High-Speed-Railway" class="headerlink" title="A CNN-Based Defect Inspection Method for Catenary Split Pins in High-Speed Railway"></a><a href="https://ieeexplore.ieee.org/document/8482333">A CNN-Based Defect Inspection Method for Catenary Split Pins in High-Speed Railway</a></h3><h4 id="Content-Summary-10"><a href="#Content-Summary-10" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一种改进的三级SPs缺陷检测系统（PVANET++）。使用该网络和霍夫变换以及Chan-Vese模型对Firs、sPsare进行定位，然后将三个准则应用于SPs缺陷检测；且使用了一种新的方法生成锚框作为合适的候选框，并结合具有多个层的特征构造有区别的超特征；</li><li>利用底层自然信息，在FEN中构建更具有鉴别能力的特征；</li><li>利用和CSD组件的规模和形状相关联的新锚定机制，在RPN中生成更高质量的proposals；</li><li>分为三个阶段baseline：第一阶段，第一个PVANET++应用于原始图像，定位组件位置，然后将位置裁剪之后送入到下一个PVANET++网络；第二个网络，用于预测裁剪关节组件图像中的pin_区域，而后继续被裁剪送入到下一个PVANET++中；</li><li>在第三个网络中，对于A类SPs，裁剪的pin_区域1、pin_区域2和pin_区域3被发送到第三个PV ANET++以定位特定零件的头部、车身和尾部。这些特定零件的定义将在第五节中介绍。由于销U区域3中的螺栓引起的堵塞问题，采用了两种不同的标准来分别检测A1型和A2型SPs。对于B型SPs，SPs的旋转会导致二维图像中复杂的SPs状态。使用HT&amp;CVM块定位裁剪的pin_区域4中的某些特定零件，然后应用第三个标准进行缺陷检测；</li></ul><h4 id="Ideas-9"><a href="#Ideas-9" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用多级网络实现大像素图像中的微小缺陷重复定位之后再进行检测；</li><li>使用和图像中特定结构相关联的锚点生成机制在RPN中生成高质量的区域建议；</li></ul><h3 id="A-Generic-Deep-Learning-Based-Approach-for-Automated-Surface-Inspection"><a href="#A-Generic-Deep-Learning-Based-Approach-for-Automated-Surface-Inspection" class="headerlink" title="A Generic Deep-Learning-Based Approach for Automated Surface Inspection"></a><a href="https://ieeexplore.ieee.org/document/7864335">A Generic Deep-Learning-Based Approach for Automated Surface Inspection</a></h3><h3 id="Content-Summary-11"><a href="#Content-Summary-11" class="headerlink" title="Content Summary"></a>Content Summary</h3><ul><li>文章提出了一种只需要少量数据进行训练的ASI检测方法，根据图像块的特征构建分类器，同时将训练好的分类器输入图像上获得像素级预测；</li><li>ASI技术的性能取决于对缺陷特征的建模程度；</li><li>本文提出了一种通用的ASI方法。该方法利用预训练的DL网络提取patch特征，根据patch特征生成缺陷热图，并对热图进行阈值分割，预测缺陷区域；</li><li>使用Otsu方法进行二值化操作；（Otsu方法同构最小化组内方差的最佳阈值来对图像进行二值化）</li><li>文中还使用Felzenswalb的分割来细化缺陷区域，该方法根据像素的颜色相似性对其进行分组；</li></ul><h4 id="Ideas-10"><a href="#Ideas-10" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>预训练DL提取特征，并分为多个patches；</li><li>使用patches生成缺陷热图（HM）；</li><li>对热图进行阈值分割，使用图分割的方法进一步细化缺陷区域；</li></ul><h3 id="A-High-Precision-Positioning-Approach-for-Catenary-Support-Components-With-Multiscale-Difference"><a href="#A-High-Precision-Positioning-Approach-for-Catenary-Support-Components-With-Multiscale-Difference" class="headerlink" title="A High-Precision Positioning Approach for Catenary Support Components With Multiscale Difference"></a><a href="https://ieeexplore.ieee.org/document/8824211">A High-Precision Positioning Approach for Catenary Support Components With Multiscale Difference</a></h3><h4 id="Content-Summary-12"><a href="#Content-Summary-12" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章将粗定位网络和精细定位网络进行结合，在粗定位网络中提出了一种基于先对定位信息的无监督剧烈算法对CSC图像进行分类，然后输入到CNN中进行特征提取，并生成带有标签的建议区域；</li><li>在精细定位网络中，使用改进的定位框架实现对CSCs的精确定位；</li><li>作为一种有效的深度学习框架，提出了CSCNET来提高多尺度差分CSCs同时定位的精度和速度。为了提高定位性能，该框架利用了CSCs的相对定位信息，增强了定位方法处理接触网图像多尺度差异的鲁棒性；</li><li>引入了CNN分类网络来生成带有类别标签的建议区域。它在克服尺度差异和不平衡数据集方面发挥着重要作用;</li><li>针对CSCNET中CNN分类网络的特殊分类要求，提出了一种基于CSCs定位信息和邻接表的无监督聚类算法；</li><li>在粗定位网络中对图像数据集的类别进行无监督聚类时，只有当图像中存在的CSC的位置批次最接近时，才可以将两幅图像划分为一个类别；</li><li>使用一种无监督聚类方法对train训练集进行聚类和预测框的定位，然后使用CNN分类网络对无监督聚类的第一阶段得到的大致分类数据集进行分类，然后根据分类数据集的结果和使用无监督聚类算法得到的图片数据集和预测框之间的映射信息得到输入图像集中的预测框位置；</li><li>在对CNN分类网络进行充分训练后，将调整大小的悬链线图像输入卷积网络，预测43个类的置信度。置信度最高的类标签被分配给输入图像。根据类与建议区域之间的映射关系，生成12个CSC类别的粗定位结果，称为带标签的建议区域；</li></ul><h4 id="Ideas-11"><a href="#Ideas-11" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用粗定位和精细定位网络进行连接的方法进行缺陷检测；</li><li>利用图像中的多个待检测缺陷的结构信息；</li><li>使用无监督聚类算法得到训练集中的图像数据集分类，然后对每个类别得到其中的缺陷检测框的位置作为映射，对测试集图片进行分类之后，取每张图片最大可能性的标签类别使用前边的映射来得到最终的粗略的标定框预测结果；</li></ul><h3 id="A-Machine-Vision-Apparatus-and-Method-for-Can-End-Inspection"><a href="#A-Machine-Vision-Apparatus-and-Method-for-Can-End-Inspection" class="headerlink" title="A_Machine_Vision_Apparatus_and_Method_for_Can-End_Inspection"></a><a href="https://ieeexplore.ieee.org/document/7476878">A_Machine_Vision_Apparatus_and_Method_for_Can-End_Inspection</a></h3><h4 id="Content-Summary-13"><a href="#Content-Summary-13" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文中提出了一种结合先验形状约束的熵率聚类算法来定位罐端面目标并将其划分为多个测量区域，然后，采用超像素分组和选择方案来查找平板中央面板内部的缺陷区域，对于其他三个环形测量区域，引入了一种多尺度脊线检测算法来沿其投影轮廓寻找缺陷和变形；</li><li>文中采用熵率聚类算法对图像进行分割，而后将图像分割为多个互不相交的区域；</li><li>作者在文中对罐的中央面板的缺陷检测采用了超像素分组和选择算法，首先使用熵率聚类算法在图像中得到多个超像素，然后在超像素的基础上进行分组，然后在每个分组中使用一个特定的指数函数来评估每个区域的灰度变化（首先使用带系数的二项式滤波器对于中央面板进行平滑处理），而后计算原始图像和平滑之间的差值，之后阈值来得到缺陷区域；</li><li>文中提出了一种多尺度脊检测算法，作者发现缺陷的共同特性为局部的最小值或最大值，其中的阈值的选择主要基于用户的先验统计分析；</li><li>卷曲宽度的测量对于罐端被冲压的缺陷非常重要，使用高斯核的二阶导数与投影轮廓进行直接卷积操作，然后将两个过零点之间的距离作为卷曲宽度，然后和阈值进行比较，如果卷曲宽度大于阈值，那么表示存在缺陷；</li><li>活动轮廓模型可以用于定位，是一种流行的边界提取算法；</li></ul><h4 id="Ideas-12"><a href="#Ideas-12" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>熵率聚类算法可以对图像任意K个超像素的划分；</li><li>使用超像素分组和选择算法实现缺陷区域的检测；</li><li>在计算原始图像和带有缺陷图像的差值之前，可以使用带有二项式的滤波器对图像进行平滑处理；</li></ul><h3 id="Automated-defect-analysis-in-electron-microscopic-images"><a href="#Automated-defect-analysis-in-electron-microscopic-images" class="headerlink" title="Automated defect analysis in electron microscopic images"></a><a href="https://www.nature.com/articles/s41524-018-0093-8.pdf">Automated defect analysis in electron microscopic images</a></h3><h4 id="Content-Summary-14"><a href="#Content-Summary-14" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文中使用了级联目标检测器，卷积神经网络和局部图像分析方法，使用级联目标检测器作为检测模块、使用CNN作为筛选模块、使用分水岭洪水算法寻找缺陷轮廓+使用区域属性分析得到轮廓的大小信息；</li><li>使用在增强的数据集中训练的级联目标检测器，构建了一个有环&#x2F;没有环的CNN训练集，进行训练之后的CNN对前一阶段得到的所有的bbox中是否包含有环进行分类筛选，从而进一步提高了模型的性能；</li></ul><h4 id="Ideas-13"><a href="#Ideas-13" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用CNN对BBOX进行分类也可以作为筛选目标检测器得到的结果中是否真正包含缺陷的工具；</li></ul><h3 id="Automatic-classification-of-defective-photovoltaic-module-cells-in-electroluminescence-images"><a href="#Automatic-classification-of-defective-photovoltaic-module-cells-in-electroluminescence-images" class="headerlink" title="Automatic classification of defective photovoltaic module cells in electroluminescence images"></a><a href="https://arxiv.org/abs/1807.02894v2">Automatic classification of defective photovoltaic module cells in electroluminescence images</a></h3><h4 id="Content-Summary-15"><a href="#Content-Summary-15" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章首先使用手工制作的特征和支持向量机对缺陷太阳能电池进行监督分类，然后又提出了一个使用CNN的分类框架，最后文章提供了一个数据集；</li><li>使用SVM的特征分类方法：从电池图像中提取局部描述符，然后从局部描述符中计算全局表示（编码），然后将全局描述符分为缺陷描述符和功能描述符；</li><li>使用Masking掩码技术，可以划分每个图像的前景和背景部分区别开来；</li><li>使用关键点检测和密集采样的方法对局部特征的位置进行采样，关键点检测器依赖于图像中的纹理，因此关键点的数量与高频元素的数量成比例，且关键点方法对图像的捕捉比例是不变的，无论图像是旋转还是分辨率变化；</li><li>编码的目的是从多个局部描述符中形成单个固定长度的全局描述符；</li><li>文章使用局部聚集描述符向量（VLAD）通过对训练集中的随机特征描述符子集进行K均值聚类而创建的，最后为了使得得到的VLAD向量具有鲁棒性，需要进行归一化操作；</li><li>为了增强VLAD对概率k均值聚类的潜在次优解的鲁棒性，我们使用不同的随机种子从不同的训练子集计算了五个VLAD表示。然后，通过PCA算法，对VLAD编码的串联，之后再进行归一化操作；</li><li>文章中为了分析CNN学习的特征，还采用了t-分布随机邻域嵌入的方法（实际使用的为该方法的变体：t-SNE的巴恩斯小屋变体），这是一种用于降低维度的流形学习技术；</li><li>文中为了突出图像中的类特定区分区域，使用了CAM类激活图，CAM可以补充全自动评估过程，并在视觉检查期间的复杂情况下提供决策支持；</li><li>文中提供的参考性结论：如果图像中关键点的空间分布相当稀疏，那么使用Masking相当有用；</li><li>根据图像单元中缺陷可能性的置信度按比例加权样本确实提高了学习分类器的泛化能力；</li></ul><h4 id="Ideas-14"><a href="#Ideas-14" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>对图像的采样可以考虑使用关键点或密集采样，当图像中关键点的空间分布相当稀疏，那么使用掩码技术相当有用；</li><li>可以使用t-SNE相关的方法来分析CNN对特征的学习能力；</li><li>对图像集中得到的特征描述符可以使用VLAD方法来得到全局可以用于分类的描述符；</li></ul><h3 id="Surface-Defects-Detection-Based-on-Adaptive-Multiscale-Image-Collection-and-Convolutional-Neural-Networks"><a href="#Surface-Defects-Detection-Based-on-Adaptive-Multiscale-Image-Collection-and-Convolutional-Neural-Networks" class="headerlink" title="Surface Defects Detection Based on Adaptive Multiscale Image Collection and Convolutional Neural Networks"></a><a href="https://ieeexplore.ieee.org/document/8661668">Surface Defects Detection Based on Adaptive Multiscale Image Collection and Convolutional Neural Networks</a></h3><h4 id="Content-Summary-16"><a href="#Content-Summary-16" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章首先使用ImageNet数据集对检测网络进行预训练，然后建立AMIC增强数据集，其中包括自适应多尺度图像提取和训练图像的轮廓局部提取；</li></ul><h4 id="Ideas-15"><a href="#Ideas-15" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用AMIC对数据集进行自动增强；</li></ul><h3 id="Concrete-bridge-surface-damage-detection-using-a-single-stage-detector"><a href="#Concrete-bridge-surface-damage-detection-using-a-single-stage-detector" class="headerlink" title="Concrete bridge surface damage detection using a single-stage detector"></a><a href="https://onlinelibrary.wiley.com/doi/abs/10.1111/mice.12500">Concrete bridge surface damage detection using a single-stage detector</a></h3><h4 id="Content-Summary-17"><a href="#Content-Summary-17" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章使用YOLO V3网络架构进行训练，并使用迁移学习的方法初始化了网络的权重，同时还引入了Batch Normalization和Focal loss损失函数；</li></ul><h4 id="Ideas-16"><a href="#Ideas-16" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用YOLO V3检测器对图像进行训练并结合BN和FL来使得模型达到更好的性能；</li></ul><h3 id="Surface-defect-classification-and-detection-on-extruded-aluminum-profiles-using-convolutional-neural-networks"><a href="#Surface-defect-classification-and-detection-on-extruded-aluminum-profiles-using-convolutional-neural-networks" class="headerlink" title="Surface defect classification and detection on extruded aluminum profiles using convolutional neural networks"></a><a href="https://link.springer.com/article/10.1007/s12289-019-01496-1">Surface defect classification and detection on extruded aluminum profiles using convolutional neural networks</a></h3><h4 id="Content-Summary-18"><a href="#Content-Summary-18" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>在图像数据集进行采集的时候就使用了多个条件：在高亮度和低亮度下，从不同方向，从近距离和远距离拍摄缺陷；</li><li>使用数据增强技术来使得模型的泛化能力更加强大；</li><li>对选择的原始网络模型的结构进行修改：对于VGG16网络，在其前两个conv层中使用stride&#x3D;2而不是1，以应对更大分辨率的图像；对于GoogleNet，将第一卷积层的步长从2调整为4，将第二卷积层的步长从1调整为2；对ResNet，在第一卷积层中应用4而不是2的步幅，在第一卷积块中应用2而不是1的步幅；</li></ul><h4 id="Ideas-17"><a href="#Ideas-17" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>在采集图像数据集时应该就考虑到模型的泛化能力问题；</li><li>使用数据增强技术来使得模型的泛化能力更加强大；</li></ul><h3 id="A-fast-and-robust-convolutional-neural-network-based-defect-detection-model-in-product-quality-control"><a href="#A-fast-and-robust-convolutional-neural-network-based-defect-detection-model-in-product-quality-control" class="headerlink" title="A fast and robust convolutional neural network-based defect detection model in product quality control"></a><a href="https://link.springer.com/article/10.1007/s00170-017-0882-0">A fast and robust convolutional neural network-based defect detection model in product quality control</a></h3><h4 id="Content-Summary-19"><a href="#Content-Summary-19" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文中提出了一种精心设计的联合检测CNN架构来实现缺陷检测，对于图像样本，首先根据背景纹理信息确定样本的类别，然后判断其是否包含缺陷区域；</li><li>在CNN中采用的池化层使用都是max pooling层，因为其对小失真就有鲁棒性；</li></ul><h4 id="Ideas-18"><a href="#Ideas-18" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用联合CNN架构，先对图像进行类别的确定，然后再使用CNN判断每个图像中是否包含缺陷区域；</li><li>在CNN中采用的池化层使用都是max pooling层，因为其对小失真就有鲁棒性；</li></ul><h3 id="Tire-Defect-Detection-Using-Fully-Convolutional-Network"><a href="#Tire-Defect-Detection-Using-Fully-Convolutional-Network" class="headerlink" title="Tire Defect Detection Using Fully Convolutional Network"></a><a href="https://ieeexplore.ieee.org/document/8678643">Tire Defect Detection Using Fully Convolutional Network</a></h3><h4 id="Content-Summary-20"><a href="#Content-Summary-20" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文中提出了一个具有两个过程的缺陷检测框架，对轮胎的侧面和正面进行了缺陷检测，通过将VGG16网络的三个pooling层进行融合得到了最佳的性能；</li><li>详细来说：在第一阶段，使用VGG16网络进行特征提取，在该过程中将全连接-FC层改为了卷积层CONV，从而使得得到的特征输出具有足够的空间信息。在第二阶段，通过添加采样层，使用双线性插值的方法在第一阶段产生的特征向量基础上生成了与初始图像相同大小的特征层，并进行融合。之后在融合的特征上使用softmax函数预测类别分数；</li><li>文章提出了将FC层替换为CONV层的思想，使用全卷积神经网络进行缺陷检测pipeline；</li><li>将特征进行上采样之后融合；</li><li>通过将FC层替换为CONV层来保留特征图中相对应的空间位置信息；</li><li>使用双线性插值的方法来使得特征图的尺寸达到一样，然后便于特征图之间的融合；</li></ul><h4 id="Ideas-19"><a href="#Ideas-19" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>通过将FC层替换为CONV层，来得到FCN全卷积神经网络且保持有较多的空间位置信息；</li><li>可以使用双线性插值的方法来上采样；</li></ul><h3 id="Automatic-pixel-level-multiple-damage-detection-of-concrete-structure-using-fully-convolutional-network-DOI：10-1111-mice-12433"><a href="#Automatic-pixel-level-multiple-damage-detection-of-concrete-structure-using-fully-convolutional-network-DOI：10-1111-mice-12433" class="headerlink" title="Automatic pixel-level multiple damage detection of concrete structure using fully convolutional network(DOI：10.1111&#x2F;mice.12433)"></a><a href="#">Automatic pixel-level multiple damage detection of concrete structure using fully convolutional network(DOI：10.1111&#x2F;mice.12433)</a></h3><h4 id="Content-Summary-21"><a href="#Content-Summary-21" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文中使用FCN网络检测图像中的缺陷，同时提供了像素级的缺陷检测，使用迁移学习进行权重的初始化；</li><li>作者通过微调DenseNet-121构建了FCN架构；</li><li>为了获得更好的反卷积性能，将所有平均池化层改为了最大池化层，并将第14层中的全局平均池也替换为核大小为2×2、步长为2的最大池层，DenseNet-121的最终分类器层被丢弃，完全连接层被转换为卷积层，然后是丢失率为0.5的Dropout层，附加具有1×1内核和五个输出通道（第18、21、24、27和30层）的卷积，以预测每个先前输出位置处每个类别（裂纹、剥落、风化、孔洞和背景）的分数，然后是反卷积层，以将先前输出增加采样到像素密集输出。FCN融合了来自DenseNet-121最后一层、所有池层和第一卷积层的预测。在每个反卷积层中，通过实现步长为2的上采样，先前输出的大小增加了一倍。最后，FCN的输出大小与输入大小相同；</li></ul><h4 id="Ideas-20"><a href="#Ideas-20" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用最大池化层替换原来FCN网络中存在的平均池化层可以实现更好的反卷积性能；</li><li>使用反卷积操作可以实现输入和输出保持相同的大小，且反卷积输出大小和stride有关；</li></ul><h3 id="Automatic-Metallic-Surface-Defect-Detection-and-Recognition-with-Convolutional-Neural-Networks"><a href="#Automatic-Metallic-Surface-Defect-Detection-and-Recognition-with-Convolutional-Neural-Networks" class="headerlink" title="Automatic Metallic Surface Defect Detection and Recognition with Convolutional Neural Networks"></a><a href="https://www.mdpi.com/2076-3417/8/9/1575">Automatic Metallic Surface Defect Detection and Recognition with Convolutional Neural Networks</a></h3><h4 id="Content-Summary-22"><a href="#Content-Summary-22" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一种新的CASAE网络来处理金属表面的缺陷；</li><li>首先文章对原始的金属表面图像进行像素级的预测，然后针对预测像素（背景&#x2F;缺陷）进行裁剪，然后将裁剪得到的crops区域进行灰度化处理，保证了缺陷检测的精度，接着调整处理后的图像集到统一大小，而后将图像集输入到CNN分类网络中实现分类（CNN中使用了ATRUS卷积，有效避免了CNN的感受野过小而导致的对原始的图像中尺度较大的目标缺陷检测不到的问题）；</li><li>AE网络广泛应用于信息编码和重建，通常AE网络包含编码器网络和解码器网络，编码器网络是一个转换单元，将输入的图像转换为多维特征图像，用于特征提取和表示；</li><li>解码器网络通过合并来自所有中间层中学习的特征映射的上下文信息来微调像素级标签，同时解码器网络可以使用上采样操作将最终输出恢复为输入图像相同的大小；</li><li>作者为了排除编码器网络受图像中不同缺陷之间的不同模糊颜色影响，使用了归一化操作将图像转换为灰度图像；</li><li>文章中将上采样操作的结果连接到编码器部分的相应特征映射，以获得最终的特征映射，在最后一层作者将具有softmax层的1x1卷积连接到AE网络，以将输出转换为特征图，最终的预测掩码是缺陷概率图，该图最终又被调整为和输入图像相同的大小；</li><li>作者使用Atrus卷积以用于增加网络的接受域，来检测较大尺度的缺陷；</li><li>阿托斯卷积将卷积中求和的像素隔开，但求和像素与常规卷积相同。空白中萎缩卷积的权重为零，不参与卷积运算。因此，它们的有效感受野是7×7。AE网络编码器部分中的规则卷积被带填充1和步长1的阿托斯卷积取代；</li><li>阈值模块的设计主要是为了进一步细化预测掩码的结果，并对概率图应用逐像素的阈值操作；</li><li>文章中作者在完成了对所有可能的缺陷进行分割之后，又采用blob分析的方法对缺陷轮廓进行更加精确的分割，然后根据图像中的缺陷轮廓提取了最小封闭矩形区域（MER）；</li><li>然后作者采用放射变换将MER转换为正MER，且将正MER区域设置为RoI区域；</li></ul><h4 id="Ideas-21"><a href="#Ideas-21" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>首先使用分割网络得到缺陷的像素级分割结果，然后将得到的RoI区域输入到分类网络中进行缺陷的分类；</li><li>AE编码器和解码器网络的应用；</li><li>使用Atrus卷积可以增加网络的接受域，来检测图像中存在的较大尺度的缺陷；</li><li>可以使用blob分析对缺陷的轮廓进行更加精确的分割；</li><li>使用放射变换可以调整最后RoI区域的映射方向；</li></ul><h3 id="Fully-Convolutional-Networks-for-Surface-Defect-Inspection-in-IndustrialEnvironment"><a href="#Fully-Convolutional-Networks-for-Surface-Defect-Inspection-in-IndustrialEnvironment" class="headerlink" title="Fully Convolutional Networks for Surface Defect Inspection in IndustrialEnvironment"></a><a href="https://www.researchgate.net/publication/320304926_Fully_Convolutional_Networks_for_Surface_Defect_Inspection_in_Industrial_Environment">Fully Convolutional Networks for Surface Defect Inspection in IndustrialEnvironment</a></h3><h4 id="Content-Summary-23"><a href="#Content-Summary-23" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>作者将ZFNet网络最后的FC层修改为CONV卷积层，并使用修改后的网络对缺陷进行像素级的划分，然后对第一阶段得到的RoI区域进行采样得到多个patches作为训练样本；之后，作者使用跨层融合的特征进行检测，并分别计算了不同层特征的得分map，之后对同一个特征层的得分map进行评测，使用投票策略进行决策得到最后的类别；然后对来自两个不同特征层的两个得分map也进行了投票决定最终该patch块的类别分数；</li><li>文中将第一个缺陷分割阶段中缺陷区域占总面积n%以上的patches作为下一个阶段的训练样本；</li></ul><h4 id="Ideas-22"><a href="#Ideas-22" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>将第一个阶段得到的粗略的缺陷分割区域中间缺陷面积占比大于阈值的部分作为patches提供给第二阶段的FCN分割网络中，且在第二阶段的FCN网络中使用了特征层融合的技术；</li></ul><h3 id="A-Fast-Detection-Method-via-Region-Based-Fully-Convolutional-Neural-Networks-for-Shield-Tunnel-Lining-Defects"><a href="#A-Fast-Detection-Method-via-Region-Based-Fully-Convolutional-Neural-Networks-for-Shield-Tunnel-Lining-Defects" class="headerlink" title="A Fast Detection Method via Region-Based Fully Convolutional Neural Networks for Shield Tunnel Lining Defects"></a><a href="https://dl.acm.org/doi/10.1111/mice.12367">A Fast Detection Method via Region-Based Fully Convolutional Neural Networks for Shield Tunnel Lining Defects</a></h3><h4 id="Content-Summary-24"><a href="#Content-Summary-24" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章使用FCN分割网络对原始的缺陷图像进行分割，然后在得到的feature map上使用RPN网络得到的对应的RoI区域建议框，然后在特征图上使用卷积核进行操作得到多个对应的特征图，而后对每个特征图将得到的RoI区域映射其中；</li><li>之后，使用RoI池化层将每个RoI区域通过大小为w&#x2F;k<em>h&#x2F;k的规则网络划分为k</em>k个box；</li></ul><h4 id="Ideas-23"><a href="#Ideas-23" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>使用FCN网络得到的缺陷分割特征Map之后使用位置敏感的RoI方法来得到的区域建议框，然后进行softmax和bounding box regression操作；</li></ul><h3 id="Deep-Learning-Based-Intelligent-Defect-Detection-of-Cutting-Wheels-with-Industrial-Images-in-Manufacturing"><a href="#Deep-Learning-Based-Intelligent-Defect-Detection-of-Cutting-Wheels-with-Industrial-Images-in-Manufacturing" class="headerlink" title="Deep Learning-Based Intelligent Defect Detection of Cutting Wheels with Industrial Images in Manufacturing"></a><a href="https://www.sciencedirect.com/science/article/pii/S2351978920315808">Deep Learning-Based Intelligent Defect Detection of Cutting Wheels with Industrial Images in Manufacturing</a></h3><h4 id="Content-Summary-ellipsis"><a href="#Content-Summary-ellipsis" class="headerlink" title="Content Summary(ellipsis)"></a>Content Summary(ellipsis)</h4><h4 id="Ideas-ellipsis"><a href="#Ideas-ellipsis" class="headerlink" title="Ideas(ellipsis)"></a>Ideas(ellipsis)</h4><h3 id="Segmentation-Based-Deep-Learning-Approach-for-Surface-Defect-Detection"><a href="#Segmentation-Based-Deep-Learning-Approach-for-Surface-Defect-Detection" class="headerlink" title="Segmentation-Based Deep-Learning Approach for Surface-Defect Detection"></a><a href="https://arxiv.org/abs/1903.08536">Segmentation-Based Deep-Learning Approach for Surface-Defect Detection</a></h3><h4 id="Content-Summary-25"><a href="#Content-Summary-25" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章提出了一个基于分割的两阶段的缺陷检测方法，第一阶段包括像素级标签上进行训练的分割网络，第二个阶段包括在分割网络上构建的附加决策网络，来预测整个图像中是否存在异常；</li><li>使用Max pooling层进行下采样可以保证较小的特征在网络的前向传播过程中保留下来；</li><li>决策网络实际上就是利用第一阶段产生的feature map进行二值分类；</li><li>训练细节：首先先训练FCN分割网络，然后冻结FCN网络中的权重来训练决策网络；</li></ul><h4 id="Ideas-24"><a href="#Ideas-24" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>仅使用Max pooling层进行下采样可以保证较小的特征在网络的前向传播过程中保留下来；</li><li>使用冻结训练来处理训练两个相互连接的网络但是Loss不同的问题；</li></ul><h3 id="Detection-of-Rail-Surface-Defects-Based-on-CNN-Image-Recognition-and-Classification"><a href="#Detection-of-Rail-Surface-Defects-Based-on-CNN-Image-Recognition-and-Classification" class="headerlink" title="Detection of Rail Surface Defects Based on CNN Image Recognition and Classification"></a><a href="https://ieeexplore.ieee.org/document/8323642">Detection of Rail Surface Defects Based on CNN Image Recognition and Classification</a></h3><h4 id="Content-Summary-26"><a href="#Content-Summary-26" class="headerlink" title="Content Summary"></a>Content Summary</h4><ul><li>文章中作者首先将图像进行预处理将其转换为灰色二值图像，然后使用Canny边缘检测器获得边缘点并保存边缘点列，然后使用图像中轨道的比率d&#x2F;I（其中d表示轨道的宽度，I表示灰度图像的宽度），通过使用上述的比率来进一步删除保存的边缘点中的假边缘点，然后，对边缘点再次进行粗略和精细去除假边缘点，然后使用线性拟合的方法对上述过程中去除的真的边缘点进行拟合恢复；</li><li>第二阶段中，作者使用InceptionV3网络对第一阶段中得到的图像进行分类，同时在分类的时候使用一种新的Loss函数，向交叉熵中添加了F分数公式，实现了模型的精确度和召回率的平衡；</li><li>文章中说明利用轨道本身的几何特征；</li><li>文章中使用加权平均方法将原始的彩色图像转换为灰度图像，并使用自适应中值滤波，其可以根据噪声点调整滤波窗口的大小以减少噪声；</li><li>作者使用提出的约束条件来使得xi自适应地缩小动态范围（其中，xi为Canny边缘检测器获得的一行中每两个相邻边缘点之间的列差）；</li><li>实现迁移学习的两种方法：当目标域和源域之间的差异较小时，映射相应的数学关系以扩展目标域中的数据量+当目标域和源域之间存在较大差异时，转移学习建立在卷积神经网络层上，并完成特征的迁移；</li><li>作者为了检测定位算法的性能，使用cropped图像和原始的图像分别输入到CNN中来进行分类，从而来对比定位处理算法的性能；</li></ul><h4 id="Ideas-25"><a href="#Ideas-25" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>向交叉熵Loss中中添加了F分数公式，实现了模型的精确度和召回率的平衡；</li><li>需要注意利用图像中不同的组织结构之间的关联关系，从而得到更加明显的特征；</li><li>可以使用裁剪图像生成多个cropped块来实现对图像中缺陷的定位和检测（有利于大分辨率图像中的小尺度目标的检测）；</li></ul>]]></content>
    
    
    <categories>
      
      <category>my-knowledge-blogs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Computer Vision</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>About ME</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p><strong>Yangyang Wang</strong></p><p><em><strong>2000-02 | 男 | 汉族 | 中共党员</strong></em><br>2000-02 | Male | Han Nationality | Full member of the CPC</p><p><strong>我的GitHub主页（我的开源项目）：<a href="https://github.com/TheWangYang">https://github.com/TheWangYang</a></strong><br>My GitHub HomePage : <a href="https://github.com/TheWangYang">https://github.com/TheWangYang</a></p><p><strong>我的CSDN主页（记录技术博客等）：<a href="https://blog.csdn.net/weixin_43749999">https://blog.csdn.net/weixin_43749999</a></strong><br>My Personal Blog(CSDN) Address : <a href="https://blog.csdn.net/weixin_43749999">https://blog.csdn.net/weixin_43749999</a></p><p><strong>我的Leetcode主页（我的刷题记录）：<a href="https://leetcode-cn.com/u/wyypersist">https://leetcode-cn.com/u/wyypersist</a></strong><br>My Leetcode HomePage ： <a href="https://leetcode-cn.com/u/wyypersist">https://leetcode-cn.com/u/wyypersist</a></p><h2 id="教育经历-Education"><a href="#教育经历-Education" class="headerlink" title="教育经历(Education)"></a>教育经历(Education)</h2><p><strong>&gt;硕士在读，西安交通大学（985&#x2F;211&#x2F;双一流），人工智能与机器人研究所（人工智能学院），电子信息（人工智能）专业，2022年9月-2025年6月</strong><br>Master Degree, Xi’an Jiaotong University, Institute of Artificial Intelligence and Robotics(IAIR), Electronic Information (Artificial Intelligence), September 2022 - June 2025</p><p><em>截止本页更新时，硕士阶段GPA排名及相关成绩情况学院还未公布</em><br><em>coming soon …</em></p><p><strong>&gt;学士学位，郑州大学（211&#x2F;双一流），网络空间安全学院，软件工程专业，2018年9月-2022年6月</strong><br>Bachelor Degree, Zhengzhou University, School of Cyberspace Security, Software Engineering, September 2018 - June 2022</p><p><strong>本科全阶段成绩GPA排名：14&#x2F;184（专业前7.6%）</strong><br>GPA of all undergraduate stages: 3.44 &#x2F; 4.00 (14&#x2F;184, top 7.6%)</p><p><strong>本科全阶段综合排名（包含竞赛&#x2F;专利&#x2F;软著等加分项）：9&#x2F;184（专业前4.89%）</strong><br>Comprehensive ranking of all undergraduate stages (including bonus points for competitions&#x2F;patents&#x2F;software, etc.): (9&#x2F;184, top 4.89%)</p><p><strong>保研至西安交通大学</strong><br>Entered Xi’an Jiaotong University through recommendation interview</p><h2 id="研究兴趣（Research-Interest）"><a href="#研究兴趣（Research-Interest）" class="headerlink" title="研究兴趣（Research Interest）"></a>研究兴趣（Research Interest）</h2><p><em><strong>计算机视觉</strong></em><br>Computer Vision</p><ul><li><strong>图片拼接&#x2F;融合（硕士前期阶段做过探索）</strong>, Image splicing&#x2F;fusion (explored in the early stage of master’s degree)</li><li><strong>工业领域缺陷检测（硕士阶段重点研究）</strong>, Defect detection in the industrial field (key research at the master’s level)</li><li><strong>神经网络场-NeRF（参加竞赛时做过一段时间探索，竞赛名次全球top13）</strong>, Neural Network Field-NeRF (I did some exploration for a while when I participated in the competition, and the competition ranked top 13 in the world)</li><li>…</li></ul><p><strong>机器学习大数据处理分析</strong><br>Machine Learning</p><h2 id="实习经历（Intern-Experience）"><a href="#实习经历（Intern-Experience）" class="headerlink" title="实习经历（Intern Experience）"></a>实习经历（Intern Experience）</h2><p><strong>&gt;计算机视觉算法工程师（实习），<a href="http://www.ukdq.com.cn/">南京悠阔电气有限公司</a>，2022年3月-2022年6月</strong><br>Computer Vision Algorithm Engineer(intern), <a href="http://www.ukdq.com.cn/">Nanjing Youkuo Electric Technology Co., Ltd.</a>, March 2022 - June 2022</p><ul><li><strong>与组内成员合作，对采集到的变压器表面部位图片进行数据标注、模型训练、获取onnx权重模型或tensorRT模型，并使用C++&#x2F;Python编写部署推理API。</strong> Cooperate with members of the group to annotate the collected images of the transformer surface, perform model training, obtain the onnx weight model or tensorRT model, and use C++&#x2F;Python to write and deploy the inference API.</li><li><strong>作为负责人，将部署在NVIDIA显卡上的算法移植到了寒武纪MLU卡上。</strong> As the person in charge, the algorithm deployed on the NVIDIA graphics card was ported to the Cambrian MLU card.</li><li><strong>主要使用寒武纪官方提供的docker镜像来加载部署验证环境。 首先对模型的pth权重进行量化，然后保存为.cambricon模型（Cambrian提供的离线格式模型）。 然后，使用寒武纪CNRT运行时库部署并加载离线模型，获取.so动态链接库，由业务端python脚本调用，完成批量图像推理。</strong> Mainly use the official docker image provided by Cambrian to load the deployment verification environment. First, quantize the pth weight, and then save it as a .cambricon model (offline model provided by Cambrian). Then, use the Cambrian CNRT runtime library to deploy and load the offline model to obtain the .so dynamic link library, which is called by the business-side python script to complete batch image reasoning.</li></ul><p><strong>&gt;coming soon…</strong></p><h2 id="项目经历（Project-Experience）"><a href="#项目经历（Project-Experience）" class="headerlink" title="项目经历（Project Experience）"></a>项目经历（Project Experience）</h2><h4 id="硕士阶段（截止目前）Master-Period-until-now"><a href="#硕士阶段（截止目前）Master-Period-until-now" class="headerlink" title="硕士阶段（截止目前）Master Period(until now)"></a>硕士阶段（截止目前）Master Period(until now)</h4><p><strong>&gt;缺陷检测算法软硬协同架构设计与系统集成-中国科技部-科技创新2030—“新一代人工智能”重大项目子课题 | 2021年10月-2023年10月</strong><br>Defect detection algorithm software and hardware collaborative architecture design and system integration-China Ministry of Science and Technology-Technological Innovation 2030-“New Generation Artificial Intelligence” major project sub-topic | October 2021-October 2023</p><ul><li><strong>项目简介：作为项目组的核心成员，主要负责支持成像与感知推理的检测、学习与决策系统设计与搭建、研究基于少样本学习的检测算法。前期工作主要是在自建数据集上使用较新的目标检测算法来验证和演示检测任务。我们提出了结合空间注意力机制的改进FCOS算法。目前工作主要集中在工业缺陷检测领域中利用异常样本较少和正常样本较多的无监督或半监督算法的研究（few-shot&#x2F;zero-shot）。</strong>, Project Introduction: As a core member of the project team, he is mainly responsible for supporting the detection of imaging and perceptual reasoning, the design and construction of learning and decision-making systems, and the research of detection algorithms based on few-shot learning. The preliminary work is mainly to use newer target detection algorithms on self-built data sets to verify and demonstrate detection tasks. We propose an improved FCOS algorithm combined with a spatial attention mechanism. Current work is mainly focused on the research of unsupervised or semi-supervised algorithms (few-shot&#x2F;zero-shot) that utilize fewer abnormal samples and more normal samples in the field of industrial defect detection.</li><li><strong>项目取得成果（Project Achieved Results）</strong></li><li><em><strong>IEEE Transactions on Instrumentation and Measurement(TIM, 二作&#x2F;second author, JCR Q1&#x2F;SCI Area 2) (在审, in process)</strong></em></li><li><strong>发明专利一项（二作，不含导师），“一种工业缺陷检测优化方法、系统、装置、设备及存储介质”</strong>, One invention patent (two works, excluding mentor), “an industrial defect detection optimization method, system, device, equipment and storage medium”</li><li><em><strong>more coming soon…</strong></em></li></ul><h4 id="本科阶段-Bachelor-Period"><a href="#本科阶段-Bachelor-Period" class="headerlink" title="本科阶段 Bachelor Period"></a>本科阶段 Bachelor Period</h4><p><strong>&gt;基于机器学习的智能医疗柜 | 2021年3月-2021年5月</strong>, Intelligent Medical Cabinet Based on Machine Learning | March 2021-May 2021</p><ul><li><strong>项目简介：作为负责人，我组织团队成员开发了“基于机器学习的智能医疗柜”深度学习项目，我主要负责Web端、APP端和后端算法模块的开发。在查阅了相关文献并结合自身能力后，我决定将算法分析分为：收集数据预处理、老人健康指标、大量数据输入分类器、获得结果并可视化。</strong>, As the person in charge, I organized team members to develop the “Smart Medical Cabinet Based on Machine Learning” deep learning project. I was mainly responsible for the development of the Web, APP and back-end algorithm modules. After reviewing relevant literature and combining my own abilities, I decided to divide the algorithm analysis into: collecting data preprocessing, elderly health indicators, inputting large amounts of data into the classifier, obtaining results and visualizing them.</li><li><strong>项目取得成果（Project Achieved Results）</strong></li><li><strong>该项目荣获2021年中国大学生计算机设计大赛河南省级赛三等奖</strong>, This project won the 2021 Chinese College Student Computer Design Competition Henan Provincial Third Prize.</li></ul><p><strong>&gt;SmartGloves智能数据手套 | 2020年5月-2020年9月</strong>, SmartGloves Intelligent Data Gloves | May 2020-September 2020</p><ul><li><strong>项目介绍：我作为团队核心成员完整参与了“SmartGloves智能数据手套”项目的研发过程，负责使用机器学习技术分析患者康复数据。该项目采用镜像疗法帮助患者进行手部康复。我将数据分析过程分为：收集数据、数据预处理、患者手指曲率回归预测、患者康复程度人工智能评估等步骤。</strong>, As a core member of the team, I fully participated in the research and development process of the “SmartGloves Intelligent Data Gloves” project, responsible for using machine learning technology to analyze patient rehabilitation data. This program uses mirror therapy to help patients with hand rehabilitation. I divide the data analysis process into the following steps: data collection, data preprocessing, patient finger curvature regression prediction, and artificial intelligence assessment of patient recovery.</li><li><strong>项目取得成果（Project Achieved Results）</strong></li><li><strong>该项目荣获第十四届ICAN国际创新创业大赛三等奖</strong>, This project won the third prize of the 14th ICAN International Innovation Entrepreneurship Competition.</li></ul><h2 id="荣誉和奖励（Honors-and-Awards）"><a href="#荣誉和奖励（Honors-and-Awards）" class="headerlink" title="荣誉和奖励（Honors and Awards）"></a>荣誉和奖励（Honors and Awards）</h2><h4 id="硕士阶段（截止目前）Master-Period-until-now-1"><a href="#硕士阶段（截止目前）Master-Period-until-now-1" class="headerlink" title="硕士阶段（截止目前）Master Period(until now)"></a>硕士阶段（截止目前）Master Period(until now)</h4><ul><li><p><strong>2023年全球人工智能技术创新大赛 GigaRendering 基于千兆像素稀疏图像的全新视角渲染算法II赛道 | 全球第13名 | 2023年6月</strong>, 2023 Global Artificial Intelligence Technology Innovation Contest-GigaRendering A New Perspective Rendering Algorithm Based on Gigapixel Sparse Images II Track | TOP20 | 2023.6</p></li><li><p><strong>2023年第十三届中兴捧月全球精英算法挑战赛-图像处理赛道 | 区域优胜奖（超分辨率方向赛题，来自世界各地的近1200名选手参加了本次比赛的图像处理子赛道，其中前60名有机会进入复赛） | 2023年5月</strong>, The 13th ZTE Pengyue Global Elite Challenge in 2023 - Image Processing Track | Regional Excellence Award(Super-Resolution direction competition questions, Nearly 1,200 people from all over the world participated in the image processing sub-track of this competition, and the top 60 of them have the opportunity to win the regional award) | 2023.5</p></li><li><p><strong>2023年“华为杯”第五届中国研究生人工智能创新大赛全国总决赛 | 国家级三等奖（前30%队伍获一、二、三等奖） | 2023年8月</strong>, 2023 “Huawei Cup” National Finals of the 5th China Postgraduate Artificial Intelligence Innovation Competition | Third Prize (30% chance of winning) | 2023.8</p></li><li><p><strong>2023年华为嵌入式软件大赛（实物组）西北赛区 | 第36名 | 2023年6月</strong>, 2023 Huawei Embedded Software Contest (Physical Group) Northwest Division | TOP36 | 2023.6</p></li><li><p><strong>2023年中国研究生电子设计大赛西北赛区技术赛道 | 西北赛区二等奖 | 2023年7月</strong>, 2023 China Postgraduate Electronic Design Competition Northwest Division Technology Track | Second Prize | 2023.7</p></li><li><p><strong>2023年中国研究生电子设计大赛西北赛区商业计划赛道 | 西北赛区二等奖 | 2023年7月</strong>, 2023 China Postgraduate Electronic Design Competition Northwest Division Business Plan Track | Second Prize | 2023.7</p></li><li><p><strong>2023年中国国际互联网+创新创业大赛西安交通大学校赛 | 银奖（前47%有望获得金奖、银奖、铜奖） | 2023年7月</strong>, 2023 China International Internet + Innovation and Entrepreneurship Competition Xi’an Jiaotong University School Competition | Silver Award (Second Prize, The top 47% are expected to win the bronze award, and the proportion of the silver award is even less) | 2023.7</p></li><li><p>…</p></li></ul><h4 id="本科阶段-Bachelor-Period-1"><a href="#本科阶段-Bachelor-Period-1" class="headerlink" title="本科阶段 Bachelor Period"></a>本科阶段 Bachelor Period</h4><ul><li><p><strong>第十届中国软件杯大学生软件设计大赛决赛 | 国家级三等奖 | 2021年5月</strong>, Finals of the 10th China Software Cup College Student Software Design Competition | Third Prize | 2021.5</p></li><li><p><strong>2020年中国大学生计算机大赛-微信小程序应用开发赛 | 二等奖 | 2020年7月</strong>, 2020 China University Computer Competition - WeChat Approval Application Development Raihua Shuangyai District | Second Prize | 2020.7</p></li><li><p><strong>2021年美国大学生数学建模竞赛 | H奖 | 2021年4月</strong>, 2021 American College Students Mathematics Modeling Competition | Second Prize | 2021.4</p></li><li><p><strong>2020年亚太地区大学生数学建模竞赛 | 国际二等奖 | 2021年1月</strong>, 2020 College Students Mathematics Modeling Competition | Second Prize | 2021.1</p></li><li><p><strong>第十四届ICAN国际创新创业大赛中国区总决赛 | 国家级三等奖 | 2020年12月</strong>, Chinese Finals of the 14th ICAN International Innovation and Entrepreneurship Competition | Third Prize | 2020.12</p></li><li><p><strong>第十四届ICAN国际创新创业大赛河南赛区 | 省级一等奖 | 2020年10月</strong>, Henan Division of the 14th ICAN International Innovation and Entrepreneurship Competition | First Prize | 2020.10</p></li><li><p><strong>2021年中国大学生计算机设计大赛河南省级赛 | 省级三等奖 | 2021年5月</strong>, 2021 China University of Computer Design Competition Henan Provincial | Third Prize | 2021.5</p></li><li><p><strong>2020-2021学年郑州大学二等奖学金 | 2021年12月</strong>, 2020-2021 Journal of Zhengzhou University | First-class Scholarship | 2021.12</p></li><li><p><strong>2020-2021学年郑州大学三好学生 | 2021年12月</strong>, 2020-2021 school year Zhengzhou University | Three good students | 2021.12</p></li><li><p><strong>2019-2020学年郑州大学一等奖学金 | 2020年12月</strong>, 2019-2020 Journal of Zhengzhou University | First-class Scholarship | 2020.12</p></li><li><p><strong>2019-2020学年郑州大学三好学生 | 2020年12月</strong>, 2019-2020 school year Zhengzhou University | Three good students | 2020.12</p></li><li><p><strong>2018-2019学年郑州大学二等奖学金 | 2019年12月</strong>, 2018-2019 Journal of Zhengzhou University | First-class Scholarship | 2019.12</p></li><li><p><strong>2018-2019学年郑州大学三好学生 | 2019年12月</strong>, 2018-2019 school year Zhengzhou University | Three good students | 2019.12</p></li></ul><h2 id="专业技能（Professional-Skill）"><a href="#专业技能（Professional-Skill）" class="headerlink" title="专业技能（Professional Skill）"></a>专业技能（Professional Skill）</h2><p><strong>语言：Java(用作web开发+后端开发等)、Python(用作深度学习任务+小型服务器系统快速实现+QT界面快速开发等)、C++(用作LeetCode等算法题)</strong>, Java (used for web development + back-end development, etc.), Python (used for deep learning tasks + rapid implementation of small server systems + rapid development of QT interface, etc.), C++ (used for algorithm questions such as LeetCode)</p><p>…</p><h2 id="综合素质（Comprehensive-Quality）"><a href="#综合素质（Comprehensive-Quality）" class="headerlink" title="综合素质（Comprehensive Quality）"></a>综合素质（Comprehensive Quality）</h2><h4 id="社区和组织经验（Community-and-Organizational-Experiences）"><a href="#社区和组织经验（Community-and-Organizational-Experiences）" class="headerlink" title="社区和组织经验（Community and Organizational Experiences）"></a>社区和组织经验（Community and Organizational Experiences）</h4><p><strong>硕士阶段（Master Period）</strong></p><p><strong>&gt;组织名称：…</strong>, Organization: coming soon…</p><ul><li><strong>主要工作：…</strong>: coming soon …</li></ul><p>…<br><strong>本科阶段（Bachelor Period）</strong></p><p><strong>&gt;组织名称：优课达（杭州）网络有限公司郑州大学北校区俱乐部 | 2019年10月-2020年10月</strong>, Organization: Youkeda (Hangzhou) Network Co., Ltd. Zhengzhou University North Campus Club | Oct 2019 - Oct 2020</p><ul><li><strong>主要工作：我作为俱乐部负责人，在阿里巴巴技术专家的指导下定期组织技术交流。俱乐部会员技术在原有水平上有了很大的提高。</strong>, I have currently served as the head of Zhengzhou University North Campus Club, and regularly organized technical exchanges under the guidance of  Alibaba technical experts.Club membership technology has been greatly improved in the original level.</li></ul><h4 id="英语能力（English-Ability）"><a href="#英语能力（English-Ability）" class="headerlink" title="英语能力（English Ability）"></a>英语能力（English Ability）</h4><p><strong>英语水平：CET-4：545，CET-6：501，雅思总分：6.5，在研究生一年级期末阶段完成了4次全英答辩</strong>, English Level: CET-4:545, CET-6:501, IELTS(total):6.5, Completed 4 English defenses at the end of the first year of graduate school</p><h4 id="其他（Others）"><a href="#其他（Others）" class="headerlink" title="其他（Others）"></a>其他（Others）</h4><p><strong>&gt;爱好：篮球（大学新生篮球赛二等奖）、电影、音乐、…</strong>, Hobbies: Basketball (College New Student Collection Second Prize), Films, Music, …</p><p><strong>&gt;我对待学习的态度非常认真，不解决问题不罢休，也正是因为自己的这样一份坚持，才得以在本科阶段顺利保研攻读硕士研究生，并帮助自己完成了很多事情</strong></p><h2 id="联系我（Contact-Me）"><a href="#联系我（Contact-Me）" class="headerlink" title="联系我（Contact Me）"></a>联系我（Contact Me）</h2><p><strong>Email:<a href="mailto:&#x77;&#121;&#x79;&#115;&#117;&#99;&#x63;&#x65;&#115;&#115;&#50;&#x30;&#x32;&#x30;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;">&#x77;&#121;&#x79;&#115;&#117;&#99;&#x63;&#x65;&#115;&#115;&#50;&#x30;&#x32;&#x30;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109;</a></strong></p><p><strong>QQ: 844817943</strong></p><p><strong>Phone &amp; WeChat: 13803907433</strong></p><p><strong>地址：中国西安市西咸新区沣西新城西安交通大学创新港校区</strong>, Where am I now: Xi’an Jiaotong University Innovation Port Campus, Fengxi New City, Xixian New District, Xi’an City, China</p><p><strong>邮政编码：710100</strong>, Postal Code: 710100</p><p><em>This page was last updated on September 17, 2023.</em></p>]]></content>
    
  </entry>
  
  
  
</search>
