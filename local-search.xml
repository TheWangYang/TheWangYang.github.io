<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230822</title>
    <link href="/2023/08/22/my-leetcode-logs-20230822/"/>
    <url>/2023/08/22/my-leetcode-logs-20230822/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230820</title>
    <link href="/2023/08/20/my-leetcode-logs-20230820/"/>
    <url>/2023/08/20/my-leetcode-logs-20230820/</url>
    
    <content type="html"><![CDATA[<h2 id="131-分割回文串（C-回溯法实现）"><a href="#131-分割回文串（C-回溯法实现）" class="headerlink" title="131. 分割回文串（C++回溯法实现）"></a>131. 分割回文串（C++回溯法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//判断字符串是否为回文串的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                <span class="hljs-comment">//截取字符串</span><br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果不是回文数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯过程，返回已经添加的子串</span><br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）93-复原-IP-地址（C-回溯实现）"><a href="#（复习）93-复原-IP-地址（C-回溯实现）" class="headerlink" title="（复习）93. 复原 IP 地址（C++回溯实现）"></a>（复习）93. 复原 IP 地址（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-comment">//判断是否合法的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断start对应的s中的字符是否为0</span><br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//然后进行判断</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end;i++)&#123;<br>            <span class="hljs-comment">//首先判断每个数字是否合法</span><br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果数组都合法，然后计算从start到end对应的数字之和是否超过了255</span><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span></span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span>(pointNum == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">//判断最后一个逗点之后的字符串是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//判断是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointNum += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//递归调用函数，由于加入了一个点，因此下一个开始index应该为i + 2</span><br>                <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">2</span>, pointNum);<br>                pointNum -= <span class="hljs-number">1</span>;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）78-子集（C-实现）"><a href="#（复习）78-子集（C-实现）" class="headerlink" title="（复习）78. 子集（C++实现）"></a>（复习）78. 子集（C++实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtraing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtraing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtraing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230817</title>
    <link href="/2023/08/17/my-leetcode-logs-20230817/"/>
    <url>/2023/08/17/my-leetcode-logs-20230817/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）40-组合总和-II（C-回溯算法实现）"><a href="#（复习）40-组合总和-II（C-回溯算法实现）" class="headerlink" title="（复习）40. 组合总和 II（C++回溯算法实现）"></a>（复习）40. 组合总和 II（C++回溯算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义两个数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-comment">//定义回溯函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum ==target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层循环逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i<span class="hljs-number">-1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示树的同层中的上一个一样的元素使用过了</span><br>            &#125;<br><br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//实现了函数中间</span><br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracing</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）131-分割回文串（C-回溯实现）"><a href="#（复习）131-分割回文串（C-回溯实现）" class="headerlink" title="（复习）131. 分割回文串（C++回溯实现）"></a>（复习）131. 分割回文串（C++回溯实现）</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230802</title>
    <link href="/2023/08/02/my-leetcode-logs-20230802/"/>
    <url>/2023/08/02/my-leetcode-logs-20230802/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）131-分割回文串（C-回溯法实现，无优化版）"><a href="#（复习）131-分割回文串（C-回溯法实现，无优化版）" class="headerlink" title="（复习）131. 分割回文串（C++回溯法实现，无优化版）"></a>（复习）131. 分割回文串（C++回溯法实现，无优化版）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//设置函数判断输入字符串是否为回文串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; huiwen, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j;i++, j--)&#123;<br>            <span class="hljs-keyword">if</span>(huiwen[i] != huiwen[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯中单层逻辑实现</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="93-复原-IP-地址（C-回溯实现）"><a href="#93-复原-IP-地址（C-回溯实现）" class="headerlink" title="93. 复原 IP 地址（C++回溯实现）"></a>93. 复原 IP 地址（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-comment">//判断是否为合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//两个逗号之间的字符串的开始位置为0，表示不合法</span><br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//记录两个逗号之间的数字相加是否在255范围之内</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end;i ++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//num累加</span><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <br>            <span class="hljs-comment">//判断num是否大于255</span><br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">//设置的回溯算法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointSum)</span></span>&#123;<br>        <span class="hljs-comment">//判断pointSum等于3，表示是一个可能的结果</span><br>        <span class="hljs-keyword">if</span>(pointSum == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-comment">//首先判断是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                <span class="hljs-comment">//在i位置之后插入一个点</span><br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointSum += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//回溯调用</span><br>                <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">2</span>, pointSum);<br>                pointSum -= <span class="hljs-number">1</span>;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="78-子集（C-回溯法实现）"><a href="#78-子集（C-回溯法实现）" class="headerlink" title="78. 子集（C++回溯法实现）"></a>78. 子集（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现了"><a href="#实现了" class="headerlink" title="实现了"></a>实现了</h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230729</title>
    <link href="/2023/07/29/my-leetcode-logs-20230729/"/>
    <url>/2023/07/29/my-leetcode-logs-20230729/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）39-组合总和（C-回溯法实现）"><a href="#（复习）39-组合总和（C-回溯法实现）" class="headerlink" title="（复习）39. 组合总和（C++回溯法实现）"></a>（复习）39. 组合总和（C++回溯法实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-type">void</span> backtracing(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> index)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &gt; <span class="hljs-built_in">target</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>            result.push_back(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            path.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            path.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        result.clear();<br>        path.clear();<br>        <br>        backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和-II（C-回溯法实现）"><a href="#40-组合总和-II（C-回溯法实现）" class="headerlink" title="40. 组合总和 II（C++回溯法实现）"></a>40. 组合总和 II（C++回溯法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//核心思想：需要增加used数据，来判断是否使用过</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++)&#123;<br>            <span class="hljs-comment">//判断used数组中是否已经使用过i位置元素</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//先将candidates进行排序</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-built_in">backtracing</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串（C-回溯法实现，无优化版）"><a href="#131-分割回文串（C-回溯法实现，无优化版）" class="headerlink" title="131. 分割回文串（C++回溯法实现，无优化版）"></a>131. 分割回文串（C++回溯法实现，无优化版）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//判断是否为回文字符串的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; huiwen, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--)&#123;<br>            <span class="hljs-keyword">if</span>(huiwen[i] != huiwen[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯法中单层逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//回溯调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230728</title>
    <link href="/2023/07/28/my-leetcode-logs-20230728/"/>
    <url>/2023/07/28/my-leetcode-logs-20230728/</url>
    
    <content type="html"><![CDATA[<h2 id="复习：77-组合（C-回溯-剪枝实现）"><a href="#复习：77-组合（C-回溯-剪枝实现）" class="headerlink" title="复习：77. 组合（C++回溯+剪枝实现）"></a>复习：77. 组合（C++回溯+剪枝实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//定义保存路径的数组</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//定义保存整个结果的result数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//回溯实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="216-组合总和-III（C-回溯实现）"><a href="#216-组合总和-III（C-回溯实现）" class="headerlink" title="216. 组合总和 III（C++回溯实现）"></a>216. 组合总和 III（C++回溯实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-comment">//判断path.size()是否等于k</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            <span class="hljs-comment">//判断targetSum是否等于n</span><br>            <span class="hljs-keyword">if</span>(sum == n)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯单层逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>;i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            sum += i;<br>            <span class="hljs-built_in">backtracing</span>(k, n, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合（C-回溯实现）"><a href="#17-电话号码的字母组合（C-回溯实现）" class="headerlink" title="17. 电话号码的字母组合（C++回溯实现）"></a>17. 电话号码的字母组合（C++回溯实现）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义字母和数字之间的映射</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> num2str[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-comment">//0</span><br>        <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-comment">//1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-comment">//2</span><br>        <span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-comment">//3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-comment">//4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-comment">//5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-comment">//6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-comment">//7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-comment">//8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>,<span class="hljs-comment">//9</span><br>    &#125;;<br><br>    vector&lt;<span class="hljs-built_in">string</span>&gt; result;<br>    <span class="hljs-built_in">string</span> s;<span class="hljs-comment">//这个string类型变量就相当于path</span><br><br>    <span class="hljs-comment">//回溯算法实现</span><br>    <span class="hljs-comment">//参数为传入digits地址，起始index下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracing</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; digits, <span class="hljs-built_in">int</span> startIndex</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex == digits.size())&#123;<br>            result.push_back(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//将digits中对应startIndex位置的数字转为数字</span><br>        <span class="hljs-built_in">int</span> digit = digits[startIndex] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">string</span> letters = num2str[digit];<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; letters.size();i++)&#123;<br>            s.push_back(letters[i]);<br>            backtracing(digits, startIndex + <span class="hljs-number">1</span>);<br>            s.pop_back();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">letterCombinations</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> digits</span>)</span> &#123;<br>        s.clear();<br>        result.clear();<br>        <span class="hljs-keyword">if</span>(digits.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        backtracing(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和（C-回溯法实现）"><a href="#39-组合总和（C-回溯法实现）" class="headerlink" title="39. 组合总和（C++回溯法实现）"></a>39. 组合总和（C++回溯法实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    <span class="hljs-type">void</span> backtracing(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> index)&#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-built_in">target</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>            result.push_back(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            path.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        result.clear();<br>        path.clear();<br><br>        backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230727</title>
    <link href="/2023/07/27/my-leetcode-logs-20230727/"/>
    <url>/2023/07/27/my-leetcode-logs-20230727/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）108-将有序数组转换为二叉搜索树"><a href="#（复习）108-将有序数组转换为二叉搜索树" class="headerlink" title="（复习）108. 将有序数组转换为二叉搜索树"></a>（复习）108. 将有序数组转换为二叉搜索树</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//创建保存结点的队列</span><br>        queue&lt;TreeNode*&gt; nodeQ;<br>        <span class="hljs-comment">//创建保存左left边界的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQ;<br>        <span class="hljs-comment">//创建保存右right边界的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQ;<br><br>        <span class="hljs-comment">//初始化一个空结点并加入到队列中</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>        nodeQ.<span class="hljs-keyword">push</span>(root);<br><br>        <span class="hljs-comment">//将left和right加入到对应的队列中</span><br>        leftQ.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);<br>        rightQ.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//循环遍历实现对树的构造</span><br>        <span class="hljs-keyword">while</span>(!nodeQ.empty())&#123;<br>            <span class="hljs-comment">//首先得到nodeQ队列头部的结点进行赋值</span><br>            TreeNode* curr = nodeQ.front();<br>            nodeQ.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-comment">//得到left和right</span><br>            <span class="hljs-keyword">int</span> left = leftQ.front();<br>            leftQ.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> right = rightQ.front();<br>            rightQ.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>            curr-&gt;val = nums[mid];<br><br>            <span class="hljs-comment">//处理左子树</span><br>            <span class="hljs-keyword">if</span>(left &lt;= mid - <span class="hljs-number">1</span>)&#123;<br>                curr-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                leftQ.<span class="hljs-keyword">push</span>(left);<br>                rightQ.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>                nodeQ.<span class="hljs-keyword">push</span>(curr-&gt;left);<br>            &#125;<br><br>            <span class="hljs-comment">//处理右子树</span><br>            <span class="hljs-keyword">if</span>(right &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>                curr-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                leftQ.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>                rightQ.<span class="hljs-keyword">push</span>(right);<br>                nodeQ.<span class="hljs-keyword">push</span>(curr-&gt;right);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树（C-递归实现）"><a href="#538-把二叉搜索树转换为累加树（C-递归实现）" class="headerlink" title="538. 把二叉搜索树转换为累加树（C++递归实现）"></a>538. 把二叉搜索树转换为累加树（C++递归实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br><br>    void convertBSTHelper(TreeNode* root, int &amp;<span class="hljs-built_in">sum</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        // 遍历右子树<br>        convertBSTHelper(root-&gt;<span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>);<br><br>        // 更新当前节点的值为累加和<br>        <span class="hljs-built_in">sum</span> += root-&gt;val;<br>        root-&gt;val = <span class="hljs-built_in">sum</span>;<br><br>        // 遍历左子树<br>        convertBSTHelper(root-&gt;<span class="hljs-built_in">left</span>, <span class="hljs-built_in">sum</span>);<br>    &#125;<br><br>    TreeNode* convertBST(TreeNode* root) &#123;<br>        //使用递归实现<br>        int <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        convertBSTHelper(root, <span class="hljs-built_in">sum</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树（C-迭代法实现）"><a href="#538-把二叉搜索树转换为累加树（C-迭代法实现）" class="headerlink" title="538. 把二叉搜索树转换为累加树（C++迭代法实现）"></a>538. 把二叉搜索树转换为累加树（C++迭代法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre;<span class="hljs-comment">//pre保存当前累加值</span><br><br>    <span class="hljs-comment">//使用迭代法实现</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_new_BST</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        TreeNode* curr = root;<br>        <span class="hljs-comment">//使用栈保存树的结点，实现迭代遍历</span><br>        stack&lt;TreeNode*&gt; st;<br><br>        <span class="hljs-comment">//使用循环实现，按照右中左实现反中序遍历</span><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(curr);<br>                curr = curr-&gt;right;<span class="hljs-comment">//右</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//中</span><br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                curr-&gt;val += pre;<br><br>                pre = curr-&gt;val;<span class="hljs-comment">//更新累加之后的值</span><br><br>                <span class="hljs-comment">//左</span><br>                curr = curr-&gt;left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        pre = <span class="hljs-number">0</span>;<br>        TreeNode* resultNode = <span class="hljs-built_in">get_new_BST</span>(root);<br>        <span class="hljs-keyword">return</span> resultNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="77-组合（C-回溯法实现）"><a href="#77-组合（C-回溯法实现）" class="headerlink" title="77. 组合（C++回溯法实现）"></a>77. 组合（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置path保存当前层的满足题意结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//设置保存所有path的result结果数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//使用回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n;i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯回来之后，弹出最后一个元素</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//首先清空result数组</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//path清空</span><br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//调用回溯法</span><br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="77-组合（C-回溯法剪枝实现）"><a href="#77-组合（C-回溯法剪枝实现）" class="headerlink" title="77. 组合（C++回溯法剪枝实现）"></a>77. 组合（C++回溯法剪枝实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置path保存当前层的满足题意结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//设置保存所有path的result结果数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//使用回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>;i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯回来之后，弹出最后一个元素</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//首先清空result数组</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//path清空</span><br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//调用回溯法</span><br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230726</title>
    <link href="/2023/07/26/my-leetcode-logs-20230726/"/>
    <url>/2023/07/26/my-leetcode-logs-20230726/</url>
    
    <content type="html"><![CDATA[<h2 id="复习：669-修剪二叉搜索树（迭代法实现，C-）"><a href="#复习：669-修剪二叉搜索树（迭代法实现，C-）" class="headerlink" title="复习：669. 修剪二叉搜索树（迭代法实现，C++）"></a>复习：669. 修剪二叉搜索树（迭代法实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-comment">//修剪二叉树，迭代实现</span><br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//修剪root节点</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(root != NULL &amp;&amp; (root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root -&gt;</span> right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root -&gt;</span> left;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">//修剪root结点的左子树小于low的情况</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-comment">//循环找到左边界</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> right;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr -&gt;</span> left;<br>        &#125;<br><br>        curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-comment">//循环处理右子树大于high的情况</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>right;<br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树（C-递归法实现）"><a href="#108-将有序数组转换为二叉搜索树（C-递归法实现）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（C++递归法实现）"></a>108. 将有序数组转换为二叉搜索树（C++递归法实现）</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs excel">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     <span class="hljs-built_in">int</span> val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() <span class="hljs-symbol">:</span> val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(<span class="hljs-built_in">int</span> x) <span class="hljs-symbol">:</span> val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(<span class="hljs-built_in">int</span> x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) <span class="hljs-symbol">:</span> val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br><br>    //使用递归法实现<br>    TreeNode* digui(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span> &gt; <span class="hljs-built_in">right</span>)&#123;<br>            return NULL;<br>        &#125;<br><br>        //单层递归逻辑<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + ((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br>        TreeNode* root = new TreeNode(nums[<span class="hljs-built_in">mid</span>]);<br><br>        //递归调用<br>        root-&gt;<span class="hljs-built_in">left</span> = digui(nums, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>);<br>        root-&gt;<span class="hljs-built_in">right</span> = digui(nums, <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);<br><br>        return root;<br>    &#125;<br><br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        //使用迭代法实现<br>        return digui(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树（C-迭代法实现）"><a href="#108-将有序数组转换为二叉搜索树（C-迭代法实现）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（C++迭代法实现）"></a>108. 将有序数组转换为二叉搜索树（C++迭代法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//初始化根结点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>        queue&lt;TreeNode*&gt; nodeQueue;<span class="hljs-comment">//创建队列保存树结点</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQueue;<span class="hljs-comment">//创建保存left左下标的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQueue;<span class="hljs-comment">//创建保存right右下标的队列</span><br><br>        <span class="hljs-comment">//将left=0和right=nums.size()-1分别放到left和right队列中</span><br>        nodeQueue.<span class="hljs-keyword">push</span>(root);<br>        leftQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);<br>        rightQueue.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//使用while循环</span><br>        <span class="hljs-keyword">while</span>(!nodeQueue.empty())&#123;<br>            <span class="hljs-comment">//得到当前结点</span><br>            TreeNode* curr = nodeQueue.front();<br>            nodeQueue.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-comment">//拿到left和right下标</span><br>            <span class="hljs-keyword">int</span> left = leftQueue.front();<br>            leftQueue.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-keyword">int</span> right = rightQueue.front();<br>            rightQueue.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br><br>            curr-&gt;val = nums[mid];<span class="hljs-comment">//将nums[mid]值复制给curr-&gt;val</span><br><br><br>            <span class="hljs-comment">//处理左子树</span><br>            <span class="hljs-keyword">if</span>(left &lt;= mid - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//向nodeQueue中加入left空结点，用于下次赋值</span><br>                curr-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQueue.<span class="hljs-keyword">push</span>(curr-&gt;left);<br>                leftQueue.<span class="hljs-keyword">push</span>(left);<br>                rightQueue.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//处理右子树</span><br>            <span class="hljs-keyword">if</span>(right &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//向nodeQueue中加入right空结点，用于下次赋值</span><br>                curr-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQueue.<span class="hljs-keyword">push</span>(curr-&gt;right);<br>                rightQueue.<span class="hljs-keyword">push</span>(right);<br>                leftQueue.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230719</title>
    <link href="/2023/07/19/my-leetcode-logs-20230719/"/>
    <url>/2023/07/19/my-leetcode-logs-20230719/</url>
    
    <content type="html"><![CDATA[<h2 id="669-修剪二叉搜索树（递归实现，C-）"><a href="#669-修剪二叉搜索树（递归实现，C-）" class="headerlink" title="669. 修剪二叉搜索树（递归实现，C++）"></a>669. 修剪二叉搜索树（递归实现，C++）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* trim<span class="hljs-constructor">BST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span> &#123;<br>        <span class="hljs-comment">//迭代实现</span><br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//当前结点的值小于low，那么遍历root的right右子树</span><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; low)&#123;<br>            TreeNode* node = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>            return node;<br>        &#125;<br><br>        <span class="hljs-comment">//当前结点的值大于high，那么遍历root的左子树</span><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; high)&#123;<br>            TreeNode* node = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>            return node;<br>        &#125;<br><br>        root-&gt;left = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>        root-&gt;right = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树（迭代法实现，C-）"><a href="#669-修剪二叉搜索树（迭代法实现，C-）" class="headerlink" title="669. 修剪二叉搜索树（迭代法实现，C++）"></a>669. 修剪二叉搜索树（迭代法实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//处理根结点，将新树的root结点调节到low,hight之间</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(root != NULL &amp;&amp; (root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//继续处理</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<span class="hljs-comment">//处理左子树小于low的情况</span><br>            <span class="hljs-comment">//循环找到左边界</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>right;<br>            &#125;<br>            <span class="hljs-comment">//处理curr结点的</span><br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>left;<br>        &#125;<br><br>        <span class="hljs-comment">//处理root结点的右边，将大于high的结点删除掉</span><br>        curr = root;<br><br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>right;<br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230718</title>
    <link href="/2023/07/18/my-leetcode-logs-20230718/"/>
    <url>/2023/07/18/my-leetcode-logs-20230718/</url>
    
    <content type="html"><![CDATA[<h2 id="701-二叉搜索树中的插入操作（递归实现，C-）"><a href="#701-二叉搜索树中的插入操作（递归实现，C-）" class="headerlink" title="701. 二叉搜索树中的插入操作（递归实现，C++）"></a>701. 二叉搜索树中的插入操作（递归实现，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        //用递归方法实现<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            TreeNode* node = new TreeNode(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val)&#123;<br>            root-&gt;<span class="hljs-built_in">left</span> = insertIntoBST(root-&gt;<span class="hljs-built_in">left</span>, val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val)&#123;<br>            root-&gt;<span class="hljs-built_in">right</span> = insertIntoBST(root-&gt;<span class="hljs-built_in">right</span>,val);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="701-二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C-）"><a href="#701-二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C-）" class="headerlink" title="701. 二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C++）"></a>701. 二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        //使用迭代法实现<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            TreeNode* node = new TreeNode(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        TreeNode* curr = root;<br>        TreeNode* parent = root;<br>        while(curr != NULL)&#123;//while循环当curr等于NULL时弹出，就是需要插入的节点位置<br>            parent = curr;<br>            <span class="hljs-keyword">if</span>(curr-&gt;val &lt; val)&#123;<br>                curr = curr-&gt;<span class="hljs-built_in">right</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = curr-&gt;<span class="hljs-built_in">left</span>;<br>            &#125;<br>        &#125;<br><br>        //处理parent和新插入的节点位置的关系<br>        TreeNode* node = new TreeNode(val);<br>        <span class="hljs-keyword">if</span>(parent-&gt;val &gt; val)&#123;//表示插入点在parent的左<br>            parent-&gt;<span class="hljs-built_in">left</span> = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent-&gt;<span class="hljs-built_in">right</span> = node;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点（递归实现，C-）"><a href="#450-删除二叉搜索树中的节点（递归实现，C-）" class="headerlink" title="450. 删除二叉搜索树中的节点（递归实现，C++）"></a>450. 删除二叉搜索树中的节点（递归实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* deleteNode(TreeNode* root, int key) &#123;<br><br>        <span class="hljs-comment">//删除二叉搜索树的结点</span><br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-comment">//第一种情况，key对应的结点为叶子结点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(root -&gt;</span> <span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> == NULL &amp;&amp; root-&gt;</span>right == NULL)&#123;<br>            delete root;<br>            return NULL;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; root-&gt;</span>right == NULL)&#123;<span class="hljs-comment">//第二种情况，删除节点有左子树</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* node = root-&gt;</span>left;<br>            delete root;<br>            return node;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> == NULL &amp;&amp; root-&gt;</span>right != NULL)&#123;<span class="hljs-comment">//第三种情况，删除节点有右子树</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* node = root-&gt;</span>right;<br>            delete root;<br>            return node;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; root-&gt;</span>right != NULL)&#123;<span class="hljs-comment">//第四种情况，删除节点左右子树都存在</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* curr = root-&gt;</span>right;<span class="hljs-comment">//遍历要删除的结点的右子树</span><br>            <span class="hljs-comment">//找到要删除结点的右子树的最左边子树的结点</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span>left != NULL)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>left;<br>            &#125;<br><br>            <span class="hljs-comment">//将删除节点的左子树移动到上述curr对应的结点的左子树上</span><br>            <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = root-&gt;</span>left;<br>            <span class="hljs-comment">//记录要删除的节点</span><br>            TreeNode* tmp = root;<br>            <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<span class="hljs-comment">//返回结点的右子树作为根节点</span><br>            delete tmp;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-comment">//然后用root-&gt;left/right来接着对应的递归返回节点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; key)&#123;<br>            <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = deleteNode(root-&gt;</span>right, key);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &gt; key)&#123;<br>            <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = deleteNode(root-&gt;</span>left, key);<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230716</title>
    <link href="/2023/07/16/my-leetcode-logs-20230716/"/>
    <url>/2023/07/16/my-leetcode-logs-20230716/</url>
    
    <content type="html"><![CDATA[<h2 id="98-验证二叉搜索树（迭代，C-）"><a href="#98-验证二叉搜索树（迭代，C-）" class="headerlink" title="98.验证二叉搜索树（迭代，C++）"></a>98.验证二叉搜索树（迭代，C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//使用栈来进行迭代法实现（中序遍历迭代）</span><br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* currNode = root;<br>        TreeNode* preNode = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">//使用同一迭代法遍历树结点</span><br>        <span class="hljs-keyword">while</span>(currNode != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(currNode != <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-comment">//将当前结点加入到栈中</span><br>                st.<span class="hljs-built_in">push</span>(currNode);<br>                currNode = currNode -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currNode = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//中</span><br>                <span class="hljs-keyword">if</span>(preNode != <span class="hljs-literal">NULL</span> &amp;&amp; currNode-&gt;val &lt;= preNode-&gt;val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//保存前一个结点</span><br>                preNode = currNode;<br>                <span class="hljs-comment">//右</span><br>                currNode = currNode -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="530-二叉搜索树的最小绝对差（迭代，C-）"><a href="#530-二叉搜索树的最小绝对差（迭代，C-）" class="headerlink" title="530. 二叉搜索树的最小绝对差（迭代，C++）"></a>530. 二叉搜索树的最小绝对差（迭代，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    //设置最小插值默认为最大<br>    long long result = LONG_MAX;<br>    int getMinimumDifference(TreeNode* root) &#123;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* pre = NULL;<br>        TreeNode* curr = root;<br><br>        while(curr != NULL |<span class="hljs-type">| !st</span>.empty())&#123;<br>            <span class="hljs-keyword">if</span>(curr != NULL)&#123;<br>                st.push(curr);<br>                curr = curr -&gt; <span class="hljs-built_in">left</span>;//左中右<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.pop();<br>                <span class="hljs-keyword">if</span>(pre != NULL &amp;&amp; abs(pre-&gt;val - curr-&gt;val) &lt; result)&#123;<br>                    result = abs(pre-&gt;val - curr-&gt;val);<br>                &#125;<br>                pre = curr;<br>                curr = curr -&gt; <span class="hljs-built_in">right</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（迭代，C-）"><a href="#501-二叉搜索树中的众数（迭代，C-）" class="headerlink" title="501.二叉搜索树中的众数（迭代，C++）"></a>501.二叉搜索树中的众数（迭代，C++）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        TreeNode* curr = root;<br>        <span class="hljs-comment">//创建Map以保存每个树结点对应的次数</span><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(curr);<br>                curr = curr -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//中</span><br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                dict[curr-&gt;val]++;<br><br>                <span class="hljs-comment">//右边</span><br>                curr = curr -&gt; right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到最大的出现次数</span><br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : dict) &#123;<br>            <span class="hljs-keyword">if</span> (entry.second &gt; maxCount) &#123;<br>                maxCount = entry.second;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 找到出现次数等于最大值的数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : dict) &#123;<br>            <span class="hljs-keyword">if</span> (entry.second == maxCount) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(entry.first);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（递归，C-）"><a href="#501-二叉搜索树中的众数（递归，C-）" class="headerlink" title="501.二叉搜索树中的众数（递归，C++）"></a>501.二叉搜索树中的众数（递归，C++）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> max_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大出现次数</span><br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前count</span><br>    TreeNode* pre = NULL;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; result;<br><br>    void <span class="hljs-constructor">BSTdigui(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-comment">//按照左中右的顺序遍历</span><br>        <span class="hljs-comment">//遍历左子树</span><br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br><br>        <span class="hljs-comment">//处理本次遍历内部逻辑</span><br>        <span class="hljs-keyword">if</span>(pre<span class="hljs-operator"> == </span>NULL)&#123;<span class="hljs-comment">//第一个结点，因为之前的结点都是1</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre != NULL<span class="hljs-operator"> &amp;&amp; </span>pre-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>root-&gt;<span class="hljs-keyword">val</span>)&#123;<span class="hljs-comment">//判断pre和curr的值是否相等</span><br>            count++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//与前一个结点数值不相同</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//更新pre</span><br>        pre = root;<br><br>        <span class="hljs-comment">//判断count和max_count的大小，相等，直接将root-&gt;val放入到返回的结果数组中</span><br>        <span class="hljs-keyword">if</span>(count<span class="hljs-operator"> == </span>max_count)&#123;<br>            result.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断是否为最大值</span><br>        <span class="hljs-keyword">if</span>(count &gt; max_count)&#123;<br>            max_count = count;<br>            <span class="hljs-comment">//result中结果都失效了</span><br>            result.clear<span class="hljs-literal">()</span>;<br>            result.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历右子树</span><br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        return ;<br>    &#125;<br><br>    vector&lt;<span class="hljs-built_in">int</span>&gt; find<span class="hljs-constructor">Mode(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（迭代法，C-实现）"><a href="#501-二叉搜索树中的众数（迭代法，C-实现）" class="headerlink" title="501.二叉搜索树中的众数（迭代法，C++实现）"></a>501.二叉搜索树中的众数（迭代法，C++实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; findMode(TreeNode* root) &#123;<br>        <span class="hljs-comment">//使用迭代遍历法实现</span><br>        TreeNode* pre = <span class="hljs-keyword">NULL</span>;<br>        TreeNode* curr = root;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">int</span> max_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-keyword">NULL</span> || !st.empty())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">NULL</span>)&#123;<br>                st.<span class="hljs-keyword">push</span>(curr);<br>                curr = curr -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = st.top();<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//开始和递归法一样</span><br>                <span class="hljs-keyword">if</span>(pre == <span class="hljs-keyword">NULL</span>)&#123;<span class="hljs-comment">//首个结点</span><br>                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre-&gt;val == curr-&gt;val)&#123;<br>                    <span class="hljs-keyword">count</span>++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//和前一个结点不一样</span><br>                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//更新前一个结点</span><br>                pre = curr;<br><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> == max_count)&#123;<br>                    result.push_back(curr-&gt;val);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &gt; max_count)&#123;<br>                    max_count = <span class="hljs-keyword">count</span>;<br>                    result.clear();<br>                    result.push_back(curr-&gt;val);<br>                &#125;<br><br>                curr = curr -&gt; right;<span class="hljs-comment">//右结点</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先（递归调用，C-实现）"><a href="#236-二叉树的最近公共祖先（递归调用，C-实现）" class="headerlink" title="236.二叉树的最近公共祖先（递归调用，C++实现）"></a>236.二叉树的最近公共祖先（递归调用，C++实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(NULL), <span class="hljs-built_in">right</span>(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-keyword">if</span>(root == p |<span class="hljs-type">| root</span> == q |<span class="hljs-type">| root</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        TreeNode* <span class="hljs-built_in">left</span> = lowestCommonAncestor(root-&gt;<span class="hljs-built_in">left</span>, p, q);<br>        TreeNode* <span class="hljs-built_in">right</span> = lowestCommonAncestor(root-&gt;<span class="hljs-built_in">right</span>, p, q);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> != NULL &amp;&amp; <span class="hljs-built_in">right</span> != NULL)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> != NULL &amp;&amp; <span class="hljs-built_in">right</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> == NULL &amp;&amp; <span class="hljs-built_in">right</span> != NULL)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">right</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> NULL;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先（递归法，C-实现，充分利用二叉搜索树的特征）"><a href="#235-二叉搜索树的最近公共祖先（递归法，C-实现，充分利用二叉搜索树的特征）" class="headerlink" title="235. 二叉搜索树的最近公共祖先（递归法，C++实现，充分利用二叉搜索树的特征）"></a>235. 二叉搜索树的最近公共祖先（递归法，C++实现，充分利用二叉搜索树的特征）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br><br>    TreeNode* <span class="hljs-constructor">BSTdigui(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; p-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &gt; q-&gt;<span class="hljs-keyword">val</span>)&#123;<br>            TreeNode* left = <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>            <span class="hljs-keyword">if</span>(left != NULL)&#123;<br>                return left;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; p-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &lt; q-&gt;<span class="hljs-keyword">val</span>)&#123;<br>            TreeNode* right = <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>            <span class="hljs-keyword">if</span>(right != NULL)&#123;<br>                return right;<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125; <br><br><br>    TreeNode* lowest<span class="hljs-constructor">CommonAncestor(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span> &#123;<br>        return <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先（迭代法，C-实现，充分利用二叉搜索树的特征）"><a href="#235-二叉搜索树的最近公共祖先（迭代法，C-实现，充分利用二叉搜索树的特征）" class="headerlink" title="235. 二叉搜索树的最近公共祖先（迭代法，C++实现，充分利用二叉搜索树的特征）"></a>235. 二叉搜索树的最近公共祖先（迭代法，C++实现，充分利用二叉搜索树的特征）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br>class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; p-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; p-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                return root;<br>            &#125;<br>        &#125;<br>        return NULL;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>Alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230711</title>
    <link href="/2023/07/11/my-leetcode-logs-20230711/"/>
    <url>/2023/07/11/my-leetcode-logs-20230711/</url>
    
    <content type="html"><![CDATA[<h2 id="700-二叉搜索树中的搜索（层序遍历法）"><a href="#700-二叉搜索树中的搜索（层序遍历法）" class="headerlink" title="700.二叉搜索树中的搜索（层序遍历法）"></a>700.二叉搜索树中的搜索（层序遍历法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-keyword">val</span> <span class="hljs-operator">==</span> <span class="hljs-keyword">val</span>)&#123;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索（递归法）"><a href="#700-二叉搜索树中的搜索（递归法）" class="headerlink" title="700.二叉搜索树中的搜索（递归法）"></a>700.二叉搜索树中的搜索（递归法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode huisu(TreeNode root, int <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.<span class="hljs-keyword">val</span> == <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">//表示在root的左子树中</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> &lt; root.<span class="hljs-keyword">val</span>)&#123;<br>            <span class="hljs-keyword">return</span> huisu(root.left, <span class="hljs-keyword">val</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> huisu(root.right, <span class="hljs-keyword">val</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">return</span> huisu(root, <span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（递归法实现）"><a href="#98-验证二叉搜索树（递归法实现）" class="headerlink" title="98.验证二叉搜索树（递归法实现）"></a>98.验证二叉搜索树（递归法实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>    <span class="hljs-comment">//递归实现中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> digui(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//中序遍历：右中左</span><br>        digui(root.left);<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        digui(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> boolean isValidBST(TreeNode root) &#123;<br>        digui(root);<br>        <span class="hljs-comment">//使用中序遍历，同时保存树的结点的值，判断是否为升序即可</span><br>        <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i <span class="hljs-operator">&lt;</span> result.size(); i <span class="hljs-operator">++</span>)&#123;<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">get</span>(i) <span class="hljs-operator">&lt;=</span> result.<span class="hljs-built_in">get</span>(i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（迭代法实现）"><a href="#98-验证二叉搜索树（迭代法实现）" class="headerlink" title="98.验证二叉搜索树（迭代法实现）"></a>98.验证二叉搜索树（迭代法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isValidBST(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            stack.<span class="hljs-keyword">push</span>(root);<br>        &#125;<br>        TreeNode pre = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">//循环迭代</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-comment">//得到栈顶结点</span><br>            TreeNode curr = stack.peek();<br>            <span class="hljs-comment">//判断curr是否为null</span><br>            <span class="hljs-comment">//按照右中左的顺序加入到栈中</span><br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>                stack.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出栈顶结点</span><br>                <span class="hljs-keyword">if</span>(curr.right != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//判断当前结点的右结点是否为null，不为null</span><br>                    stack.<span class="hljs-keyword">push</span>(curr.right);<br>                &#125;<br>                stack.<span class="hljs-keyword">push</span>(curr);<br>                stack.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(curr.left != <span class="hljs-keyword">null</span>)&#123;<br>                    stack.<span class="hljs-keyword">push</span>(curr.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//弹出栈顶null（占位）结点</span><br>                stack.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//对结点进行操作</span><br>                TreeNode tmp = stack.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span> &amp;&amp; pre.val &gt;= tmp.val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（递归，C-）"><a href="#98-验证二叉搜索树（递归，C-）" class="headerlink" title="98.验证二叉搜索树（递归，C++）"></a>98.验证二叉搜索树（递归，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    long long max_value = LONG_MIN;<br>    bool isValidBST(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            <span class="hljs-keyword">return</span> true;<br>        &#125;<br><br>        bool <span class="hljs-built_in">left</span> = isValidBST(root-&gt;<span class="hljs-built_in">left</span>);<br>        <span class="hljs-keyword">if</span>(max_value &lt; root-&gt;val)&#123;<br>            max_value = root-&gt;val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> false;<br>        &#125;<br>        bool <span class="hljs-built_in">right</span> = isValidBST(root-&gt;<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span> &amp;&amp; <span class="hljs-built_in">right</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>C++</tag>
      
      <tag>二叉树（从700. 二叉搜索树中的搜索开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230710.md</title>
    <link href="/2023/07/10/my-leetcode-logs-20230710/"/>
    <url>/2023/07/10/my-leetcode-logs-20230710/</url>
    
    <content type="html"><![CDATA[<h2 id="513-找树左下角的值（递归写法）"><a href="#513-找树左下角的值（递归写法）" class="headerlink" title="513.找树左下角的值（递归写法）"></a>513.找树左下角的值（递归写法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    int max_depth <span class="hljs-operator">=</span> <span class="hljs-number">-1</span>;<br>    int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> huisu(TreeNode root, int depth)&#123;<br>        <span class="hljs-comment">//设置递归终止条件</span><br>        <span class="hljs-keyword">if</span>(root.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> root.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(max_depth <span class="hljs-operator">&lt;</span> depth)&#123;<br>                max_depth <span class="hljs-operator">=</span> depth;<br>                result <span class="hljs-operator">=</span> root.<span class="hljs-keyword">val</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归左子树条件</span><br>        <span class="hljs-keyword">if</span>(root.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            depth<span class="hljs-operator">++</span>;<br>            huisu(root.left, depth);<br>            depth<span class="hljs-operator">--</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归右子树</span><br>        <span class="hljs-keyword">if</span>(root.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            depth<span class="hljs-operator">++</span>;<br>            huisu(root.right, depth);<br>            depth<span class="hljs-operator">--</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int findBottomLeftValue(TreeNode root) &#123;<br>        huisu(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="513-找树左下角的值（迭代法）"><a href="#513-找树左下角的值（迭代法）" class="headerlink" title="513.找树左下角的值（迭代法）"></a>513.找树左下角的值（迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> findBottomLeftValue(TreeNode root) &#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//使用二叉树层序遍历</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-comment">///如果队列不是空的，那么进入循环</span><br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到当前队列的长度</span><br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">size</span>;i ++)&#123;<br>                <span class="hljs-comment">//得到每层的结点</span><br>                TreeNode node = que.poll();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                    result = node.val;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路经总和（递归法）"><a href="#112-路经总和（递归法）" class="headerlink" title="112.路经总和（递归法）"></a>112.路经总和（递归法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//设置的回溯算法</span><br>    <span class="hljs-keyword">public</span> boolean huisu(TreeNode root, int currSum)&#123;<br>        <span class="hljs-comment">//判断是否为targetSum</span><br>        <span class="hljs-comment">//遇到叶子结点且currSum==0，这表示找到了满足题意的结果</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; currSum == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遇到叶子节点直接返回false</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            currSum -= root.left.<span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">if</span>(huisu(root.left, currSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            currSum += root.left.<span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            currSum -= root.right.<span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">if</span>(huisu(root.right, currSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            currSum += root.right.<span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> boolean hasPathSum(TreeNode root, int targetSum) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> huisu(root, targetSum - root.<span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路径总和（迭代法）"><a href="#112-路径总和（迭代法）" class="headerlink" title="112.路径总和（迭代法）"></a>112.路径总和（迭代法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-comment">//自定义类</span><br>public <span class="hljs-keyword">class</span> MyNode&#123;<br>     TreeNode treeNode;<br>     <span class="hljs-built_in">int</span> currSum = <span class="hljs-number">0</span>;<br>     <span class="hljs-constructor">MyNode(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">currSum</span>)</span>&#123;<br>         this.treeNode = root;<br>         this.currSum = currSum;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean has<span class="hljs-constructor">PathSum(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">targetSum</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用非递归方法做</span><br>        Stack&lt;MyNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        MyNode rootNode = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">root</span>, <span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span>;<br>        st.push(rootNode);<br><br>        <span class="hljs-keyword">while</span>(!st.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            MyNode node = st.peek<span class="hljs-literal">()</span>;<br>            st.pop<span class="hljs-literal">()</span>;<br><br>            <span class="hljs-keyword">if</span>(targetSum<span class="hljs-operator"> == </span>node.currSum<span class="hljs-operator"> &amp;&amp; </span>node.treeNode.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>node.treeNode.right<span class="hljs-operator"> == </span>null)&#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//压入右结点栈中</span><br>            <span class="hljs-keyword">if</span>(node.treeNode.right != null)&#123;<br>                st.push(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">right</span>, <span class="hljs-params">node</span>.<span class="hljs-params">currSum</span> + <span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">right</span>.<span class="hljs-params">val</span>)</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//将左结点压入栈中</span><br>            <span class="hljs-keyword">if</span>(node.treeNode.left != null)&#123;<br>                st.push(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">left</span>, <span class="hljs-params">node</span>.<span class="hljs-params">currSum</span> + <span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">left</span>.<span class="hljs-params">val</span>)</span>);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路经总和2（回溯法）"><a href="#113-路经总和2（回溯法）" class="headerlink" title="113.路经总和2（回溯法）"></a>113.路经总和2（回溯法）</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用回溯方法做<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> huisu(TreeNode root, <span class="hljs-type">int</span> targetSum, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; targetSum == root.val)&#123;<br>            result.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(<span class="hljs-type">path</span>));<br>        &#125;<br><br>        huisu(root.left, targetSum - root.val, result, <span class="hljs-type">path</span>);<br>        huisu(root.right, targetSum - root.val, result, <span class="hljs-type">path</span>);<br><br>        <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; pathSum(TreeNode root, <span class="hljs-type">int</span> targetSum) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        huisu(root, targetSum, result, <span class="hljs-type">path</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路经总和2（DFS法）"><a href="#113-路经总和2（DFS法）" class="headerlink" title="113.路经总和2（DFS法）"></a>113.路经总和2（DFS法）</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; res = new ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; pathSum(TreeNode root, <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>) &#123;<br>        List&lt;<span class="hljs-keyword">Integer</span>&gt; cur = new ArrayList&lt;&gt;();<br>        dfs(root, cur, <span class="hljs-number">0</span>, <span class="hljs-built_in">sum</span>);            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br><br>    <span class="hljs-keyword">public</span> void dfs(TreeNode node, List&lt;<span class="hljs-keyword">Integer</span>&gt; cur, <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>)&#123;<br>        <span class="hljs-keyword">if</span>(node == null)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left == null &amp;&amp; node.right == null &amp;&amp; node.val + <span class="hljs-built_in">sum</span> == <span class="hljs-keyword">target</span>)&#123;<br>            cur.add(node.val);<br>            res.add(new ArrayList&lt;&gt;(cur));<br>            cur.remove(cur.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;            <br>        cur.add(node.val);<br>        dfs(node.left, cur, <span class="hljs-built_in">sum</span> + node.val, <span class="hljs-keyword">target</span>);<br>        dfs(node.right, cur, <span class="hljs-built_in">sum</span> + node.val, <span class="hljs-keyword">target</span>);<br>        cur.remove(cur.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//参数：中序遍历数组和后续遍历数组</span><br>    public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">postorder</span>)</span> &#123;<br>        <span class="hljs-comment">//获得分割结点</span><br>        <span class="hljs-built_in">int</span> in_length = inorder.length;<br>        <span class="hljs-built_in">int</span> post_length = postorder.length;<br><br>        <span class="hljs-comment">//判断是否为空结点</span><br>        <span class="hljs-keyword">if</span>(in_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>post_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-comment">//通过后续序列找到切割结点</span><br>        <span class="hljs-built_in">int</span> root_val = postorder<span class="hljs-literal">[<span class="hljs-identifier">post_length</span> - <span class="hljs-number">1</span>]</span>;<br>        <span class="hljs-comment">//构造根结点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历中序序列，找到切割结点在其中的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; in_length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root_val<span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                k = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//按照分割结点将中序序列和后续序列进行分割</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_post = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-comment">//递归调用函数</span><br>        root.left = build<span class="hljs-constructor">Tree(<span class="hljs-params">left_in</span>, <span class="hljs-params">left_post</span>)</span>;<br><br>        <span class="hljs-comment">//按照分割结点构造右子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">in_length</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_post = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>, <span class="hljs-params">k</span>, <span class="hljs-params">post_length</span> - 1)</span>;<br>        root.right = build<span class="hljs-constructor">Tree(<span class="hljs-params">right_in</span>, <span class="hljs-params">right_post</span>)</span>;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">preorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> pre_length = preorder.length;<br>        <span class="hljs-built_in">int</span> in_length = inorder.length;<br>        <span class="hljs-keyword">if</span>(pre_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>in_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> root_val = preorder<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <br>        <span class="hljs-comment">//得到左子树对应的前序和中序序列</span><br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; in_length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root_val<span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                k = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_pre = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>, 1, <span class="hljs-params">k</span> + 1)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        root.left = build<span class="hljs-constructor">Tree(<span class="hljs-params">left_pre</span>, <span class="hljs-params">left_in</span>)</span>;<br><br>        <span class="hljs-comment">//构造右子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_pre = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">pre_length</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">in_length</span>)</span>;<br>        root.right = build<span class="hljs-constructor">Tree(<span class="hljs-params">right_pre</span>, <span class="hljs-params">right_in</span>)</span>;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public TreeNode construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n_length = nums.length;<br>        <span class="hljs-keyword">if</span>(n_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> max_value = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//首先找到最大值和最大值对应的index</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max_value &lt; nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                max_value = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>                k = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建根结点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">max_value</span>)</span>;<br>        <br>        <span class="hljs-comment">//从根结点左边构造左子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">n_length</span>)</span>;<br>        root.left = construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">left_nums</span>)</span>;<br>        root.right = construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">right_nums</span>)</span>;<br><br>        return root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树（递归实现）"><a href="#617-合并二叉树（递归实现）" class="headerlink" title="617. 合并二叉树（递归实现）"></a>617. 合并二叉树（递归实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode <span class="hljs-built_in">left</span>;<br> *     TreeNode <span class="hljs-built_in">right</span>;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123;<br> *         this.val = val;<br> *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;<br> *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode huisu(TreeNode root1, TreeNode root2)&#123;<br>        <span class="hljs-keyword">if</span>(root1 == null)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root2 == null)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        root1.val += root2.val;<br>        root1.<span class="hljs-built_in">left</span> = huisu(root1.<span class="hljs-built_in">left</span>, root2.<span class="hljs-built_in">left</span>);<br>        root1.<span class="hljs-built_in">right</span> = huisu(root1.<span class="hljs-built_in">right</span>, root2.<span class="hljs-built_in">right</span>);<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;    <br>    <br>    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>        <span class="hljs-keyword">return</span> huisu(root1, root2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树（迭代实现）"><a href="#617-合并二叉树（迭代实现）" class="headerlink" title="617. 合并二叉树（迭代实现）"></a>617. 合并二叉树（迭代实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>        <span class="hljs-comment">//使用层序遍历迭代法</span><br>        <span class="hljs-keyword">if</span>(root1 <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root2 <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        <span class="hljs-comment">//使用层序遍历</span><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-comment">//加入root1</span><br>        que.offer(root1);<br>        <span class="hljs-comment">//加入root2</span><br>        que.offer(root2);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到两个队列中的结点</span><br>            TreeNode node1 <span class="hljs-operator">=</span> que.poll();<br>            TreeNode node2 <span class="hljs-operator">=</span> que.poll();<br><br>            <span class="hljs-comment">//将两个结点的val相加</span><br>            node1.<span class="hljs-keyword">val</span> <span class="hljs-operator">+=</span> node2.<span class="hljs-keyword">val</span>;<br><br>            <span class="hljs-comment">//将树的左结点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(node1.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node1.left);<br>                que.offer(node2.left);<br>            &#125;<br><br>            <span class="hljs-comment">//将树的右结点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(node1.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node1.right);<br>                que.offer(node2.right);<br>            &#125;<br><br>            <span class="hljs-comment">//如果node1的左节点为空直接将node2的左结点赋值给node1</span><br>            <span class="hljs-keyword">if</span>(node1.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                node1.left <span class="hljs-operator">=</span> node2.left;<br>            &#125;<br><br>            <span class="hljs-comment">//如果node1的右节点为空，将node2的有结点赋值给node1</span><br>            <span class="hljs-keyword">if</span>(node1.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                node1.right <span class="hljs-operator">=</span> node2.right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230610</title>
    <link href="/2023/06/17/my-leetcode-logs-20230617/"/>
    <url>/2023/06/17/my-leetcode-logs-20230617/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和（迭代法）"><a href="#404-左叶子之和（迭代法）" class="headerlink" title="404.左叶子之和（迭代法）"></a>404.左叶子之和（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//判断下一个结点是不是左叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                result <span class="hljs-operator">+=</span> node.left.<span class="hljs-keyword">val</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//按照右左中的顺序加入到stack中</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230610</title>
    <link href="/2023/06/10/my-leetcode-logs-20230610/"/>
    <url>/2023/06/10/my-leetcode-logs-20230610/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和（迭代法）"><a href="#404-左叶子之和（迭代法）" class="headerlink" title="404.左叶子之和（迭代法）"></a>404.左叶子之和（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//判断下一个结点是不是左叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                result <span class="hljs-operator">+=</span> node.left.<span class="hljs-keyword">val</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//按照右左中的顺序加入到stack中</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230607</title>
    <link href="/2023/06/07/my-leetcode-logs-20230607/"/>
    <url>/2023/06/07/my-leetcode-logs-20230607/</url>
    
    <content type="html"><![CDATA[<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">//二叉树层序遍历</span><br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt;&gt; result = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">//BFS搜索</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-built_in">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-comment">//借助队列实现</span><br>        <span class="hljs-built_in">Queue</span>&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//将第一个节点加入队列中</span><br>        <span class="hljs-built_in">queue</span>.offer(root);<br><br>        <span class="hljs-comment">//循环进行遍历</span><br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">queue</span>.isEmpty())&#123;<br>            <span class="hljs-comment">//设置内部的保存结点的list数组</span><br>            <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; tmp = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>            int size = <span class="hljs-built_in">queue</span>.size();<span class="hljs-comment">//获得tmp list的长度</span><br><br>            <span class="hljs-comment">//遍历当前所有的节点</span><br>            for(int i = <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>                <span class="hljs-comment">//弹出队列首结点</span><br>                TreeNode node = <span class="hljs-built_in">queue</span>.poll();<br>                <span class="hljs-comment">//向tmp list中添加弹出结点的val</span><br>                tmp.add(node.val);<br>                <span class="hljs-comment">//将左右结点加入到queue中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-built_in">null</span>)&#123;<br>                    <span class="hljs-built_in">queue</span>.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-built_in">null</span>)&#123;<br>                    <span class="hljs-built_in">queue</span>.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//将本次得到的结点list加入到最后的结果list中</span><br>            result.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（递归法）"><a href="#226-翻转二叉树（递归法）" class="headerlink" title="226.翻转二叉树（递归法）"></a>226.翻转二叉树（递归法）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode <span class="hljs-built_in">left</span>;<br> *     TreeNode <span class="hljs-built_in">right</span>;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123;<br> *         this.val = val;<br> *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;<br> *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode invertTree(TreeNode root) &#123;<br>        //使用递归<br>        <span class="hljs-keyword">if</span>(root == null)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        //交换root的左右结点<br>        TreeNode tmpNode = root.<span class="hljs-built_in">left</span>;<br>        root.<span class="hljs-built_in">left</span> = root.<span class="hljs-built_in">right</span>;<br>        root.<span class="hljs-built_in">right</span> = tmpNode;<br>        invertTree(root.<span class="hljs-built_in">left</span>);<br>        invertTree(root.<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（前序遍历迭代法）"><a href="#226-翻转二叉树（前序遍历迭代法）" class="headerlink" title="226.翻转二叉树（前序遍历迭代法）"></a>226.翻转二叉树（前序遍历迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode invertTree(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            <span class="hljs-comment">//弹出栈顶结点</span><br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//交换左右结点</span><br>            TreeNode tmp <span class="hljs-operator">=</span> node.left;<br>            node.left <span class="hljs-operator">=</span> node.right;<br>            node.right <span class="hljs-operator">=</span> tmp;<br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（统一迭代法，前序遍历实现）"><a href="#226-翻转二叉树（统一迭代法，前序遍历实现）" class="headerlink" title="226.翻转二叉树（统一迭代法，前序遍历实现）"></a>226.翻转二叉树（统一迭代法，前序遍历实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode invertTree(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用统一迭代法</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode curr = st.peek();<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出结点</span><br>                <span class="hljs-comment">//按照右中左进栈（前序遍历）</span><br>                <span class="hljs-keyword">if</span>(curr.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(curr.right);<br>                &#125;<br>                <span class="hljs-comment">//中结点入栈</span><br>                st.<span class="hljs-keyword">push</span>(curr);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(curr.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(curr.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//先弹出null结点</span><br>                curr = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//交换结点</span><br>                TreeNode tmp = curr.left;<br>                curr.left = curr.right;<br>                curr.right = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树（递归写法）"><a href="#101-对称二叉树（递归写法）" class="headerlink" title="101.对称二叉树（递归写法）"></a>101.对称二叉树（递归写法）</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//设置递归函数，传入参数分别为root的左右结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>        <span class="hljs-comment">//确定终止条件</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left == <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left.val != right.val)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//确定递归的内容</span><br>        <span class="hljs-comment">//传入为左节点的左子树和右节点的右子树</span><br>        <span class="hljs-keyword">boolean</span> outside = compare(left.left, right.right);<br>        <span class="hljs-comment">//传入为左节点的右子树和右节点的左子树</span><br>        <span class="hljs-keyword">boolean</span> inside = compare(left.right, right.left);<br>        <span class="hljs-keyword">boolean</span> eq = outside &amp;&amp; inside;<br>        <span class="hljs-keyword">return</span> eq;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">//使用递归实现</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">compare</span><span class="hljs-params">(root.left, root.right)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树（迭代写法，使用队列实现）"><a href="#101-对称二叉树（迭代写法，使用队列实现）" class="headerlink" title="101.对称二叉树（迭代写法，使用队列实现）"></a>101.对称二叉树（迭代写法，使用队列实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> boolean isSymmetric(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//使用迭代法进行遍历</span><br>        <span class="hljs-comment">//使用队列每次保存左右子树的同外侧结点和同内侧结点</span><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root.left);<br>        que.offer(root.right);<br><br>        <span class="hljs-comment">//while循环遍历que进行比较</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到que中的两个节点判断是否相同</span><br>            TreeNode leftNode <span class="hljs-operator">=</span> que.peek();<br>            que.poll();<br>            TreeNode rightNode <span class="hljs-operator">=</span> que.peek();<br>            que.poll();<br><br>            <span class="hljs-comment">//进行判断的逻辑</span><br>            <span class="hljs-keyword">if</span>(leftNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> rightNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                continue;<span class="hljs-comment">//表示两个结点都是空的，那么continue</span><br>            &#125;<br><br>            <span class="hljs-comment">//判断两个结点是否相同</span><br>            <span class="hljs-comment">// if(leftNode != null &amp;&amp; rightNode == null)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;else if(leftNode == null &amp;&amp; rightNode != null)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;else if(leftNode.val != rightNode.val)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;</span><br><br>            <span class="hljs-keyword">if</span>((leftNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> rightNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> (leftNode.<span class="hljs-keyword">val</span> <span class="hljs-operator">!=</span> rightNode.<span class="hljs-keyword">val</span>)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//然后将leftNode的左子树和rightNode的右子树加入到que中</span><br>            que.offer(leftNode.left);<br>            que.offer(rightNode.right);<br><br>            <span class="hljs-comment">//将leftNode的右子树和rightNode的左子树加入到que中</span><br>            que.offer(leftNode.right);<br>            que.offer(rightNode.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度（递归方法）"><a href="#104-二叉树的最大深度（递归方法）" class="headerlink" title="104.二叉树的最大深度（递归方法）"></a>104.二叉树的最大深度（递归方法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//递归方法</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> leftDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-built_in">int</span> rightDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>        <span class="hljs-built_in">int</span> maxDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftDepth, rightDepth);<br>        return maxDepth;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度（使用迭代法，队列实现层次遍历）"><a href="#104-二叉树的最大深度（使用迭代法，队列实现层次遍历）" class="headerlink" title="104.二叉树的最大深度（使用迭代法，队列实现层次遍历）"></a>104.二叉树的最大深度（使用迭代法，队列实现层次遍历）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDepth(TreeNode root) &#123;<br>        <span class="hljs-comment">//迭代法求二叉树深度</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxResult = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//设置队列存储结点</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-comment">//深度加1</span><br>            maxResult++;<br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">size</span>;i++)&#123;<br>                TreeNode node = que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559.N 叉树的最大深度"></a>559.N 叉树的最大深度</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-keyword">class</span> Node &#123;<br>    <span class="hljs-keyword">public</span> int <span class="hljs-keyword">val</span>;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> children;<br><br>    <span class="hljs-keyword">public</span> Node() &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> Node(int _val) &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> _val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node(int _val, List<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> _children) &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> _val;<br>        children <span class="hljs-operator">=</span> _children;<br>    &#125;<br>&#125;;<br><span class="hljs-operator">*/</span><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int maxDepth(Node root) &#123;<br>        <span class="hljs-comment">//使用迭代法+队列实现层次遍历</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义队列</span><br>        Queue<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            result<span class="hljs-operator">++</span>;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                Node node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br><br>                <span class="hljs-keyword">for</span>(int j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j <span class="hljs-operator">&lt;</span> node.children.size();j<span class="hljs-operator">++</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(node.children.<span class="hljs-built_in">get</span>(j) <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                        que.offer(node.children.<span class="hljs-built_in">get</span>(j));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度（使用递归法）"><a href="#111-二叉树的最小深度（使用递归法）" class="headerlink" title="111.二叉树的最小深度（使用递归法）"></a>111.二叉树的最小深度（使用递归法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">minDepth</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> leftDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">minDepth</span>)</span>;<br>        <span class="hljs-built_in">int</span> rightDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">minDepth</span>)</span>;<br><br>        <span class="hljs-keyword">if</span>(root.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>root.right<span class="hljs-operator"> == </span>null)&#123;<br>            minDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftDepth, rightDepth);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(leftDepth, rightDepth);<br>        &#125;<br>        return minDepth;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度（使用迭代法-队列实现层次遍历）"><a href="#111-二叉树的最小深度（使用迭代法-队列实现层次遍历）" class="headerlink" title="111.二叉树的最小深度（使用迭代法+队列实现层次遍历）"></a>111.二叉树的最小深度（使用迭代法+队列实现层次遍历）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int minDepth(TreeNode root) &#123;<br>        <span class="hljs-comment">//迭代法得到最小深度，使用队列实现</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            result<span class="hljs-operator">++</span>;<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数（使用层次遍历实现）"><a href="#222-完全二叉树的节点个数（使用层次遍历实现）" class="headerlink" title="222.完全二叉树的节点个数（使用层次遍历实现）"></a>222.完全二叉树的节点个数（使用层次遍历实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int countNodes(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        result<span class="hljs-operator">++</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    result<span class="hljs-operator">++</span>;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    result<span class="hljs-operator">++</span>;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（递归方法）"><a href="#110-平衡二叉树（递归方法）" class="headerlink" title="110.平衡二叉树（递归方法）"></a>110.平衡二叉树（递归方法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//使用递归方法</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Height(TreeNode <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">int</span> leftHeight = get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-keyword">if</span>(leftHeight<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//表示不满足平衡二叉树</span><br>        return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> rightHeight = get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>        <span class="hljs-keyword">if</span>(rightHeight<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftHeight, rightHeight);<br>        return result;<br>    &#125;<br>    public boolean is<span class="hljs-constructor">Balanced(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        return get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>)</span><span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> ? <span class="hljs-literal">false</span>: <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）"><a href="#110-平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）" class="headerlink" title="110.平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）"></a>110.平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义求以root结点作为根节点的最大高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getHeight(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> len = que.<span class="hljs-keyword">size</span>();<br>            result++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>                TreeNode node = que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalanced(TreeNode root) &#123;<br>        <span class="hljs-comment">//遍历的时候求当前左右节点的最大高度，然后求之间的差的绝对值，将该值和1比较</span><br>        <span class="hljs-comment">//外层使用二叉树的统一迭代遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//按照后序遍历方法</span><br>                st.<span class="hljs-keyword">push</span>(node);<span class="hljs-comment">//中</span><br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//添加进去之前需要判断是否为平衡树</span><br>                <span class="hljs-keyword">int</span> leftHeight = getHeight(node.left);<br>                <span class="hljs-keyword">int</span> rightHeight = getHeight(node.right);<br>                <span class="hljs-keyword">if</span>(Math.<span class="hljs-keyword">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//首先弹出标记用的空结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（递归得到树的最大高度-遍历当前结点判断该结点的左右子树高度差是否大于1）"><a href="#110-平衡二叉树（递归得到树的最大高度-遍历当前结点判断该结点的左右子树高度差是否大于1）" class="headerlink" title="110.平衡二叉树（递归得到树的最大高度+遍历当前结点判断该结点的左右子树高度差是否大于1）"></a>110.平衡二叉树（递归得到树的最大高度+遍历当前结点判断该结点的左右子树高度差是否大于1）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getHeight(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> leftHeight = getHeight(root.left);<br>        <span class="hljs-keyword">int</span> rightHeight = getHeight(root.right);<br>        <span class="hljs-keyword">int</span> maxDepth = <span class="hljs-number">1</span> + Math.max(leftHeight, rightHeight);<br>        <span class="hljs-keyword">return</span> maxDepth;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalanced(TreeNode root) &#123;<br>        <span class="hljs-comment">//遍历的时候求当前左右节点的最大高度，然后求之间的差的绝对值，将该值和1比较</span><br>        <span class="hljs-comment">//外层使用二叉树的统一迭代遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//按照后序遍历方法</span><br>                st.<span class="hljs-keyword">push</span>(node);<span class="hljs-comment">//中</span><br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//添加进去之前需要判断是否为平衡树</span><br>                <span class="hljs-keyword">int</span> leftHeight = getHeight(node.left);<br>                <span class="hljs-keyword">int</span> rightHeight = getHeight(node.right);<br>                <span class="hljs-keyword">if</span>(Math.<span class="hljs-keyword">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//首先弹出标记用的空结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用递归调用实现<br>    //参数分别为传入的结点，本次的单条路径，所有路径结果数组<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> travelTreeAllPath(TreeNode root, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;String&gt; result)&#123;<br>        //将中结点加入到<span class="hljs-type">path</span>中，这样才算遍历到了叶子结点<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        //递归条件，到叶子节点结束递归<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            //结束递归的时候将<span class="hljs-type">path</span>中对应的结果添加到result list中<br>            String path_str = &quot;&quot;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>;i++)&#123;<br>                path_str += String.valueOf(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i));<br>                path_str += &quot;-&gt;&quot;;<br>            &#125;<br>            path_str += <span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);<br>            //将当前结果加入到result list中<br>            result.<span class="hljs-keyword">add</span>(path_str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        //每次递归需要执行的代码<br>        //不是空结点才进行递归<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.left, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.right, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        travelTreeAllPath(root, <span class="hljs-type">path</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><br>//使用StringBuilder进行字符串的构造，效率提升很大<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用递归调用实现<br>    //参数分别为传入的结点，本次的单条路径，所有路径结果数组<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> travelTreeAllPath(TreeNode root, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;String&gt; result)&#123;<br>        //将中结点加入到<span class="hljs-type">path</span>中，这样才算遍历到了叶子结点<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        //递归条件，到叶子节点结束递归<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            //结束递归的时候将<span class="hljs-type">path</span>中对应的结果添加到result list中<br>            StringBuilder sb = <span class="hljs-built_in">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>;i++)&#123;<br>                sb.append(String.valueOf(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i)));<br>                sb.append(&quot;-&gt;&quot;);<br>            &#125;<br>            sb.append(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>));<br>            //将当前结果加入到result list中<br>            result.<span class="hljs-keyword">add</span>(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        //每次递归需要执行的代码<br>        //不是空结点才进行递归<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.left, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.right, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        travelTreeAllPath(root, <span class="hljs-type">path</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径（使用迭代方法实现）"><a href="#257-二叉树的所有路径（使用迭代方法实现）" class="headerlink" title="257.二叉树的所有路径（使用迭代方法实现）"></a>257.二叉树的所有路径（使用迭代方法实现）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public List&lt;String&gt; binary<span class="hljs-constructor">TreePaths(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-comment">//使用前序迭代法</span><br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return result;<br>        &#125;<br>        <span class="hljs-comment">//保存当前对应的tmp path</span><br>        Stack&lt;String&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//保存前序遍历时的树结点</span><br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        st.push(root);<br>        path.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span>);<br>        <span class="hljs-keyword">while</span>(!st.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            TreeNode node = st.peek<span class="hljs-literal">()</span>;<br>            st.pop<span class="hljs-literal">()</span>;<span class="hljs-comment">//弹出栈顶结点</span><br><br>            <span class="hljs-comment">//去除该节点对应的path</span><br>            String str = path.peek<span class="hljs-literal">()</span>;<br>            path.pop<span class="hljs-literal">()</span>;<br><br>            <span class="hljs-comment">//入栈之前先判断当前是否为叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>node.right<span class="hljs-operator"> == </span>null)&#123;<br>                <span class="hljs-comment">//将path放入到result数组中</span><br>                result.add(str);<br>            &#125;<br><br>            <span class="hljs-comment">//右左中顺序入栈</span><br>            <span class="hljs-keyword">if</span>(node.right != null)&#123;<br>                st.push(node.right);<br>                StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">str</span>)</span>;<br>                sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.append(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">node</span>.<span class="hljs-params">right</span>.<span class="hljs-params">val</span>)</span>);<br>                path.push(sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(node.left != null)&#123;<br>                st.push(node.left);<br>                StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">str</span>)</span>;<br>                sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.append(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">node</span>.<span class="hljs-params">left</span>.<span class="hljs-params">val</span>)</span>);<br>                path.push(sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="404-左叶子之和（使用迭代法）"><a href="#404-左叶子之和（使用迭代法）" class="headerlink" title="404.左叶子之和（使用迭代法）"></a>404.左叶子之和（使用迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//二叉树迭代遍历得到左右左叶子之和</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//判断条件需要重新理解</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span> &amp;&amp; node.left.left == <span class="hljs-keyword">null</span> &amp;&amp; node.left.right == <span class="hljs-keyword">null</span>)&#123;<br>                    result += node.left.val;<br>                &#125;<br>                <span class="hljs-comment">//按照右左中的顺序加入栈中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230605</title>
    <link href="/2023/06/05/my-leetcode-logs-20230605/"/>
    <url>/2023/06/05/my-leetcode-logs-20230605/</url>
    
    <content type="html"><![CDATA[<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义递归函数</span><br>    void preorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-comment">//将当前root节点的值存入到result中</span><br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br>    public List&lt;Integer&gt; preorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义后续遍历递归函数</span><br>    void tree<span class="hljs-constructor">PostOrderTraversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>    &#125;<br><br>    public List&lt;Integer&gt; postorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    void tree<span class="hljs-constructor">InorderTraversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br><br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br><br>    public List&lt;Integer&gt; inorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历（迭代方式）"><a href="#144-二叉树的前序遍历（迭代方式）" class="headerlink" title="144.二叉树的前序遍历（迭代方式）"></a>144.二叉树的前序遍历（迭代方式）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//非递归方式遍历二叉树</span><br>        <span class="hljs-comment">//定义一个保存节点值的栈</span><br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-comment">//定义返回的结果数组</span><br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <br>        st.add(root);<br>        <span class="hljs-comment">//while循环Stack栈，将其中的val添加到result数组中</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode tmpNode <span class="hljs-operator">=</span> st.pop();<br>            <span class="hljs-comment">//将当前节点加入到result中</span><br>            result.add(tmpNode.<span class="hljs-keyword">val</span>);<br>            <span class="hljs-comment">//然后将tmpNode节点的右节点现加入到st中</span><br>            <span class="hljs-keyword">if</span>(tmpNode.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(tmpNode.right);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(tmpNode.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(tmpNode.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历（迭代法）"><a href="#94-二叉树的中序遍历（迭代法）" class="headerlink" title="94.二叉树的中序遍历（迭代法）"></a>94.二叉树的中序遍历（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> inorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法得到二叉树的中序遍历节点值</span><br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        TreeNode curr <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">while</span>(curr <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> <span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            <span class="hljs-keyword">if</span>(curr <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(curr);<br>                curr <span class="hljs-operator">=</span> curr.left;<span class="hljs-comment">//得到左节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//表示左子树到底了，需要开始向result中添加节点值</span><br>                curr <span class="hljs-operator">=</span> st.pop();<span class="hljs-comment">//弹出节点</span><br>                result.add(curr.<span class="hljs-keyword">val</span>);<span class="hljs-comment">//将弹出的节点加入到result数组中</span><br>                curr <span class="hljs-operator">=</span> curr.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历（迭代法）"><a href="#145-二叉树的后序遍历（迭代法）" class="headerlink" title="145.二叉树的后序遍历（迭代法）"></a>145.二叉树的后序遍历（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> postorderTraversal(TreeNode root) &#123;<br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.pop();<br>            result.add(node.<span class="hljs-keyword">val</span>);<br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        Collections.reverse(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历（统一迭代法）"><a href="#144-二叉树的前序遍历（统一迭代法）" class="headerlink" title="144.二叉树的前序遍历（统一迭代法）"></a>144.二叉树的前序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//统一模板进行二叉树遍历</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//判断右节点是否为空，不为空加入到stack中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果遇到节点为null，首先弹出null节点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<span class="hljs-comment">//弹出不是null的节点（标记的结点）</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                result.add(node.val);<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历（统一迭代法）"><a href="#94-二叉树的中序遍历（统一迭代法）" class="headerlink" title="94.二叉树的中序遍历（统一迭代法）"></a>94.二叉树的中序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//将右节点添加到st中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br><br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//弹出空节点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出被标记节点</span><br>                result.add(node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历（统一迭代法）"><a href="#145-二叉树的后序遍历（统一迭代法）" class="headerlink" title="145.二叉树的后序遍历（统一迭代法）"></a>145.二叉树的后序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//先将中间节点放进st中</span><br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//再将右节点放入stack中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左节点放入stack中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//弹出null结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>                result.add(node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230604</title>
    <link href="/2023/06/04/my-leetcode-logs-20230604/"/>
    <url>/2023/06/04/my-leetcode-logs-20230604/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针相关题目"><a href="#双指针相关题目" class="headerlink" title="双指针相关题目"></a>双指针相关题目</h1><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-keyword">val</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125;<br>            fast++;<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>双指针法中出现的题目均为前边几个章节中已经出现过的，这里就不再赘述，可以查看本人之前的博客进行学习。</em></p><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;<br><br>    <span class="hljs-comment">//定义两个栈</span><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        <span class="hljs-comment">//调用得到stackOut</span><br>        isStackOut();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>()</span> &#123;<br>        isStackOut();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">//判断stackOut是否为空，如果是空的，直接将stackIn中的元素放到stackOut中</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isStackOut</span>()</span>&#123;<br>        <span class="hljs-comment">//如果栈不是空的</span><br>        <span class="hljs-keyword">if</span>(!stackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>            stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;<br><br>    Queue&lt;Integer&gt; q1;<br>    Queue&lt;Integer&gt; q2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span>()</span> &#123;<br>        q1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        q2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        <span class="hljs-comment">//先放在q2辅助队列中，为了保证最后进入的元素最先出来</span><br>        q2.offer(x);<br>        <span class="hljs-comment">//将q1队列中的其他元素加入到q2中</span><br>        <span class="hljs-keyword">while</span>(!q1.isEmpty())&#123;<br>            q2.offer(q1.poll());<br>        &#125;<br>        <span class="hljs-comment">//最后将q2和q1进行交换</span><br>        Queue&lt;Integer&gt; qTemp = q1;<br>        q1 = q2;<br>        q2 = qTemp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.poll();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">top</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化栈</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dict用于表示匹配关系</span><br>        Map&lt;Character, Character&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.<span class="hljs-built_in">toCharArray</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">containsKey</span>(ch)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果此时栈为空，那么表示此时符号进栈之后不可能再找到与之匹配的符号，直接返回false；</span><br>                <span class="hljs-comment">//或者栈不为空，但是此时即将入栈的符号和栈顶的符号不匹配，也直接返回false即可；</span><br>                <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>() || dict.<span class="hljs-built_in">get</span>(stack.<span class="hljs-built_in">pop</span>()) != ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">isEmpty</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化定义栈</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stack</span>&lt;Character&gt;();<br><br>        <span class="hljs-keyword">for</span>(Character ch : s.<span class="hljs-built_in">toCharArray</span>())&#123;<br>            <span class="hljs-comment">//判断栈顶元素是否和当前元素相同，相同同时都删除</span><br>            <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">isEmpty</span>() &amp;&amp; stack.<span class="hljs-built_in">peek</span>() == ch)&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//最终得到stack中的字符串</span><br>        <span class="hljs-type">String</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">isEmpty</span>())&#123;<br>            result = stack.<span class="hljs-built_in">pop</span>() + result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//优化版本，使用了StringBuilder加快了代码执行的效率</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.<span class="hljs-built_in">toCharArray</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!stack.<span class="hljs-built_in">isEmpty</span>() &amp;&amp; stack.<span class="hljs-built_in">peek</span>() == ch) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            sb.<span class="hljs-built_in">append</span>(stack.<span class="hljs-built_in">pop</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">toString</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> eval<span class="hljs-constructor">RPN(String[] <span class="hljs-params">tokens</span>)</span> &#123;<br>        <span class="hljs-comment">//定义保存符号的Stack</span><br>        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        Map&lt;String, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        dict.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">1</span>);<br>        dict.put(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">2</span>);<br>        dict.put(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">3</span>);<br>        dict.put(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">for</span>(String str : tokens)&#123;<br>            <span class="hljs-keyword">if</span>(dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">str</span>)</span>)&#123;<br>                <span class="hljs-built_in">int</span> second = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>                <span class="hljs-built_in">int</span> first = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>                <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>                    result = first + second;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">2</span>)&#123;<br>                    result = first - second;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">3</span>)&#123;<br>                    result = first<span class="hljs-operator"> * </span>second;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    result = first<span class="hljs-operator"> / </span>second;<br>                &#125;<br>                stack.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">result</span>)</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.push(str);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//优化之后的代码</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> eval<span class="hljs-constructor">RPN(String[] <span class="hljs-params">tokens</span>)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinkedList()</span>;<br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="hljs-comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br>                stack.push(stack.pop<span class="hljs-literal">()</span> + stack.pop<span class="hljs-literal">()</span>);      <span class="hljs-comment">// 注意 - 和/ 需要特殊处理</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(s)) &#123;<br>                stack.push(-stack.pop<span class="hljs-literal">()</span> + stack.pop<span class="hljs-literal">()</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(s)) &#123;<br>                stack.push(stack.pop<span class="hljs-literal">()</span><span class="hljs-operator"> * </span>stack.pop<span class="hljs-literal">()</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/&quot;</span>.equals(s)) &#123;<br>                <span class="hljs-built_in">int</span> temp1 = stack.pop<span class="hljs-literal">()</span>;<br>                <span class="hljs-built_in">int</span> temp2 = stack.pop<span class="hljs-literal">()</span>;<br>                stack.push(temp2<span class="hljs-operator"> / </span>temp1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">s</span>)</span>);<br>            &#125;<br>        &#125;<br>        return stack.pop<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义自己实现的一个基于双端队列的单调队列类</span><br><span class="hljs-keyword">class</span> MyQueue&#123;<br>    Deque&lt;Integer&gt; dequeue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">//设置poll方法</span><br>    void poll(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-comment">//移除的时候判断当前移除的元素是否和队列的头部相同，相同则弹出</span><br>        <span class="hljs-keyword">if</span>(!dequeue.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>dequeue.peek<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)&#123;<br>            dequeue.poll<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置的add方法</span><br>    <span class="hljs-comment">//add的时候需要判断和当前队列中的元素的大小关系，需要维持递减的顺序</span><br>    void add(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">while</span>(!dequeue.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>dequeue.get<span class="hljs-constructor">Last()</span> &lt; <span class="hljs-keyword">val</span>)&#123;<br>            dequeue.remove<span class="hljs-constructor">Last()</span>;<span class="hljs-comment">//移除最后的元素</span><br>        &#125;<br>        <span class="hljs-comment">//增加到队列中</span><br>        dequeue.add(<span class="hljs-keyword">val</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获得队列头部元素值</span><br>    <span class="hljs-built_in">int</span> peek<span class="hljs-literal">()</span>&#123;<br>        return dequeue.peek<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> max<span class="hljs-constructor">SlidingWindow(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>            return nums;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> len = nums.length -k + <span class="hljs-number">1</span>;<span class="hljs-comment">//定义最后结果数组的长度</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置的结果数组对应的index索引值</span><br><br>        MyQueue myqueue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyQueue()</span>;<br><br>        <span class="hljs-comment">//先将前k个元素放入队列中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            myqueue.add(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//得到第一个前k个元素中最大值</span><br>        result<span class="hljs-literal">[<span class="hljs-identifier">index</span><span class="hljs-operator">++</span>]</span> = myqueue.peek<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">//循环遍历后边的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-comment">//滑动窗口往后移动一格，首先判断队列中的第一个元素是否需要弹出</span><br>            myqueue.poll(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-identifier">k</span>]</span>);<br>            <span class="hljs-comment">//然后判断，增加的元素是否需要到达队顶</span><br>            myqueue.add(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>            <span class="hljs-comment">//记录最大值</span><br>            result<span class="hljs-literal">[<span class="hljs-identifier">index</span><span class="hljs-operator">++</span>]</span> = myqueue.peek<span class="hljs-literal">()</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> top<span class="hljs-constructor">KFrequent(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">//key为元素，value为元素出现的频率</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i: nums)&#123;<br>            map.put(i, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">i</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//按照map的value进行排序</span><br>        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; sortedList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.entry<span class="hljs-constructor">Set()</span>);<br>        <span class="hljs-comment">// 使用 Comparator 和流式操作按照 value 进行降序排序</span><br>        sortedList.sort(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Map</span>.</span><span class="hljs-module"><span class="hljs-identifier">Entry</span>.</span></span>comparing<span class="hljs-constructor">ByValue(Comparator.<span class="hljs-params">reverseOrder</span>()</span>));<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i ++)&#123;<br>            result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sortedList.get(i).get<span class="hljs-constructor">Key()</span>;    <br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//使用小顶堆实现</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> top<span class="hljs-constructor">KFrequent(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">//保存key-value对应的字典</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> num: nums)&#123;<br>            map.put(num, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">num</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//创建优先级队列</span><br>        <span class="hljs-comment">//后边设置插入的顺序为构建小顶堆</span><br>        PriorityQueue&lt;<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair1<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>-pair2<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>);<br>        <br>        <span class="hljs-comment">//遍历map，开始插入</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entry<span class="hljs-constructor">Set()</span>)&#123;<br>            <span class="hljs-comment">//首先，判断小顶堆中元素个数，如果小于k，直接插入即可</span><br>            <span class="hljs-keyword">if</span>(pq.size<span class="hljs-literal">()</span> &lt; k)&#123;<br>                pq.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;entry.get<span class="hljs-constructor">Key()</span>, entry.get<span class="hljs-constructor">Value()</span>&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//判断当前准备插入的元素对是否大于当前顶点，如果是，删除顶点，然后直接插入当前节点</span><br>                <span class="hljs-keyword">if</span>(entry.get<span class="hljs-constructor">Value()</span> &gt; pq.peek<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>)&#123;<br>                    <span class="hljs-comment">//先弹出顶点元素</span><br>                    pq.poll<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">//然后插入</span><br>                    pq.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;entry.get<span class="hljs-constructor">Key()</span>, entry.get<span class="hljs-constructor">Value()</span>&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建返回数组结果</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>        <span class="hljs-comment">//循环pq队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = pq.poll<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>双指针</tag>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230602</title>
    <link href="/2023/06/02/my-leetcode-logs-20230602/"/>
    <url>/2023/06/02/my-leetcode-logs-20230602/</url>
    
    <content type="html"><![CDATA[<h2 id="459-重复的子字符串（需要不定时回顾，使用了KMP算法）"><a href="#459-重复的子字符串（需要不定时回顾，使用了KMP算法）" class="headerlink" title="459.重复的子字符串（需要不定时回顾，使用了KMP算法）"></a>459.重复的子字符串（需要不定时回顾，使用了KMP算法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//得到前缀表的函数</span><br>    void get<span class="hljs-constructor">Next(<span class="hljs-params">int</span>[] <span class="hljs-params">next</span>, String <span class="hljs-params">s</span>)</span>&#123;<br>        next<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                j = next<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>;<br>            &#125;<br>            <span class="hljs-comment">//判断字符串s中对应位置为i和j是否包含相等的字符</span><br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                j++;<br>            &#125;<br>            next<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = j;<br>        &#125;<br>    &#125;<br><br>    public boolean repeated<span class="hljs-constructor">SubstringPattern(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">//使用KMP字符串匹配算法实现</span><br>        <span class="hljs-keyword">if</span>(s.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//构造长度为s.length()的next数组</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">s</span>.<span class="hljs-identifier">length</span>()]</span>;<br>        get<span class="hljs-constructor">Next(<span class="hljs-params">next</span>, <span class="hljs-params">s</span>)</span>;<br>        <span class="hljs-built_in">int</span> len = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(next<span class="hljs-literal">[<span class="hljs-identifier">len</span> - <span class="hljs-number">1</span>]</span> != <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>len % (len - next<span class="hljs-literal">[<span class="hljs-identifier">len</span> - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>字符串处理相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230601</title>
    <link href="/2023/06/01/my-leetcode-logs-20230601/"/>
    <url>/2023/06/01/my-leetcode-logs-20230601/</url>
    
    <content type="html"><![CDATA[<h2 id="350-两个数组的交集"><a href="#350-两个数组的交集" class="headerlink" title="350.两个数组的交集"></a>350.两个数组的交集</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] <span class="hljs-keyword">intersect</span>(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span>[] record1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-type">int</span>[] record2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br><br>        <span class="hljs-type">int</span> nums1Length = nums1.length;<br>        <span class="hljs-type">int</span> nums2Length = nums2.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1Length;i++)&#123;<br>            record1[nums1[i]]++; <br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; nums2Length;i++)&#123;<br>            record2[nums2[i]]++;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; tmp = <span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        <br>        <span class="hljs-type">int</span> n = Math.max(record1.length, record2.length);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(record1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; record2[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> m = Math.min(record1[i], record2[i]);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>                    tmp.<span class="hljs-keyword">add</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[tmp.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.size();i++)&#123;<br>            result[i] = tmp.<span class="hljs-keyword">get</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//得到数字n的每个位置上的数字平方和</span><br>    <span class="hljs-built_in">int</span> getSum(<span class="hljs-built_in">int</span> n)&#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">sum</span> += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isHappy(<span class="hljs-built_in">int</span> n) &#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-built_in">int</span> currSum = getSum(n);<br>            <span class="hljs-keyword">if</span>(currSum == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(dict.containsKey(currSum) &amp;&amp; dict.get(currSum) != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dict.put(currSum, <span class="hljs-number">1</span>);<br>            &#125;<br>            n = currSum;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums2.length;j++)&#123;<br>                map.<span class="hljs-built_in">put</span>(nums1[i] + nums2[j], map.<span class="hljs-built_in">getOrDefault</span>(nums1[i] + nums2[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums3.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums4.length;j++)&#123;<br>                count += map.<span class="hljs-built_in">getOrDefault</span>(<span class="hljs-number">0</span> - (nums3[i] + nums4[j]), <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//首先对nums进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//判断第一个nums是否为大于0，如果是直接返回空的list</span><br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br><br>        <span class="hljs-comment">//然后使用双指针循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-comment">//从i=1开始，判断当前元素和前一个元素是否相同，相同直接跳过</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//然后使用双指针</span><br>            <span class="hljs-built_in">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//当left&lt;right时进入循环</span><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-comment">//判断三者之和与0的大小关系</span><br>                <span class="hljs-comment">//当三者之和大于0时，right--</span><br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//三者之和等于0，那么作为一个结果添加到result中</span><br>                    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    tmp.<span class="hljs-keyword">add</span>(nums[i]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[left]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[right]);<br>                    result.<span class="hljs-keyword">add</span>(tmp);<span class="hljs-comment">//将当前的结果list添加到result中</span><br><br>                    <span class="hljs-comment">//然后去除和left/right重复的元素</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br><br>                    left++;<span class="hljs-comment">//左指针向右++</span><br>                    right--;<span class="hljs-comment">//右指针向左--</span><br>                    <br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;i ++)&#123;<br>            <span class="hljs-comment">//进行剪枝处理</span><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-keyword">target</span> &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//进入第二层循环</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length;j++)&#123;<br>                <span class="hljs-comment">//剪枝</span><br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; <span class="hljs-keyword">target</span> &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//对j进行去重</span><br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//准备使用双指针</span><br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i] + nums[j] + nums[left] + nums[right] &gt; <span class="hljs-keyword">target</span>)&#123;<br>                        right--;<br>                    &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[i] + nums[j] + nums[left] + nums[right] &lt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                        left++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        tmp.add(nums[i]);<br>                        tmp.add(nums[j]);<br>                        tmp.add(nums[left]);<br>                        tmp.add(nums[right]);<br>                        result.add(tmp);<br><br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                            right--;<br>                        &#125;<br><br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                            left++;<br>                        &#125;<br><br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public void reverseString(<span class="hljs-built_in">char</span>[] s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = s.length - <span class="hljs-number">1</span>;<br><br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">char</span> tmp = s[<span class="hljs-built_in">left</span>];<br>            s[<span class="hljs-built_in">left</span>] = s[<span class="hljs-built_in">right</span>];<br>            s[<span class="hljs-built_in">right</span>] = tmp;<br>            <span class="hljs-built_in">left</span>++;<br>            <span class="hljs-built_in">right</span>--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541.反转字符串 II"></a>541.反转字符串 II</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-type">void</span> reverse(<span class="hljs-type">char</span>[] s_char, <span class="hljs-type">int</span> <span class="hljs-keyword">begin</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-type">char</span> tmp = s_char[<span class="hljs-keyword">end</span>];<br>            s_char[<span class="hljs-keyword">end</span>] = s_char[<span class="hljs-keyword">begin</span>];<br>            s_char[<span class="hljs-keyword">begin</span>] = tmp;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> String reverseStr(String s, <span class="hljs-type">int</span> k) &#123;<br>        //将String字符串转换为<span class="hljs-type">char</span>数组<br>        <span class="hljs-type">char</span>[] s_char = s.toCharArray();<br>        <span class="hljs-type">int</span> n = s.length();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(;i &lt; n;i = i + <span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-type">int</span> start = i;<br>            <span class="hljs-type">int</span> end = Math.min(n - <span class="hljs-number">1</span>, <span class="hljs-keyword">start</span> + k - <span class="hljs-number">1</span>);<br>            reverse(s_char, <span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(s_char);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String replace<span class="hljs-constructor">Space(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s<span class="hljs-operator"> == </span>null)&#123;<br>            return null;<br>        &#125;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>            &#125;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br><br>    void reverse<span class="hljs-constructor">String(StringBuilder <span class="hljs-params">sb</span>, <span class="hljs-params">int</span> <span class="hljs-params">begin</span>, <span class="hljs-params">int</span> <span class="hljs-params">end</span>)</span>&#123;<br>        <span class="hljs-comment">//然后反转字符串</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-built_in">char</span> tmp = sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">begin</span>)</span>;<br>            sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">begin</span>, <span class="hljs-params">sb</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">end</span>)</span>);<br>            sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">end</span>, <span class="hljs-params">tmp</span>)</span>;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span>--;<br>        &#125;<br>    &#125;<br><br>    public String reverse<span class="hljs-constructor">Words(String <span class="hljs-params">s</span>)</span> &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-comment">//先删除字符串中前边或后边的空格</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = s.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-comment">//去除字符串中间多余的空格</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span> != <span class="hljs-character">&#x27; &#x27;</span><span class="hljs-operator"> || </span>sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">sb</span>.<span class="hljs-params">length</span>()</span> - <span class="hljs-number">1</span>) != <span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>);<br>            &#125;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">begin</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = sb.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>, <span class="hljs-params">begin</span>, <span class="hljs-params">end</span>)</span>;<br><br>        <span class="hljs-comment">//反转字符串之后，反转字符串中每个单词</span><br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> inner_end = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> n = sb.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; n)&#123;<br>            <span class="hljs-keyword">while</span>(inner_end &lt; n<span class="hljs-operator"> &amp;&amp; </span>sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">inner_end</span>)</span> != <span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                inner_end++;<br>            &#125;<br>            <span class="hljs-comment">//反转从start到end的字符串</span><br>            reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>, <span class="hljs-params">start</span>, <span class="hljs-params">inner_end</span> - 1)</span>;<br>            <span class="hljs-comment">//然后进入下一个单词</span><br>            start = inner_end + <span class="hljs-number">1</span>;<br>            inner_end = start + <span class="hljs-number">1</span>;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String reverse<span class="hljs-constructor">LeftWords(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> l = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//得到实际左旋转的格数</span><br>        <span class="hljs-built_in">int</span> k = n % l;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k;i &lt; l;i++)&#123;<br>            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>        &#125;<br><br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a>28.找出字符串中第一个匹配项的下标</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> str<span class="hljs-constructor">Str(String <span class="hljs-params">haystack</span>, String <span class="hljs-params">needle</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack.length<span class="hljs-literal">()</span> &lt; needle.length<span class="hljs-literal">()</span>) return -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length<span class="hljs-literal">()</span>)&#123;<br>            <span class="hljs-comment">//每次设置j从0开始</span><br>            j = <span class="hljs-number">0</span>;<br>            result = i;<br>            <span class="hljs-comment">//判断是否成功，成功直接返回true，否则返回false</span><br>            <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                <span class="hljs-keyword">while</span>(j &lt; needle.length<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>i &lt; haystack.length<span class="hljs-literal">()</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                        i++;<br>                        j++;<br>                        continue;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        break;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-operator"> == </span>needle.length<span class="hljs-literal">()</span>)&#123;<br>                    return result;<br>                &#125;<br>            &#125;<br>            i = result + <span class="hljs-number">1</span>;<br>        &#125;<br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230531</title>
    <link href="/2023/05/31/my-leetcode-logs-20230531/"/>
    <url>/2023/05/31/my-leetcode-logs-20230531/</url>
    
    <content type="html"><![CDATA[<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//慢指针每次走一步</span><br>            slow = slow.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//快指针每次走两步</span><br>            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//如果两个指针相遇，那么一个指针从相遇结点出发，一个指针从头节点出发，等到下次两个节点相遇的时候就是链表环形入口结点</span><br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                ListNode index1 = fast;<br>                ListNode index2 = head;<br>                <span class="hljs-keyword">while</span>(index1 != index2)&#123;<br>                    index1 = index1.<span class="hljs-keyword">next</span>;<br>                    index2 = index2.<span class="hljs-keyword">next</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD##"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>##</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> isAnagram(String s, String t) &#123;<br>        //设置<span class="hljs-type">record</span>数组的长度大小为<span class="hljs-number">26</span>（<span class="hljs-number">26</span>个小写字母）<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; s.length();i++)&#123;<br>            <span class="hljs-type">record</span>[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; t.length();i++)&#123;<br>            <span class="hljs-type">record</span>[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> canConstruct(String ransomNote, String magazine) &#123;<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.length();i++)&#123;<br>            <span class="hljs-type">record</span>[ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; magazine.length();i++)&#123;<br>            <span class="hljs-type">record</span>[magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        //数组作为map<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length;i++)&#123;<br>            //map只记录是否有，并不需要记录每个key值对应的<span class="hljs-keyword">values</span>数量<br>            <span class="hljs-type">record</span>[nums1[i]] = <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[nums2[i]] == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">record</span>[nums2[i]] = <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; tmpList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;(); <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] == <span class="hljs-number">3</span>)&#123;<br>                tmpList.<span class="hljs-keyword">add</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[tmpList.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: tmpList)&#123;<br>            result[<span class="hljs-keyword">index</span>] = tmpList.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">index</span>);<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>0faf98f2fe074769adf459ed307fb014a35a9876</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230528</title>
    <link href="/2023/05/28/my-leetcode-logs-20230528/"/>
    <url>/2023/05/28/my-leetcode-logs-20230528/</url>
    
    <content type="html"><![CDATA[<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode removeElements(ListNode head, int val) &#123;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>();<br>        ListNode resultHead = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = head;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val != val)&#123;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = head;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> resultHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义链表的结点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br>     int <span class="hljs-keyword">val</span>;<span class="hljs-comment">//定义链表中的值</span><br>     ListNode next;<br>     <span class="hljs-comment">//创建构造函数</span><br>     ListNode()&#123;&#125;<br>     <span class="hljs-comment">//创建自定义构造函数</span><br>     ListNode(int <span class="hljs-keyword">val</span>)&#123;<br>         <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>    <span class="hljs-comment">//定义链表的成员变量</span><br>    int size;<br>    <span class="hljs-comment">//定义一个虚拟的头结点</span><br>    ListNode head;<br><br>    <span class="hljs-comment">//在默认构造函数中初始化链表</span><br>    <span class="hljs-keyword">public</span> MyLinkedList() &#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.head = new ListNode(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> int <span class="hljs-keyword">get</span>(int index) &#123;<br>        <span class="hljs-comment">//首先判断index是否无效，如果无效返回-1</span><br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        ListNode resultNode = <span class="hljs-keyword">this</span>.head;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt;= index;i ++)&#123;<br>            resultNode = resultNode.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode.<span class="hljs-keyword">val</span>; <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtHead(int <span class="hljs-keyword">val</span>) &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, <span class="hljs-keyword">val</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtTail(int <span class="hljs-keyword">val</span>) &#123;<br>        addAtIndex(<span class="hljs-keyword">this</span>.size, <span class="hljs-keyword">val</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtIndex(int index, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-keyword">this</span>.size)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>            index = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.size++;<br><br>        ListNode predNode = <span class="hljs-keyword">this</span>.head;<br>        <span class="hljs-comment">//得到predNode（要插入结点的前驱）</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; index;i++)&#123;<br>            predNode = predNode.next;<br>        &#125;<br><br>        ListNode addNode = new ListNode(<span class="hljs-keyword">val</span>);<br>        addNode.next = predNode.next;<br>        predNode.next = addNode;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void deleteAtIndex(int index) &#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-keyword">this</span>.size || index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.size--;<br>        <span class="hljs-comment">//判断index是否为0</span><br>        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode predNode = head;<br>        <span class="hljs-comment">//找到需要删除结点的前驱结点</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; index;i++)&#123;<br>            predNode = predNode.next;<br>        &#125;<br><br>        predNode.next = predNode.next.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj.get(index);</span><br><span class="hljs-comment"> * obj.addAtHead(val);</span><br><span class="hljs-comment"> * obj.addAtTail(val);</span><br><span class="hljs-comment"> * obj.addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> singly<span class="hljs-operator">-</span>linked list.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     ListNode next;<br> <span class="hljs-operator">*</span>     ListNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>, ListNode next) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; this.next <span class="hljs-operator">=</span> next; &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;<br>        ListNode currNode <span class="hljs-operator">=</span> head;<br>        ListNode resultNode <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        ListNode tmpNode <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span>(currNode <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            tmpNode <span class="hljs-operator">=</span> currNode.next;<br>            currNode.next <span class="hljs-operator">=</span> resultNode;<br>            resultNode <span class="hljs-operator">=</span> currNode;<br>            currNode <span class="hljs-operator">=</span> tmpNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-两两交换链表中的结点"><a href="#24-两两交换链表中的结点" class="headerlink" title="24.两两交换链表中的结点"></a>24.两两交换链表中的结点</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;<br>        ListNode xuniHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        xuniHead.<span class="hljs-keyword">next</span> = head;<br>        ListNode curr = xuniHead;<br><br>        <span class="hljs-keyword">while</span>(curr.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp = curr.<span class="hljs-keyword">next</span>;<br>            ListNode tmp1 = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>            curr.<span class="hljs-keyword">next</span> = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = tmp;<br>            curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = tmp1;<br><br>            curr = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> xuniHead.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy.<span class="hljs-keyword">next</span> = head;<br>        ListNode fast = dummy;<br>        ListNode slow = dummy;<br><br>        <span class="hljs-comment">//先移动快指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            fast = fast.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//同时移动快慢指针</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.<span class="hljs-keyword">next</span>;<br>            slow = slow.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;<br>        ListNode currA = headA;<br>        ListNode currB = headB;<br>        <span class="hljs-built_in">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> lenB = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(currA != <span class="hljs-literal">null</span>)&#123;<br>            currA = currA.<span class="hljs-keyword">next</span>;<br>            lenA++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(currB != <span class="hljs-literal">null</span>)&#123;<br>            currB = currB.<span class="hljs-keyword">next</span>;<br>            lenB++;<br>        &#125;<br><br>        currA = headA;<br>        currB = headB;<br><br>        <span class="hljs-comment">//使得currA指向较长链表的那个</span><br>        <span class="hljs-keyword">if</span>(lenA &lt; lenB)&#123;<br>            <span class="hljs-built_in">int</span> tmpL = lenA;<br>            lenA = lenB;<br>            lenB = tmpL;<br>            <br>            ListNode tmpNode = currA;<br>            currA = currB;<br>            currB = tmpNode;<br>        &#125;<br><br>        <span class="hljs-comment">//求两者的长度差</span><br>        <span class="hljs-built_in">int</span> gap = lenA - lenB;<br><br>        <span class="hljs-comment">//然后使得较长的指针移动到较短的链表的尾部位置</span><br>        <span class="hljs-keyword">while</span>(gap-- &gt; <span class="hljs-number">0</span>)&#123;<br>            currA = currA.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//同时移动两个链表的指针</span><br>        <span class="hljs-keyword">while</span>(currA != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(currA == currB)&#123;<br>                <span class="hljs-keyword">return</span> currA;<br>            &#125;<br><br>            currA = currA.<span class="hljs-keyword">next</span>;<br>            currB = currB.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230527</title>
    <link href="/2023/05/27/my-leetcode-logs-20230527/"/>
    <url>/2023/05/27/my-leetcode-logs-20230527/</url>
    
    <content type="html"><![CDATA[<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[][] generateMatrix(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-comment">//定义一个动态增加的list，最后转换为int即可</span><br>        <span class="hljs-built_in">int</span>[][] matrixResult = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n][n];<br><br>        <span class="hljs-comment">//设置给每个格子赋值的值</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始值设置为1</span><br>        <span class="hljs-built_in">int</span> offset = <span class="hljs-number">1</span>;<span class="hljs-comment">//设置的每圈应该在右开的时候减少的偏移量</span><br>        <span class="hljs-built_in">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> loop = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> mid = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(loop &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-comment">//上行：从左到右进行填充</span><br>            <span class="hljs-keyword">for</span>(j = startY;j &lt; n - offset;j++)&#123;<br>                matrixResult[startX][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-comment">//右列：从上到下及逆行填充</span><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; n - offset; i++)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; j &gt; startY;j--)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; i &gt; startX;i--)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-comment">//将对应的startX和startY进行更新</span><br>            startX++;<br>            startY++;<br><br>            offset++;<br>            loop--;<br>        &#125;<br><br>        <span class="hljs-comment">//最后判断是否需要填充中心位置的元素</span><br>        <span class="hljs-comment">//也就是n为奇数时需要填充</span><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            matrixResult[mid][mid] = <span class="hljs-keyword">count</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrixResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.length;<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">loop</span> = Math.min(m, n) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">loop</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>;j++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>;i++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(;j &gt; startY; j<span class="hljs-comment">--)&#123;</span><br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(;i &gt; startX;i<span class="hljs-comment">--)&#123;</span><br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            startX++;<br>            startY++;<br>            <span class="hljs-keyword">offset</span>++;<br><br>            <span class="hljs-keyword">loop</span> <span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(result.size() == n * m)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <br>        //添加<br>        <span class="hljs-keyword">if</span>(m &gt; n)&#123;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>;i++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][startY]);<br>            &#125;<br>            result.<span class="hljs-keyword">add</span>(matrix[i][startY]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[startX][j]);<br>            &#125;<br>            result.<span class="hljs-keyword">add</span>(matrix[startX][j]);        <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; n == m)&#123;<br>            result.<span class="hljs-keyword">add</span>(matrix[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指offer29-顺时针打印矩阵"><a href="#剑指offer29-顺时针打印矩阵" class="headerlink" title="剑指offer29.顺时针打印矩阵"></a>剑指offer29.顺时针打印矩阵</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.length;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m*n];<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">loop</span> = Math.min(m, n) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">loop</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j ++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>; i ++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; j &gt; startY; j<span class="hljs-comment">--)&#123;</span><br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; i &gt; startX; i<span class="hljs-comment">--)&#123;</span><br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            startX++;<br>            startY++;<br>            <span class="hljs-keyword">offset</span>++;<br>            <span class="hljs-keyword">loop</span><span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> == m*n)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;here&quot;);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(m &gt; n)&#123;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>; i++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][startY];<br>            &#125;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[m - <span class="hljs-keyword">offset</span>][startY];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[startX][j];<br>            &#125;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[startX][n - <span class="hljs-keyword">offset</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == n &amp;&amp; m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[m / <span class="hljs-number">2</span>][m / <span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230525</title>
    <link href="/2023/05/25/my-leetcode-logs-20230525/"/>
    <url>/2023/05/25/my-leetcode-logs-20230525/</url>
    
    <content type="html"><![CDATA[<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//滑动窗口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> target, <span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">1000000001</span>;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">sum</span> &gt;= target)&#123;<br>                <span class="hljs-built_in">int</span> in_result = (i - start) + <span class="hljs-number">1</span>;<br>                result = result &lt; in_result ? result : in_result;<br>                <span class="hljs-keyword">sum</span> -= nums[start++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == <span class="hljs-number">1000000001</span> ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//超时写法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> total<span class="hljs-constructor">Fruit(<span class="hljs-params">int</span>[] <span class="hljs-params">fruits</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = fruits.length;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max_num = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">while</span>(is<span class="hljs-constructor">AboveTwo(<span class="hljs-params">fruits</span>, <span class="hljs-params">start</span>, <span class="hljs-params">i</span>)</span><span class="hljs-operator"> &amp;&amp; </span>start &lt; i)&#123;<br>                start ++;<br>            &#125;<br>            max_num = max_num &lt; (i - start) + <span class="hljs-number">1</span> ? (i - start) + <span class="hljs-number">1</span> : max_num;<br>        &#125;<br>        return max_num;<br>    &#125;<br><br>    <span class="hljs-comment">//判断从start到i之间是否有超过两种不同类型的水果</span><br>    boolean is<span class="hljs-constructor">AboveTwo(<span class="hljs-params">int</span>[] <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span>&#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = left; i &lt;= right;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span><span class="hljs-operator"> &amp;&amp; </span>dict.size<span class="hljs-literal">()</span> &lt; <span class="hljs-number">2</span>)&#123;<br>                dict.put(<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, <span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span><span class="hljs-operator"> &amp;&amp; </span>dict.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">2</span>)&#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span>)&#123;<br>                continue;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//滑动窗口写法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> total<span class="hljs-constructor">Fruit(<span class="hljs-params">int</span>[] <span class="hljs-params">fruits</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = fruits.length;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max_num = -<span class="hljs-number">1</span>;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-comment">//获得原来存在map中的对应的水果种类的水果树数量</span><br>            dict.put(fruits<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">fruits</span>[<span class="hljs-params">i</span>], 0)</span> + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//然后判断当前窗口中是否存在超过两种水果</span><br>            <span class="hljs-keyword">while</span>(dict.size<span class="hljs-literal">()</span> &gt; <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">//设置start对应的位置水果种类对应的树木数量 - 1</span><br>                dict.put(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>, dict.get(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>) - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果在当前滑动窗口中不存在对应的种类的树木（即树木数量为0）</span><br>                <span class="hljs-keyword">if</span>(dict.get(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//那么直接删除dict字典中对应的key</span><br>                    dict.remove(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>);<br>                &#125;<br>                <span class="hljs-comment">//然后滑动窗口左边start向左移动一位</span><br>                start ++;<br>            &#125;<br>            <span class="hljs-comment">//然后，更新最大值</span><br>            max_num = max_num &lt; (i - start) + <span class="hljs-number">1</span> ? (i - start) + <span class="hljs-number">1</span> : max_num;<br>        &#125;<br>        return max_num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String min<span class="hljs-constructor">Window(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> sn = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> tn = t.length<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> minLen = Integer.MAX_VALUE;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br><br>        Map&lt;Character, Integer&gt; tDict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; tn; i++) &#123;<br>            tDict.put(t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>, tDict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">t</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        Map&lt;Character, Integer&gt; windowDict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> formed = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录窗口中满足条件的字符数量</span><br><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sn) &#123;<br>            <span class="hljs-built_in">char</span> c = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>;<br>            windowDict.put(c, windowDict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">c</span>, 0)</span> + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (tDict.contains<span class="hljs-constructor">Key(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> &amp;&amp; </span>windowDict.get(c).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span><span class="hljs-operator"> == </span>tDict.get(c).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>) &#123;<br>                formed++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (left &lt;= right<span class="hljs-operator"> &amp;&amp; </span>formed<span class="hljs-operator"> == </span>tDict.size<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-comment">// 更新最小窗口长度和结果</span><br>                <span class="hljs-built_in">int</span> curLen = right - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (curLen &lt; minLen) &#123;<br>                    minLen = curLen;<br>                    result = s.substring(left, right + <span class="hljs-number">1</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 缩小窗口左边界</span><br>                <span class="hljs-built_in">char</span> leftChar = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>;<br>                windowDict.put(leftChar, windowDict.get(leftChar) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (tDict.contains<span class="hljs-constructor">Key(<span class="hljs-params">leftChar</span>)</span><span class="hljs-operator"> &amp;&amp; </span>windowDict.get(leftChar).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span> &lt; tDict.get(leftChar).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>) &#123;<br>                    formed--;<br>                &#125;<br><br>                left++;<br>            &#125;<br><br>            right++;<br>        &#125;<br><br>        return result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs</title>
    <link href="/2023/05/24/my-leetcode-logs-20230524/"/>
    <url>/2023/05/24/my-leetcode-logs-20230524/</url>
    
    <content type="html"><![CDATA[<h1 id="My-LeetCode-HOT-100-logs"><a href="#My-LeetCode-HOT-100-logs" class="headerlink" title="My LeetCode HOT 100 logs"></a>My LeetCode HOT 100 logs</h1><p><em>use language: java</em></p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == <span class="hljs-keyword">target</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-built_in">String</span>[] strs) &#123;<br>        Map&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>: strs)&#123;<br>            <span class="hljs-type">char</span>[] array = <span class="hljs-built_in">str</span>.<span class="hljs-property">toCharArray</span>();<br>            Arrays.<span class="hljs-property">sort</span>(array);<br>            <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(array);<br>            List&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-built_in">map</span>.<span class="hljs-property">getOrDefault</span>(<span class="hljs-built_in">key</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;<span class="hljs-built_in">String</span>&gt;());<br>            list.<span class="hljs-property">add</span>(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">key</span>, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt;(<span class="hljs-built_in">map</span>.<span class="hljs-property">values</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-built_in">int</span> longestConsecutive(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">Set</span>&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>            <span class="hljs-keyword">set</span>.add(<span class="hljs-built_in">num</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">set</span>.contains(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">int</span> currNum = <span class="hljs-built_in">num</span>;<br>                <span class="hljs-built_in">int</span> inner_result = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">set</span>.contains(currNum + <span class="hljs-number">1</span>))&#123;<br>                    inner_result += <span class="hljs-number">1</span>;<br>                    currNum += <span class="hljs-number">1</span>;<br>                &#125;<br>                <br>                result = Math.max(result, inner_result);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span> &#123;<br>    public void moveZeroes(int[] nums) &#123;<br>        int n = nums.length;<br>        <br>        int <span class="hljs-built_in">lp</span> = <span class="hljs-number">0</span>;<br>        int <span class="hljs-built_in">rp</span> = <span class="hljs-built_in">lp</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">lp</span> != n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-type">lp</span>] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-built_in">rp</span> != n)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[<span class="hljs-type">rp</span>] != <span class="hljs-number">0</span>)&#123;<br>                        int tmp = nums[<span class="hljs-type">rp</span>];<br>                        nums[<span class="hljs-type">rp</span>] = nums[<span class="hljs-type">lp</span>];<br>                        nums[<span class="hljs-type">lp</span>] = tmp;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">rp</span> += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">lp</span> += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rp</span> = <span class="hljs-built_in">lp</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> maxArea(<span class="hljs-built_in">int</span>[] height) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = height.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> area = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">int</span> h = Math.min(height[<span class="hljs-built_in">left</span>], height[<span class="hljs-built_in">right</span>]);<br>            area = Math.max(area, h * (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>));<br>            <span class="hljs-built_in">if</span>(height[<span class="hljs-built_in">left</span>] &lt; height[<span class="hljs-built_in">right</span>])&#123;<br>                <span class="hljs-built_in">left</span> ++;<br>            &#125;else&#123;<br>                <span class="hljs-built_in">right</span> -- ;<br>            &#125;<br>        &#125;<br>        return area;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; threeSum(<span class="hljs-type">int</span>[] nums) &#123;<br>        //首先先排序（升序）<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> n = nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            //判断i位置的元素是否和其前一个元素相同，相同那么进入下一次循环<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>)&#123;<br>                    right<span class="hljs-comment">--;</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; tmp = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>                    tmp.<span class="hljs-keyword">add</span>(nums[i]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[left]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[right]);<br>                    result.<span class="hljs-keyword">add</span>(tmp);<br><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right - <span class="hljs-number">1</span>] == nums[right])&#123;<br>                        right<span class="hljs-comment">--;</span><br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left + <span class="hljs-number">1</span>] == nums[left])&#123;<br>                        left++;<br>                    &#125;<br><br>                    right<span class="hljs-comment">--;</span><br>                    left++;<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> lengthOfLongestSubstring(String s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = s.length();<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>)&#123;<br>            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();<br>            map.put(s.charAt(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">left</span>);<br>            while(<span class="hljs-built_in">right</span> &lt; <span class="hljs-built_in">n</span> &amp;&amp; !map.containsKey(s.charAt(<span class="hljs-built_in">right</span>)))&#123;<br>                map.put(s.charAt(<span class="hljs-built_in">right</span>), <span class="hljs-built_in">right</span>);<br>                <span class="hljs-built_in">right</span>++;<br>            &#125;<br>            result = Math.max(result, <span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>);<br>            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">char</span>[] p_chars = p.<span class="hljs-built_in">toCharArray</span>(); <span class="hljs-comment">// 转换为字符数组</span><br>        Arrays.<span class="hljs-built_in">sort</span>(p_chars); <span class="hljs-comment">// 对字符数组进行排序</span><br>        <span class="hljs-type">String</span> sorted_p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(p_chars); <span class="hljs-comment">// 将字符数组转换回字符串</span><br>        <span class="hljs-comment">//System.out.println(&quot;sorted_p: &quot; + sorted_p);</span><br><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-keyword">while</span>(left &lt;= l - n)&#123;<br>            <span class="hljs-type">String</span> tmp = s.<span class="hljs-built_in">substring</span>(left, left + n);<br>            <span class="hljs-type">char</span>[] tmp_chars = tmp.<span class="hljs-built_in">toCharArray</span>(); <span class="hljs-comment">// 转换为字符数组</span><br>            Arrays.<span class="hljs-built_in">sort</span>(tmp_chars); <span class="hljs-comment">// 对字符数组进行排序</span><br>            <span class="hljs-type">String</span> sorted_tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(tmp_chars); <span class="hljs-comment">// 将字符数组转换回字符串</span><br>            <span class="hljs-comment">//System.out.println(&quot;sorted_tmp: &quot; + sorted_tmp);</span><br>            <span class="hljs-keyword">if</span>(sorted_tmp.<span class="hljs-built_in">equals</span>(sorted_p))&#123;<br>                result.<span class="hljs-built_in">add</span>(left);<br>            &#125;<br>            left += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560.和为 K 的子数组"></a>560.和为 K 的子数组</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Solution &#123;<br>    public int subarraySum(int[] nums, int k) &#123;<br>        Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> HashMap&lt;Integer, Integer&gt;();<br>        int <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        int result = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">length</span>;i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">sum</span> - k))&#123;<br>                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span> - k, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            result += <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">sum</span> - k);<br><br>            <br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">sum</span>))&#123;<br>                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span>, <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">sum</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>] || <span class="hljs-keyword">target</span> &gt; nums[nums.length - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-keyword">target</span>)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &gt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &gt; nums[nums.length - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-keyword">target</span>)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &lt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &gt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//暴力解法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                    nums<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>                &#125;<br>                i--;<br>                n--;<br>            &#125;<br>        &#125;<br>        return n;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//快慢指针法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; n; fast ++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-keyword">val</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125; <br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//快慢指针</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Duplicates(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">nums</span>[<span class="hljs-params">fast</span>])</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>                dict.put(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零-1"><a href="#283-移动零-1" class="headerlink" title="283.移动零"></a>283.移动零</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//使用快慢指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> moveZeroes(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow ++] = nums[fast];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(; slow &lt; n; slow ++)&#123;<br>            nums[slow] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//使用快慢指针</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean backspace<span class="hljs-constructor">Compare(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span> s_arr = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br>        <span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span> t_arr = t.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><br>        <span class="hljs-keyword">if</span>(rebuild<span class="hljs-constructor">String(<span class="hljs-params">s_arr</span>)</span>.equals(rebuild<span class="hljs-constructor">String(<span class="hljs-params">t_arr</span>)</span>))&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//重建字符串函数</span><br>    String rebuild<span class="hljs-constructor">String(<span class="hljs-params">char</span>[] <span class="hljs-params">c</span>)</span>&#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; c.length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(c<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-character">&#x27;#&#x27;</span>)&#123;<br>                c<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = c<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(slow &gt; <span class="hljs-number">0</span>)&#123;<br>                    slow--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">c</span>)</span>.substring(<span class="hljs-number">0</span>,slow);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//使用前后双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">sortedSquares</span>(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> end = nums.length;<br>       <span class="hljs-type">int</span>[] new_nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[end];<br>       <span class="hljs-type">int</span> i = end - <span class="hljs-number">1</span>;<br>       end --;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            new_nums[i--] = nums[start] * nums[start] &gt; nums[end] * nums[end] ? nums[start]*nums[start++] : nums[end]*nums[end--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> new_nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>About ME</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="WYY’S-HOMEPAGE"><a href="#WYY’S-HOMEPAGE" class="headerlink" title="WYY’S HOMEPAGE"></a>WYY’S HOMEPAGE</h2><p><strong>WANG YANG YANG</strong></p><p><strong>2000-02丨male丨Pingdingshan, Henan丨Han nationality 丨Full member of the CPC</strong></p><p><em><strong>My Personal Blog(CSDN) Address : <a href="https://blog.csdn.net/weixin_43749999">https://blog.csdn.net/weixin_43749999</a></strong></em></p><p><em><strong>My GitHub HomePage : <a href="https://github.com/TheWangYang">https://github.com/TheWangYang</a></strong></em></p><p><em><strong>My Leetcode HomePage ： <a href="https://leetcode-cn.com/u/wyypersist">https://leetcode-cn.com/u/wyypersist</a></strong></em></p><p><em><strong>My Gitee Homepage : <a href="https://gitee.com/SCKDKT">https://gitee.com/SCKDKT</a></strong></em></p><h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><p><em><strong>Master Degree, Xi’an Jiaotong University, Institute of Artificial Intelligence and Robotics(IAIR), Electronic Information (Artificial Intelligence), September 2022 - June 2025</strong></em></p><p><em>coming soon …</em></p><p><em><strong>Bachelor Degree, Zhengzhou University, School of Cyberspace Security, Software Engineering, September 2018 - June 2022</strong></em></p><p><em>GPA: 3.44 &#x2F; 4.00 (14&#x2F;184 professional 7.6%)</em></p><p><em>Comprehensive ranking of the first 6 semesters: 9&#x2F;184 (4.89%)</em></p><h2 id="Research-Interest"><a href="#Research-Interest" class="headerlink" title="Research Interest"></a>Research Interest</h2><p><em><strong>Machine Learning</strong></em></p><p><em><strong>Deep Learning</strong></em></p><p><em><strong>Computer Vision</strong></em></p><p><em><strong>Image Generation</strong></em></p><p><em><strong>Defect detection</strong></em></p><p><em><strong>NeRF</strong></em></p><p>…</p><h2 id="Intern-Experience"><a href="#Intern-Experience" class="headerlink" title="Intern Experience"></a>Intern Experience</h2><p><em><strong>Computer Vision Algorithm Engineer(intern)</strong></em><br><em><strong><a href="http://www.ukdq.com.cn/">Nanjing Youkuo Electric Technology Co., Ltd.</a></strong></em><br><em><strong>March 2022 - June 2022</strong></em></p><ul><li>As the person in charge, the algorithm deployed on the NVIDIA graphics card was ported to the Cambrian MLU card.</li><li>Mainly use the official docker image provided by Cambrian to load the deployment verification environment. First, quantize the pth weight, and then save it as a .cambricon model (offline model provided by Cambrian). Then, use the Cambrian CNRT runtime library to deploy and load the offline model to obtain the .so dynamic link library, which is called by the business-side python script to complete batch image reasoning.</li><li>Familiar with data annotation, model training, get onnx weight model or tensorRT model, and use C++&#x2F;Python to write deployment reasoning api, etc., a complete set of deep learning model reasoning deployment process.</li></ul><p><em><strong>Coming Soon…</strong></em></p><h2 id="Honors-and-Awards"><a href="#Honors-and-Awards" class="headerlink" title="Honors and Awards"></a>Honors and Awards</h2><h4 id="Master-Period"><a href="#Master-Period" class="headerlink" title="Master Period"></a><em>Master Period</em></h4><ul><li><p>2023 Global Artificial Intelligence Technology Innovation Contest-GigaRendering A New Perspective Rendering Algorithm Based on Gigapixel Sparse Images II Track | <strong>TOP20</strong> | 2023.6</p></li><li><p>2023 Huawei Embedded Software Contest (Physical Group) Northwest Division | <strong>Top36</strong> | 2023.6</p></li><li><p>2023 China Postgraduate Electronic Design Competition Northwest Division Technology Track | <strong>Second Prize</strong> | 2023.7</p></li><li><p>2023 China Postgraduate Electronic Design Competition Northwest Division Business Plan Track | <strong>Second Prize</strong> | 2023.7</p></li><li><p>2023 China International Internet + Innovation and Entrepreneurship Competition Xi’an Jiaotong University School Competition | <strong>Silver Award (Second Prize, The top 47% are expected to win the bronze award, and the proportion of the silver award is even less)</strong> | 2023.7</p></li><li><p>coming soon …</p></li></ul><h4 id="Bachelor-Period"><a href="#Bachelor-Period" class="headerlink" title="Bachelor Period"></a><em>Bachelor Period</em></h4><ul><li><p>Chinese Finals of the 14th ICAN International Innovation and Entrepreneurship Competition | <strong>Third Prize</strong> | 2020.12</p></li><li><p>Henan Division of the 14th ICAN International Innovation and Entrepreneurship Competition | <strong>First Prize</strong> | 2020.10</p></li><li><p>2021 China University of Computer Design Competition Henan Provincial | <strong>Third Prize</strong> | 2021.5</p></li><li><p>2021 American College Students Mathematics Modeling Competition | <strong>Second Prize</strong> | 2021.4</p></li><li><p>2020 College Students Mathematics Modeling Competition | <strong>Second Prize</strong> | 2021.1</p></li><li><p>2020 China University Computer Competition - WeChat Approval Application Development Raihua Shuangyai District | <strong>Second Prize</strong> | 2020.7</p></li><li><p>Finals of the 10th China Software Cup College Student Software Design Competition | <strong>Third Prize</strong> | 2021.5</p></li><li><p>2019-2020 Journal of Zhengzhou University <strong>First-class Scholarship</strong> 2020.12</p></li><li><p>2019-2020 school year Zhengzhou University <strong>Three good students</strong> 2020.12</p></li></ul><h2 id="Project-Experience"><a href="#Project-Experience" class="headerlink" title="Project Experience"></a>Project Experience</h2><h4 id="Master-Period-1"><a href="#Master-Period-1" class="headerlink" title="Master Period"></a><em>Master Period</em></h4><p><strong>Key technology and system of quality inspection with independent learning ability-Ministry of Science and Technology Innovation 2030-“New Generation Artificial Intelligence” major project</strong></p><ul><li><strong>About</strong>: Core member, Xi’an Jiaotong University, Institute of Artificial Intelligence and Robotics(<em><strong>IAIR</strong></em>), October 2021 - October 2023, Xi’an</li><li><strong>Project Introduction</strong>: As a core member of project topic 5 “Quality inspection system and verification demonstration for typical industries”, it is mainly responsible for supporting hybrid inspection of imaging and perceptual reasoning, learning and decision-making System design and construction, research on defect detection algorithm based on few-shot learning. <em><strong>The previous work</strong></em> was mainly to use the newer target detection algorithm on the self-built data set to verify and demonstrate the detection task. We also proposed an improved FCOS algorithm combined with the spatial attention mechanism. <em><strong>The current work</strong></em> mainly focuses on the research of few-sample unsupervised or semi-supervised algorithms using the few abnormal samples and more normal samples in the field of industrial defect detection.</li><li><strong>Project Achievements</strong>:</li><li><em><strong>IEEE Transactions on Instrumentation and Measurement( TIM, JCR Q1&#x2F;SCI Area 2) (in process)</strong></em></li><li><em><strong>One invention patent (second work, excluding tutor), “an industrial defect detection optimization method, system, device, equipment and storage medium”</strong></em></li><li><em><strong>more coming soon…</strong></em></li></ul><h4 id="Bachelor-Period-1"><a href="#Bachelor-Period-1" class="headerlink" title="Bachelor Period"></a><em>Bachelor Period</em></h4><p><strong>Intelligent Medical Cabinet Based on Machine Learning</strong></p><ul><li><p><strong>About</strong>: Principal, Zhengzhou University, Software College, Mar 2021 - May 2021, Zhengzhou</p></li><li><p><strong>Project Introduction</strong>: As a person in charge, I organized the development of “Machine-based intelligent medical cabinet” intelligent medical project, mainly responsible for the development of the web end, APP end and back-end algorithm  modules. After reviewing the relevant literature and combines its own ability, I  decided to divide the algorithm analysis into: collecting data pretreatment, the old man’s health indicator, a large amount of data logic regression classification, and the results visualize. When implementing the classification, I use the F value formula to make different Threshold minimum, and realize personalized model training.During the development process, I will use the theory, development knowledge, and IoT idea to the project, greatly deepened my understanding of these knowledge.</p></li><li><p><strong>Project Achievements</strong>:</p></li><li><p><em><strong>This project won the 2021 Chinese College Student Computer Design Competition Henan Provincial San Salancing Award.</strong></em></p></li></ul><p><strong>IntelligentData Smart Gloves</strong></p><ul><li><strong>About</strong>: Core member, Zhengzhou University, Software College, May 2020 - Dec 2020, Zhengzhou</li><li><strong>Project Introduction</strong>: I have participated in the research and development process of the team’s “IntelligentData-Smart Glove” project and is responsible for analyzing patient rehabilitation data.The project uses mirroring therapy to help patients carry out hand rehabilitation.I divide the data analysis process into: collected data pretreatment, patient finger curvature regression, patient rehabilitation neural network classification and other steps and use Tensorflow  and other libraries to  complete     the establishment and programming of the patient’s finger curvature prediction model and the like.In the process of research and development, I applied machine learning knowledge to actual and strengthened their understanding.</li><li><strong>Project Achievements</strong>:</li><li><em><strong>This project won the third prize of the 14th ICAN International Innovation Entrepreneurship Competition.</strong></em></li></ul><h2 id="Community-and-Organizational-Experiences"><a href="#Community-and-Organizational-Experiences" class="headerlink" title="Community and Organizational Experiences"></a>Community and Organizational Experiences</h2><h4 id="Master-Period-2"><a href="#Master-Period-2" class="headerlink" title="Master Period"></a><em>Master Period</em></h4><p><strong>Organization: coming soon</strong></p><ul><li><strong>About</strong>: coming soon …</li><li><strong>Main Work</strong>: coming soon …</li></ul><h4 id="Bachelor-Period-2"><a href="#Bachelor-Period-2" class="headerlink" title="Bachelor Period"></a><em>Bachelor Period</em></h4><p><strong>Organization: Essence (Hangzhou) Network Co., Ltd. Zhengzhou University North Campus Club</strong></p><ul><li><strong>About</strong>: Principal, Zhengzhou University Software College, Oct 2019 - Oct 2020, Zhengzhou</li><li><strong>Main Work</strong>: I have currently served as the head of Zhengzhou University North Campus Club, and regularly organized technical exchanges under the guidance of  Alibaba technical experts.Club membership technology has been greatly improved in   the original level.</li></ul><h2 id="Skills-Others"><a href="#Skills-Others" class="headerlink" title="Skills &#x2F; Others"></a>Skills &#x2F; Others</h2><p><strong>Skills: Java(Skilled), Python(Used in projects), C ++(Use in algorithmic questions)</strong></p><p><strong>English Level: CET-4:545, CET-6:501, IELTS(total):6.5</strong></p><p><strong>Hobbies: Basketball (College New Student Collection Second Prize), Films, Music, …</strong></p><h2 id="Contact-Me"><a href="#Contact-Me" class="headerlink" title="Contact Me"></a>Contact Me</h2><p><strong>Email:<a href="mailto:&#119;&#121;&#x79;&#115;&#117;&#99;&#x63;&#x65;&#115;&#115;&#50;&#x30;&#50;&#x30;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;">&#119;&#121;&#x79;&#115;&#117;&#99;&#x63;&#x65;&#115;&#115;&#50;&#x30;&#50;&#x30;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a></strong></p><p><strong>QQ: 844817943</strong></p><p><strong>Phone &amp; WeChat: 13803907433</strong></p><p><strong>Where am I now: Xi’an Jiaotong University Innovation Port Campus, Fengxi New City, Xixian New District, Xi’an City, China</strong></p><p><strong>Postal Code: 710100</strong></p><p><em>This page was last updated on August 22, 2023.</em></p>]]></content>
    
  </entry>
  
  
  
</search>
