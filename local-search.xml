<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-notes-20230916</title>
    <link href="/2023/09/16/leetcode-notes-20230916/"/>
    <url>/2023/09/16/leetcode-notes-20230916/</url>
    
    <content type="html"><![CDATA[<h2 id="416-分割等和子集（C-动态规划实现）"><a href="#416-分割等和子集（C-动态规划实现）" class="headerlink" title="416. 分割等和子集（C++动态规划实现）"></a>416. 分割等和子集（C++动态规划实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    bool canPartition(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//思路：背包的体积为sum/2</span><br>        <span class="hljs-comment">//每个元素既是重量又是价值</span><br>        <span class="hljs-comment">//dp[j]表示对于容量为j的背包，其能装的物体最大价值是dp[j]</span><br>        <span class="hljs-comment">//确定递推公式：</span><br>        <span class="hljs-comment">//dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br>        <span class="hljs-comment">//最终判断的标准：</span><br>        <span class="hljs-comment">//如果dp[target] == target，那么返回true，否则返回false；</span><br><br>        <span class="hljs-comment">//初始化动态规划数组</span><br>        <span class="hljs-comment">//题目中指定数组中元素的大小不会超过200，长度不会超过100，所以综合不会超过20000，那么</span><br>        <span class="hljs-comment">//sum / 2 = target == 10000</span><br>        <span class="hljs-comment">//因此定义动态规划数组的长度为10001</span><br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; dp(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">//判断sum / 2余数是否为1，如果为1，直接返回false；</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> false;<br>        &#125;<br><br>        <span class="hljs-comment">//得到背包最大容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">target</span> = <span class="hljs-built_in">sum</span> / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//开始递推更新dp数组</span><br>        <span class="hljs-comment">//外层循环遍历物体重量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//内层循环遍历物体的价值数组</span><br>            <span class="hljs-comment">//需要从后向前遍历，因为为了防止元素重复</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-built_in">target</span>;j &gt;= nums[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//判断dp[target] == target</span><br>        <span class="hljs-keyword">if</span>(dp[<span class="hljs-built_in">target</span>] == <span class="hljs-built_in">target</span>)&#123;<br>            <span class="hljs-keyword">return</span> true;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> false;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1049-最后一块石头的重量-II（C-动态规划实现）"><a href="#1049-最后一块石头的重量-II（C-动态规划实现）" class="headerlink" title="1049. 最后一块石头的重量 II（C++动态规划实现）"></a>1049. 最后一块石头的重量 II（C++动态规划实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> lastStoneWeightII(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones) &#123;<br>        <span class="hljs-comment">//思路：stones[i]表示第i块石头的重量，价值也为stones[i]</span><br>        <span class="hljs-comment">//题目中说的最小的重量，也就是说将这两堆石头尽可能地分为两份相同的重量</span><br>        <span class="hljs-comment">//那么这道题目就和分割等和子集一样了</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">sum</span> += stones[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">target</span> = <span class="hljs-built_in">sum</span> / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//初始化dp数组</span><br>        <span class="hljs-comment">//由于题目中给出stones数组长度最大为30，每个石头最大重量为100</span><br>        <span class="hljs-comment">//30 * 100 = 3000</span><br>        <span class="hljs-comment">//那么，target = sum / 2 = 3000 / 2 = 1500</span><br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; dp(<span class="hljs-number">1501</span>, <span class="hljs-number">0</span>);<br><br><br>        <span class="hljs-comment">//更新dp数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; stones.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-built_in">target</span>;j &gt;= stones[i];j--)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> - dp[<span class="hljs-built_in">target</span>] - dp[<span class="hljs-built_in">target</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="494-目标和（C-动态规划实现）"><a href="#494-目标和（C-动态规划实现）" class="headerlink" title="494. 目标和（C++动态规划实现）"></a>494. 目标和（C++动态规划实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> findTargetSumWays(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-comment">//思路：假设left - right = target，且left + right = sum</span><br>        <span class="hljs-comment">//那么，right = sum - left;</span><br>        <span class="hljs-comment">//则有left - (sum - left) = target</span><br>        <span class="hljs-comment">//left * 2 = sum + target</span><br>        <span class="hljs-comment">//left = (target + sum) / 2</span><br>        <span class="hljs-comment">//所以，原题目变成了求nums[i]数组中元素相加等于(target + sum) / 2的元素和</span><br>        <span class="hljs-comment">//需要注意的是：(target + sum) / 2可能向下取整，这个时候就返回0，表示不存在对应的表达式</span><br>        <span class="hljs-comment">//还有如果target &gt; sum，也是不存在的</span><br>        <span class="hljs-comment">//dp[j]表示能将j容量背包填满的方案数为dp[j]</span><br>        <span class="hljs-comment">//其中，dp[j]应该由dp[j - nums[i]]得到，其中nums[i]是元素i的重量</span><br>        <span class="hljs-comment">//也就是说，只要能找到nums[i]，就能找到dp[j - nums[i]] + nums[i] = dp[j]</span><br><br>        <span class="hljs-comment">//同时，dp[0]还应该初始化为1</span><br>        <span class="hljs-comment">//因为：对于nums = &#123;0, 0, 0&#125;，(target + sum) / 2，其中target = 0</span><br>        <span class="hljs-comment">//此时，实际上的不同表达式数目为2 * 2 * 2，而结果8的获得肯定是由dp[0] = 1递推得到的，</span><br>        <span class="hljs-comment">//因为如果dp[0] = 0，那么最终得到的dp[j]肯动都是0，因此，dp[0]应当初始化为1</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &lt; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">target</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>((<span class="hljs-built_in">target</span> + <span class="hljs-built_in">sum</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br><br>        <span class="hljs-comment">//得到背包的目标容量为bagSize</span><br>        <span class="hljs-type">int</span> bagSize = (<span class="hljs-built_in">target</span> + <span class="hljs-built_in">sum</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//初始化数组都为0</span><br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; dp(bagSize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//初始化dp[0] = 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//进行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagSize;j &gt;= nums[i];j--)&#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>动态规划（dp）算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230915</title>
    <link href="/2023/09/15/leetcode-notes-20230915/"/>
    <url>/2023/09/15/leetcode-notes-20230915/</url>
    
    <content type="html"><![CDATA[<h2 id="509-斐波那契数（C-动态规划实现）"><a href="#509-斐波那契数（C-动态规划实现）" class="headerlink" title="509. 斐波那契数（C++动态规划实现）"></a>509. 斐波那契数（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">//使用动态规划实现</span><br>        <span class="hljs-comment">//定义状态数组，长度为n+1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯（C-动态规划实现）"><a href="#70-爬楼梯（C-动态规划实现）" class="headerlink" title="70. 爬楼梯（C++动态规划实现）"></a>70. 爬楼梯（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <br>        <span class="hljs-comment">//思路：假设dp[i]表示达到第i阶楼梯所有可能的方法种类数量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//dp[0] = 0;//不需要考虑n=0的情况，因为n&gt;=1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<span class="hljs-comment">//可以走两步，也可以连续走一步</span><br>        <span class="hljs-comment">//由于dp[i]可以由dp[i - 1]增加一阶得到也可以由dp[i - 2]增加两阶得到</span><br>        <span class="hljs-comment">//因此dp[i] = dp[i - 1] + dp[i - 2]</span><br>        <span class="hljs-comment">//从前向后遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n;i ++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯（C-动态规划实现，优化空间的写法）"><a href="#70-爬楼梯（C-动态规划实现，优化空间的写法）" class="headerlink" title="70. 爬楼梯（C++动态规划实现，优化空间的写法）"></a>70. 爬楼梯（C++动态规划实现，优化空间的写法）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">//优化空间的写法</span><br>        <span class="hljs-built_in">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">2</span>] = <span class="hljs-keyword">sum</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯（C-动态规划实现）"><a href="#746-使用最小花费爬楼梯（C-动态规划实现）" class="headerlink" title="746. 使用最小花费爬楼梯（C++动态规划实现）"></a>746. 使用最小花费爬楼梯（C++动态规划实现）</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;<br>        //思路：使用一维dp数组，dp<span class="hljs-comment">[i]</span>表示跳到i层需要的最少花费<br>        //dp<span class="hljs-comment">[i]</span>可以由dp<span class="hljs-comment">[i - 1]</span>得到，此时的dp<span class="hljs-comment">[i]</span> = dp<span class="hljs-comment">[i - 1]</span> + cost<span class="hljs-comment">[i - 1]</span>;<br>        //dp<span class="hljs-comment">[i]</span>也可以由dp<span class="hljs-comment">[i - 2]</span>得到，此时的dp<span class="hljs-comment">[i]</span> = dp<span class="hljs-comment">[i - 2]</span> + cost<span class="hljs-comment">[i - 2]</span>;<br>        //那么dp<span class="hljs-comment">[i]</span> = min(dp<span class="hljs-comment">[i - 1]</span> + cost<span class="hljs-comment">[i - 1]</span>, dp<span class="hljs-comment">[i - 2]</span> + cost<span class="hljs-comment">[i - 2]</span>);<br>        //初始化dp数组：dp<span class="hljs-comment">[0]</span> = 0; dp<span class="hljs-comment">[1]</span> = 0;<br>        <br>        // 定义dp数组<br>        vector&lt;int&gt; dp(cost.size() + 1);<br>        dp<span class="hljs-comment">[0]</span> = 0;<br>        dp<span class="hljs-comment">[1]</span> = 0;<br><br>        for(int i = 2;i &lt;= cost.size();i++)&#123;<br>            dp<span class="hljs-comment">[i]</span> = min(dp<span class="hljs-comment">[i - 1]</span> + cost<span class="hljs-comment">[i - 1]</span>, dp<span class="hljs-comment">[i - 2]</span> + cost<span class="hljs-comment">[i - 2]</span>);<br>        &#125;<br><br>        return dp<span class="hljs-comment">[cost.size()]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯（C-动态规划实现，优化内存空间）"><a href="#746-使用最小花费爬楼梯（C-动态规划实现，优化内存空间）" class="headerlink" title="746. 使用最小花费爬楼梯（C++动态规划实现，优化内存空间）"></a>746. 使用最小花费爬楼梯（C++动态规划实现，优化内存空间）</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;<br>        //优化空间复杂度<br>        int dp<span class="hljs-comment">[3]</span>;<br>        dp<span class="hljs-comment">[0]</span> = 0;<br>        dp<span class="hljs-comment">[1]</span> = 0;<br><br>        for(int i = 2;i &lt;= cost.size();i++)&#123;<br>            dp<span class="hljs-comment">[2]</span> = min(dp<span class="hljs-comment">[1]</span> + cost<span class="hljs-comment">[i - 1]</span>, dp<span class="hljs-comment">[0]</span> + cost<span class="hljs-comment">[i - 2]</span>);<br>            dp<span class="hljs-comment">[0]</span> = dp<span class="hljs-comment">[1]</span>;<br>            dp<span class="hljs-comment">[1]</span> = dp<span class="hljs-comment">[2]</span>;<br>        &#125;<br><br>        return dp<span class="hljs-comment">[1]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径（C-动态规划实现）"><a href="#62-不同路径（C-动态规划实现）" class="headerlink" title="62. 不同路径（C++动态规划实现）"></a>62. 不同路径（C++动态规划实现）</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int uniquePaths(int m, int n) &#123;<br>        //思路：设dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>为动态数组，表示从(0, 0)开始到(i, j)总共有dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>条路径<br>        //而dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>只能从两个方向来推导：dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>和dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span><br>        //初始化dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>数组：从(0, 0)开始到(i, 0)或(0, j)的方法只有一个<br>        <br>        //初始化dp数组<br>        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));<br>        for(int i = 0;i &lt; m; i++)&#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = 1;<br>        &#125;<br><br>        for(int j = 0; j &lt; n;j++)&#123;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span> = 1;<br>        &#125;<br><br>        //遍历整个m*n网格<br>        for(int i = 1;i &lt; m;i++)&#123;<br>            for(int j = 1;j &lt; n;j++)&#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>            &#125;<br>        &#125;<br><br>        return dp<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="63-不同路径-II（C-动态规划实现）"><a href="#63-不同路径-II（C-动态规划实现）" class="headerlink" title="63. 不同路径 II（C++动态规划实现）"></a>63. 不同路径 II（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：首先对于(i, 0)和(0, j)的处理与没有障碍物的题目类似，但是不同的地方在于：</span><br>        <span class="hljs-comment">//由于存在障碍物，需要判断是否等于0，如果等于0，那么设置为1，否则从等于1的地方开始向后都设置为0</span><br>        <span class="hljs-comment">//在更新dp数组的时候需要注意：如果(i, j)有障碍物，那么跳过即可</span><br>        <span class="hljs-comment">//得到行列数</span><br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//初始化dp表</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//初始化最左边的列，障碍物之后都是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//初始化最上边的行，障碍物之后都是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//然后更新dp表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-comment">//表示有障碍物</span><br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="343-整数拆分（C-动态规划实现）"><a href="#343-整数拆分（C-动态规划实现）" class="headerlink" title="343. 整数拆分（C++动态规划实现）"></a>343. 整数拆分（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：dp[i]表示拆分数字i得到的正整数的最大乘积为dp[i]</span><br>        <span class="hljs-comment">//此时，dp[i]可以由如下两种方法得到：</span><br>        <span class="hljs-comment">//1.由j * (i - j)得到；</span><br>        <span class="hljs-comment">//2.由j * dp[i - j]得到，相当于，拆分了dp[i - j]；</span><br><br>        <span class="hljs-comment">//初始化dp数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//初始化dp[2] = 1</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//2 = 1 * 1</span><br>        <span class="hljs-comment">//更新dp数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-comment">//j实际上从1增加到i / 2即可</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= i / <span class="hljs-number">2</span>;j++)&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j * (i - j), j * dp[i - j]));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="96-不同的二叉搜索树（C-动态规划实现）"><a href="#96-不同的二叉搜索树（C-动态规划实现）" class="headerlink" title="96. 不同的二叉搜索树（C++动态规划实现）"></a>96. 不同的二叉搜索树（C++动态规划实现）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Solution &#123;<br>public:<br>    int numTrees(int n) &#123;<br>        <span class="hljs-regexp">//</span>思路：<br>        <span class="hljs-regexp">//</span>节点数为<span class="hljs-number">1</span>的，只有一种；<br>        <span class="hljs-regexp">//</span>结点数为<span class="hljs-number">2</span>的，有两种；<br><br>        <span class="hljs-regexp">//</span>节点数为<span class="hljs-number">3</span>的，需要分情况讨论：<br>        <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.头节点为<span class="hljs-number">1</span>对应的种类数=右子树有<span class="hljs-number">2</span>个结点的种类数*左子树有<span class="hljs-number">0</span>个结点的种类数；<br>        <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.头节点为<span class="hljs-number">2</span>对应的种类数=右子树有<span class="hljs-number">1</span>个结点的种类数*左子树有<span class="hljs-number">1</span>个结点的种类数；<br>        <span class="hljs-regexp">//</span><span class="hljs-number">3</span>.头结点为<span class="hljs-number">3</span>对应的种类数=右子树有<span class="hljs-number">0</span>个结点的种类数*左子树有<span class="hljs-number">2</span>个结点的种类数；<br>        <span class="hljs-regexp">//</span>那么节点数为<span class="hljs-number">3</span>对应的种类=头节点为<span class="hljs-number">1</span>对应的种类数+头节点为<span class="hljs-number">2</span>对应的种类数+头节点为<span class="hljs-number">3</span>对应的种类数<br><br>        <span class="hljs-regexp">//</span>而：<span class="hljs-number">0</span>个结点的种类数为dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-regexp">//</span>有<span class="hljs-number">1</span>个结点的种类数为dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-regexp">//</span>有<span class="hljs-number">2</span>个节点的种类数为dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-regexp">//</span>那么得到递推公式为：dp[<span class="hljs-number">3</span>] = dp[<span class="hljs-number">2</span>] * dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">0</span>] * dp[<span class="hljs-number">2</span>] + dp[<span class="hljs-number">1</span>] * dp[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-regexp">//</span>定义初始化数组：<br>        vector&lt;int&gt; dp(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-regexp">//</span>初始化dp[<span class="hljs-number">0</span>]为<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>; i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">1</span>;j &lt;= i;j++)&#123;<br>                <span class="hljs-regexp">//</span>j从<span class="hljs-number">1</span>开始遍历到i结束<br>                <span class="hljs-regexp">//</span>更新dp动态数组<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <br>        return dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="01背包问题基础公式推导（C-动态规划实现）"><a href="#01背包问题基础公式推导（C-动态规划实现）" class="headerlink" title="01背包问题基础公式推导（C++动态规划实现）"></a>01背包问题基础公式推导（C++动态规划实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//背包问题公式推导</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_beibao_problem</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//设置测试用例</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; values = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><br>        <span class="hljs-comment">//定义背包的最大容量</span><br>        <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>        <span class="hljs-comment">//定义二维数组</span><br>        <span class="hljs-comment">//第一个维度表示物品数组的长度</span><br>        <span class="hljs-comment">//第二个维度表示背包容量的长度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weights.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-comment">//初始化的时候需要注意：从weights开始，小于背包容量的设置为values[0]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weights[<span class="hljs-number">0</span>];j &lt;= bagweight;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = values[<span class="hljs-number">0</span>];<span class="hljs-comment">//初始化为values[0]</span><br>        &#125;<br><br>        <span class="hljs-comment">//先循环物品数组，再循环背包容量数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; weights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//循环背包容量数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= bagweights;j++)&#123;<br>                <span class="hljs-comment">//如果物品的重量大于j，表示无法将第i个物品放到背包里</span><br>                <span class="hljs-keyword">if</span>(j &lt; weights[i])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i]] + values[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[weights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweights];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>动态规划（dp）算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230914</title>
    <link href="/2023/09/14/leetcode-notes-20230914/"/>
    <url>/2023/09/14/leetcode-notes-20230914/</url>
    
    <content type="html"><![CDATA[<h2 id="134-加油站（C-贪心算法实现）"><a href="#134-加油站（C-贪心算法实现）" class="headerlink" title="134. 加油站（C++贪心算法实现）"></a>134. 加油站（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-comment">//设置currSum，用来保存从i+1更新后的sum总油量和</span><br>        <span class="hljs-type">int</span> currSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> totalSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//结果返回变量</span><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历油的数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++)&#123;<br>            totalSum += gas[i] - cost[i];<br>            currSum += gas[i] - cost[i];<br><br>            <span class="hljs-keyword">if</span>(currSum &lt; <span class="hljs-number">0</span>)&#123;<br>                currSum = <span class="hljs-number">0</span>;<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(totalSum &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="135-分发糖果（C-贪心算法实现）"><a href="#135-分发糖果（C-贪心算法实现）" class="headerlink" title="135. 分发糖果（C++贪心算法实现）"></a>135. 分发糖果（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-comment">//设置和ratings长度相同的数组，并初始化元素值为0</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candys</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-comment">//从前向后遍历，右孩子大于左孩子的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] - ratings[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                candys[i] = candys[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<span class="hljs-comment">//这个时候有孩子一定大于左孩子1</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//从后向前遍历</span><br>        <span class="hljs-comment">//判断左孩子大于右孩子的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">0</span>;i --)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] - ratings[i + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                candys[i] = <span class="hljs-built_in">max</span>(candys[i], candys[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//统计总和</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; candys.<span class="hljs-built_in">size</span>();i++)&#123;<br>            result += candys[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="860-柠檬水找零（C-贪心算法实现）"><a href="#860-柠檬水找零（C-贪心算法实现）" class="headerlink" title="860. 柠檬水找零（C++贪心算法实现）"></a>860. 柠檬水找零（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//其中当bills[i] == 20时，优先使用一张10面值+一张5面值的，尽可能多地保留5面值，因为5面值相对来说更加通用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-comment">//进行模拟</span><br>        <span class="hljs-comment">//curr_xxx表示当前商家手里面的钱的数量</span><br>        <span class="hljs-type">int</span> curr_five = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curr_ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curr_twenty = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//for循环实现遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; bills.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">5</span>)&#123;<br>                curr_five += <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-comment">//10元面值的钱增加1</span><br>                curr_ten += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//5元面值的钱减少1</span><br>                <span class="hljs-keyword">if</span>(curr_five &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    curr_five -= <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-comment">//20元面值的钱增加1</span><br>                curr_twenty += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//有两种可能</span><br>                <span class="hljs-keyword">if</span>(curr_ten &gt;= <span class="hljs-number">1</span> &amp;&amp; curr_five &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//第1种：找一张10面值+一张5面值的</span><br>                    curr_ten -= <span class="hljs-number">1</span>;<br>                    curr_five -= <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curr_five &gt;= <span class="hljs-number">3</span>)&#123;<span class="hljs-comment">//第2种：找三张5面值的</span><br>                    curr_five -= <span class="hljs-number">3</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//没有满足的找零，那么直接返回false</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="406-根据身高重建队列（C-贪心算法实现）"><a href="#406-根据身高重建队列（C-贪心算法实现）" class="headerlink" title="406. 根据身高重建队列（C++贪心算法实现）"></a>406. 根据身高重建队列（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//设置排列器，传入参数为vector数组地址</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-comment">//思路：先排身高最高的，身高相同的，按照后边的ki进行排序</span><br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<span class="hljs-comment">//创建的结果返回数组</span><br>        <br>        <span class="hljs-comment">//在循环中根据每个元素的ki对元素进行重新排序即可得到最终的结果队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; people.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//得到当前i同学应该在的位置</span><br>            <span class="hljs-type">int</span> pos = people[i][<span class="hljs-number">1</span>];<br>            result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">begin</span>() + pos, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="406-根据身高重建队列（C-贪心算法实现，将结果队列从vector替换为list）"><a href="#406-根据身高重建队列（C-贪心算法实现，将结果队列从vector替换为list）" class="headerlink" title="406. 根据身高重建队列（C++贪心算法实现，将结果队列从vector&lt;vector&gt;替换为list&lt;vector&gt;）"></a>406. 根据身高重建队列（C++贪心算法实现，将结果队列从vector&lt;vector<int>&gt;替换为list&lt;vector<int>&gt;）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">//使用list数组实现</span><br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; people.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> pos = people[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//使用迭代器</span><br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = result.<span class="hljs-built_in">begin</span>(); <br>            <span class="hljs-keyword">while</span>(pos--)&#123;<br>                it++;<br>            &#125;<br>            result.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>    &#125;<br>   <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="452-用最少数量的箭引爆气球（C-贪心算法实现）"><a href="#452-用最少数量的箭引爆气球（C-贪心算法实现）" class="headerlink" title="452. 用最少数量的箭引爆气球（C++贪心算法实现）"></a>452. 用最少数量的箭引爆气球（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//按照从小到大的顺序进行排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：寻找最少的x坐标，使得其落在尽可能多的区间内</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">//取排序后的第一个数组元素的右边界</span><br>        <span class="hljs-type">int</span> right = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//遍历从index=1开始的所有元素，得到最终的结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; right)&#123;<span class="hljs-comment">//表示下一个元素大于上一个的最小右right边界，需要增加箭的数量</span><br>                right = points[i][<span class="hljs-number">1</span>];<br>                result++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//表示该区间与上一个区间有交集</span><br>                right = <span class="hljs-built_in">min</span>(points[i][<span class="hljs-number">1</span>], right);<span class="hljs-comment">//更新right为该区间和上一个区间的最小right边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="435-无重叠区间（C-贪心算法实现）"><a href="#435-无重叠区间（C-贪心算法实现）" class="headerlink" title="435. 无重叠区间（C++贪心算法实现）"></a>435. 无重叠区间（C++贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//按照左边界进行升序排列</span><br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> eraseOverlapIntervals(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-comment">//思路：按照左边界进行排序之后，从index=1开始判断，该区间的左边界是否在右边界以内</span><br>        <span class="hljs-comment">//如果是，那么判断是删除当前区间还是删除上一个区间，这个看哪个区间的右边界大，右边界大的优先删除</span><br>        <span class="hljs-comment">//即可</span><br><br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end(), cmp);<br>        <span class="hljs-built_in">int</span> pre = <span class="hljs-number">0</span>;<span class="hljs-comment">//保存的前一个保留下来的数组index</span><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">int</span>ervals.size();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">int</span>ervals[pre][<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//判断保留下来哪一个区间</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">int</span>ervals[pre][<span class="hljs-number">1</span>])&#123;<br>                    pre = i;<span class="hljs-comment">//保存下来小的</span><br>                &#125;<br>                <span class="hljs-comment">//结果+1</span><br>                result ++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//表示没有交集，那么直接将保留区间index的变量pre更新为i</span><br>                pre = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="763-划分字母区间（C-贪心算法实现）"><a href="#763-划分字母区间（C-贪心算法实现）" class="headerlink" title="763. 划分字母区间（C++贪心算法实现）"></a>763. 划分字母区间（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//一共有27个英文字母</span><br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            hash[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br><br>        <span class="hljs-comment">//结果返回数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//更新end下标</span><br>            end = <span class="hljs-built_in">max</span>(end, hash[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span>(i == end)&#123;<br>                <span class="hljs-comment">//加入包含当前字母的区间长度</span><br>                result.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间（C-贪心算法实现）"><a href="#56-合并区间（C-贪心算法实现）" class="headerlink" title="56. 合并区间（C++贪心算法实现）"></a>56. 合并区间（C++贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    static <span class="hljs-built_in">bool</span> cmp(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; merge(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals.size() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals;<br>        &#125;<br><br>        <span class="hljs-comment">//思路：按照区间的左边界进行升序排序</span><br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end(), cmp);<br><br>        <span class="hljs-comment">//如果当前区间的左边界小于上一个区间的右边界，那么合并两个区间同时，更新left和right</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//定义的结果数组</span><br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; result;<br>        result.push_back(<span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-comment">//从index=1开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">int</span>ervals.size();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;= right)&#123;<br>                vector&lt;<span class="hljs-built_in">int</span>&gt; tmp;<br>                tmp.push_back(left);<br>                tmp.push_back(max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]));<br>                result.pop_back();<span class="hljs-comment">//弹出上一个区间</span><br>                result.push_back(tmp);<br>                <span class="hljs-comment">//更新right边界</span><br>                right = max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果当前的left大于等于上一个的右边界，那么直接加入即可，然后更新</span><br>                result.push_back(<span class="hljs-built_in">int</span>ervals[i]);<br>                left = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>                right = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="738-单调递增的数字（C-贪心算法实现）"><a href="#738-单调递增的数字（C-贪心算法实现）" class="headerlink" title="738. 单调递增的数字（C++贪心算法实现）"></a>738. 单调递增的数字（C++贪心算法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> monotoneIncreasingDigits(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-comment">//思路：将数字转换为字符串，然后判断strNum[i - 1]是否大于strNum[i]，如果是，</span><br>        <span class="hljs-comment">//需要将strNum[i - 1] --;同时将strNum[i]替换为9</span><br>        string strNum = to_string(n);<br><br>        <span class="hljs-keyword">int</span> flag = strNum.<span class="hljs-keyword">size</span>();<br><br>        <span class="hljs-comment">//从后向前遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = strNum.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i])&#123;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>                flag = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 从flag开始，全部设置为9</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = flag;i &lt; strNum.<span class="hljs-keyword">size</span>();i++)&#123;<br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stoi(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（困难）-968-监控二叉树（C-贪心算法实现）"><a href="#（困难）-968-监控二叉树（C-贪心算法实现）" class="headerlink" title="（困难） 968. 监控二叉树（C++贪心算法实现）"></a>（困难） 968. 监控二叉树（C++贪心算法实现）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs awk">/**<br> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), left(nullptr), right(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    <span class="hljs-regexp">//</span>返回结果的变量<br>    int result = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-regexp">//</span>遍历二叉树，按照从下往上的顺序进行<br>    int traversal(TreeNode* curr)&#123;<br>        <span class="hljs-regexp">//</span> 空结点，该结点有覆盖<br>        <span class="hljs-keyword">if</span>(curr == nullptr)&#123;<br>            return <span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>返回<span class="hljs-number">2</span>（状态<span class="hljs-number">2</span>表示该结点为空结点且有覆盖）<br>        &#125;<br><br>        <span class="hljs-regexp">//</span>得到left结点和right结点<br>        int left = traversal(curr-&gt;left);<span class="hljs-regexp">//</span>左结点<br>        int right = traversal(curr-&gt;right);<span class="hljs-regexp">//</span>右结点<br><br>        <span class="hljs-regexp">//</span>对中节点情况的处理<br>        <span class="hljs-regexp">//</span>情况<span class="hljs-number">1</span>：左右节点都有覆盖<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>)&#123;<br>            return <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>表示当前父结点<br>        &#125;<br><br>        <span class="hljs-regexp">//</span>情况<span class="hljs-number">2</span>分为如下几种：<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>，左右节点无覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">0</span>，左结点有摄像头，右结点无覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">1</span>，左节点无覆盖，右结点有摄像头<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">2</span>，左结点无覆盖，右结点有覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">0</span>，左结点有覆盖，右结点无覆盖<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>)&#123;<br>            result++;<span class="hljs-regexp">//</span>表示当左右结点至少有一个结点无覆盖时，在中结点增加摄像头<br>            return <span class="hljs-number">1</span>;<span class="hljs-regexp">//</span>表示增加摄像头<br>        &#125;<br><br><br>        <span class="hljs-regexp">//</span>情况<span class="hljs-number">3</span>分为如下几种：<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">2</span>，左节点有摄像头，右结点有覆盖<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">1</span>，左结点有覆盖，右结点有摄像头<br>        <span class="hljs-regexp">//</span>left == <span class="hljs-number">1</span> &amp;&amp; right == <span class="hljs-number">1</span>，左右节点均有摄像头<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-number">2</span>;<span class="hljs-regexp">//</span>那么left和right的父亲结点设置为<span class="hljs-number">2</span>，表示有覆盖<br>        &#125;<br><br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    int minCameraCover(TreeNode* root) &#123;<br>        result = <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span>初始化结果为<span class="hljs-number">0</span><br><br>        <span class="hljs-regexp">//</span>表示无覆盖<br>        <span class="hljs-keyword">if</span>(traversal(root) == <span class="hljs-number">0</span>)&#123;<br>            result ++;<br>        &#125;<br><br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>贪心算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230913</title>
    <link href="/2023/09/13/leetcode-notes-20230913/"/>
    <url>/2023/09/13/leetcode-notes-20230913/</url>
    
    <content type="html"><![CDATA[<h2 id="376-摆动序列（Java贪心实现）"><a href="#376-摆动序列（Java贪心实现）" class="headerlink" title="376. 摆动序列（Java贪心实现）"></a>376. 摆动序列（Java贪心实现）</h2><p>思路：先对数组进行升序排序，然后从后往前遍历胃口数组，遍历的同时去判断饼干数组是否有满足要求的数值，如果有，则结果返回变量result++。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> wiggleMaxLength(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> preDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> currDiff = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length - <span class="hljs-number">1</span>;i++)&#123;<br>            currDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-keyword">if</span>((preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp;currDiff &lt; <span class="hljs-number">0</span>) || (preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; currDiff &gt; <span class="hljs-number">0</span>))&#123;<br>                result ++;<br>                preDiff = currDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和（Java贪心实现）"><a href="#53-最大子数组和（Java贪心实现）" class="headerlink" title="53. 最大子数组和（Java贪心实现）"></a>53. 最大子数组和（Java贪心实现）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxSubArray(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-comment">//思路：首先遍历nums数组，定义count变量来记录从下标i开始的子数组元素累积和，如果出现count &lt;= 0       //的情况，更新count = 0即可，从头开始记录。</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">count</span> += nums[i];<br><br>            <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-keyword">count</span>)&#123;<br>                result = <span class="hljs-keyword">count</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II（Java贪心实现）"><a href="#122-买卖股票的最佳时机-II（Java贪心实现）" class="headerlink" title="122. 买卖股票的最佳时机 II（Java贪心实现）"></a>122. 买卖股票的最佳时机 II（Java贪心实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxProfit(<span class="hljs-built_in">int</span>[] prices) &#123;<br>        <span class="hljs-comment">//思路：首先某一天既可以买入也可以卖出。如果假设在i天买入在第i+5天卖出，</span><br>        <span class="hljs-comment">//实际上与从i天到i+5天每天买入和卖出，并取其中为正数的交易金额相加是一样的效果。</span><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; prices.length - <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i + <span class="hljs-number">1</span>] - prices[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                result += prices[i + <span class="hljs-number">1</span>] -prices[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-跳跃游戏（Java贪心算法实现）"><a href="#55-跳跃游戏（Java贪心算法实现）" class="headerlink" title="55. 跳跃游戏（Java贪心算法实现）"></a>55. 跳跃游戏（Java贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean canJump(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-comment">//思路：定义一个cover变量保存从当前下标开始能覆盖的最大index，</span><br>        <span class="hljs-comment">//如果cover大于或等于nums.length - 1，就表示能达到最后一个下标</span><br>        <span class="hljs-built_in">int</span> cover = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= cover;i ++)&#123;<br>            <span class="hljs-comment">//获得当前cover最大值</span><br>            cover = Math.max(i + nums[i], cover);<br><br>            <span class="hljs-keyword">if</span>(cover &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II（Java贪心算法实现）"><a href="#45-跳跃游戏-II（Java贪心算法实现）" class="headerlink" title="45. 跳跃游戏 II（Java贪心算法实现）"></a>45. 跳跃游戏 II（Java贪心算法实现）</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk">class Solution &#123;<br>    public int jump(int[] nums) &#123;<br>        <span class="hljs-regexp">//</span>思路：定义两个变量currDistance和nextDistance，<br>        <span class="hljs-regexp">//</span>其中currDistance表示从每次跳跃开始位置可以覆盖的最远坐标，<br>        <span class="hljs-regexp">//</span>nextDistance表示从遍历的i开始，能达到的最远范围，<br>        <span class="hljs-regexp">//</span>当i走到currDistance时，更新currDistance = nextDistance，表示从当前i位置开始<br>        <span class="hljs-regexp">//</span>能到达的最远坐标范围，然后判断最远范围是否可以覆盖到数组最后，如果可以那么就<span class="hljs-keyword">break</span>，<br>        <span class="hljs-regexp">//</span>这样就可以保证以最小的次数跳跃到数组最后。<br>        <br>        <span class="hljs-regexp">//</span>如果长度为<span class="hljs-number">0</span>，那么不需要跳跃<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        int currDistance = <span class="hljs-number">0</span>;<br>        int result = <span class="hljs-number">0</span>;<br>        int nextDistance = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-regexp">//</span>得到当前能达到的最大坐标值nextDistance<br>            nextDistance = Math.max(i + nums[i], nextDistance);<br>            <span class="hljs-regexp">//</span>表示到达了currDistance对应的坐标处<br>            <span class="hljs-keyword">if</span>(i == currDistance)&#123;<br>                <span class="hljs-regexp">//</span>更新currDistance<br>                currDistance = nextDistance;<br>                result ++;<span class="hljs-regexp">//</span>跳跃次数增加<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span>(currDistance &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1005-K-次取反后最大化的数组和（Java贪心实现）"><a href="#1005-K-次取反后最大化的数组和（Java贪心实现）" class="headerlink" title="1005. K 次取反后最大化的数组和（Java贪心实现）"></a>1005. K 次取反后最大化的数组和（Java贪心实现）</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-regexp">//使用Java 8特性中的IntStream来实现</span><br><span class="hljs-regexp">class Solution &#123;</span><br><span class="hljs-regexp">    public int largestSumAfterKNegations(int[] nums, int K) &#123;</span><br><span class="hljs-regexp">    //</span> 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小<br>nums = IntStream.<span class="hljs-keyword">of</span>(nums)<br>     .boxed()<br>     .sorted<span class="hljs-function"><span class="hljs-params">((o1, o2) -&gt; <span class="hljs-built_in">Math</span>.abs(o2) - <span class="hljs-built_in">Math</span>.abs(o1))</span></span><br><span class="hljs-function">     .<span class="hljs-title">mapToInt</span><span class="hljs-params">(Integer::intValue)</span>.<span class="hljs-title">toArray</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-title">len</span> = <span class="hljs-title">nums</span>.<span class="hljs-title">length</span>;    </span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">    //从前向后遍历，遇到负数将其变为正数，同时<span class="hljs-title">K</span>--</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>] = -<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">    <span class="hljs-title">K</span>--;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">// 如果<span class="hljs-title">K</span>还大于0，那么反复转变数值最小的元素，将<span class="hljs-title">K</span>用完</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)</span> <span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1] = -<span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1];</span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">stream</span><span class="hljs-params">(nums)</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">//使用带有排序规则器的方法实现</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">AbsoluteValueComparator</span> <span class="hljs-title">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Integer</span>&gt; &#123;</span><br><span class="hljs-function">        @<span class="hljs-title">Override</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">return</span> <span class="hljs-title">Math</span>.<span class="hljs-title">abs</span><span class="hljs-params">(b)</span> - <span class="hljs-title">Math</span>.<span class="hljs-title">abs</span><span class="hljs-params">(a)</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(int[] nums, int K)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">int</span> <span class="hljs-title">len</span> = <span class="hljs-title">nums</span>.<span class="hljs-title">length</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Integer</span>[] <span class="hljs-title">numsInteger</span> = <span class="hljs-title">new</span> <span class="hljs-title">Integer</span>[<span class="hljs-title">len</span>];</span><br><span class="hljs-function">        </span><br><span class="hljs-function">        // 将 <span class="hljs-title">int</span>[] 转换为 <span class="hljs-title">Integer</span>[]</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">numsInteger</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小</span><br><span class="hljs-function">        <span class="hljs-title">Arrays</span>.<span class="hljs-title">sort</span><span class="hljs-params">(numsInteger, <span class="hljs-keyword">new</span> AbsoluteValueComparator())</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        //将排序后的<span class="hljs-title">numsInteger</span>转为<span class="hljs-title">nums</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>] = <span class="hljs-title">numsInteger</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; len; i++)</span> &#123;</span><br><span class="hljs-function">            //从前向后遍历，遇到负数将其变为正数，同时<span class="hljs-title">K</span>--</span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(nums[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">nums</span>[<span class="hljs-title">i</span>] = -<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>];</span><br><span class="hljs-function">                <span class="hljs-title">K</span>--;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        // 如果<span class="hljs-title">K</span>还大于0，那么反复转变数值最小的元素，将<span class="hljs-title">K</span>用完</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)</span> <span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1] = -<span class="hljs-title">nums</span>[<span class="hljs-title">len</span> - 1];</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">stream</span><span class="hljs-params">(nums)</span>.<span class="hljs-title">sum</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="134-加油站（C-贪心算法实现）"><a href="#134-加油站（C-贪心算法实现）" class="headerlink" title="134. 加油站（C++贪心算法实现）"></a>134. 加油站（C++贪心算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-comment">//使用贪心算法实现</span><br>        <span class="hljs-comment">//思路：分三种情况，首先计算所有的gas[i] - cost[i]剩下的油总和是否小于0，</span><br>        <span class="hljs-comment">//第三种情况：如果是，那么表示从哪里出发也无法转一圈；</span><br>        <span class="hljs-comment">//第二种情况：如果min最小值大于0，表示从0出发可以达到；</span><br>        <span class="hljs-comment">//第三种情况：如果min最小值为负数，那么从0开始判断，哪个位置的油可以使得min值变为大于0的数</span><br>        <span class="hljs-comment">//那么这个位置i就是结果</span><br><br>        <span class="hljs-type">int</span> currSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> min = INT32_MAX;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; gas.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            currSum += rest;<br>            <span class="hljs-keyword">if</span>(currSum &lt; min)&#123;<br>                min = currSum;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(currSum &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(min &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//情况三，从后向前遍历实现</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = gas.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            min += rest;<br>            <span class="hljs-keyword">if</span>(min &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>贪心算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-notes-20230912.</title>
    <link href="/2023/09/12/leetcode-notes-20230912/"/>
    <url>/2023/09/12/leetcode-notes-20230912/</url>
    
    <content type="html"><![CDATA[<h2 id="455-分发饼干（C-实现贪心算法，先遍历胃口数组）"><a href="#455-分发饼干（C-实现贪心算法，先遍历胃口数组）" class="headerlink" title="455. 分发饼干（C++实现贪心算法，先遍历胃口数组）"></a>455. 分发饼干（C++实现贪心算法，先遍历胃口数组）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> find<span class="hljs-constructor">ContentChildren(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">g</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">//先对两个数组进行排序</span><br>        sort(g.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, g.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        sort(s.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, s.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>        <span class="hljs-built_in">int</span> index = s.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">//index保存饼干数组的当前位置</span><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录结果（孩子满足的人数）</span><br>        <span class="hljs-comment">//外层for循环遍历胃口数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = g.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(index &gt;=<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span> &gt;= g<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                index --;<br>                result ++;<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="455-分发饼干（C-实现贪心算法，先遍历饼干数组）"><a href="#455-分发饼干（C-实现贪心算法，先遍历饼干数组）" class="headerlink" title="455. 分发饼干（C++实现贪心算法，先遍历饼干数组）"></a>455. 分发饼干（C++实现贪心算法，先遍历饼干数组）</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> findContentChildren(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; g, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; s) &#123;<br>        sort(g.begin(), g.<span class="hljs-keyword">end</span>());<br>        sort(s.begin(), s.<span class="hljs-keyword">end</span>());<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        //先遍历饼干<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span> &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] &gt;= g[<span class="hljs-built_in">index</span>])&#123;<br>                <span class="hljs-built_in">index</span>++;<br>                result++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="376-摆动序列（C-贪心算法实现）"><a href="#376-摆动序列（C-贪心算法实现）" class="headerlink" title="376. 摆动序列（C++贪心算法实现）"></a>376. 摆动序列（C++贪心算法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> wiggleMaxLength(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.<span class="hljs-keyword">size</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> preDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> currDiff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>;i++)&#123;<br>            currDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">//如果出现峰值</span><br>            <span class="hljs-keyword">if</span>((preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; currDiff &lt; <span class="hljs-number">0</span>) || (preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; currDiff &gt; <span class="hljs-number">0</span>))&#123;<br>                result ++;<br>                preDiff = currDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和（C-贪心算法实现）"><a href="#53-最大子数组和（C-贪心算法实现）" class="headerlink" title="53. 最大子数组和（C++贪心算法实现）"></a>53. 最大子数组和（C++贪心算法实现）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> result = INT32_MIN;<br>        <span class="hljs-comment">//定义暂时保存的最大和变量count</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//单层for循环实现遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-comment">//更新count</span><br>            <span class="hljs-keyword">count</span> += nums[i];<br><br>            <span class="hljs-comment">//判断count是否大于result，大于result的话直接更新result为count的值</span><br>            <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-keyword">count</span>)&#123;<br>                result = <span class="hljs-keyword">count</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//判断count是否小于等于0，如果是，表示当前nums[i]为负，那么就更count为nums[i+1]</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II（C-贪心算法实现）"><a href="#122-买卖股票的最佳时机-II（C-贪心算法实现）" class="headerlink" title="122. 买卖股票的最佳时机 II（C++贪心算法实现）"></a>122. 买卖股票的最佳时机 II（C++贪心算法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                result += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II（Java贪心算法实现）"><a href="#122-买卖股票的最佳时机-II（Java贪心算法实现）" class="headerlink" title="122. 买卖股票的最佳时机 II（Java贪心算法实现）"></a>122. 买卖股票的最佳时机 II（Java贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxProfit(<span class="hljs-built_in">int</span>[] prices) &#123;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; prices.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] - prices[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                result += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-跳跃游戏（Java贪心算法实现）"><a href="#55-跳跃游戏（Java贪心算法实现）" class="headerlink" title="55. 跳跃游戏（Java贪心算法实现）"></a>55. 跳跃游戏（Java贪心算法实现）</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean canJump(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> cover = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= cover;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i + nums[i] &gt; cover)&#123;<br>                cover = i + nums[i];<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(cover &gt;= nums.length - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II（Java贪心算法实现）"><a href="#45-跳跃游戏-II（Java贪心算法实现）" class="headerlink" title="45. 跳跃游戏 II（Java贪心算法实现）"></a>45. 跳跃游戏 II（Java贪心算法实现）</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs glsl">class Solution &#123;<br>    public <span class="hljs-type">int</span> jump(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">length</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前定义的最小下标</span><br>        <span class="hljs-type">int</span> currDistance = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">length</span>;i++)&#123;<br>            nextDistance = Math.<span class="hljs-built_in">max</span>(nums[i] + i, nextDistance);<br>            <span class="hljs-keyword">if</span>(i == currDistance)&#123;<br>                result++;<br>                currDistance = nextDistance;<br>                <span class="hljs-keyword">if</span>(nextDistance &gt;= nums.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>贪心算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230904</title>
    <link href="/2023/09/04/leetcode-notes-20230904/"/>
    <url>/2023/09/04/leetcode-notes-20230904/</url>
    
    <content type="html"><![CDATA[<h2 id="47-全排列-II（C-回溯算法实现）"><a href="#47-全排列-II（C-回溯算法实现）" class="headerlink" title="47. 全排列 II（C++回溯算法实现）"></a>47. 全排列 II（C++回溯算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-comment">//在叶子结点收集元素</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i ++)&#123;<br>            <span class="hljs-comment">// 判断同层中是否已经使用了相同的元素</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示已经使用过了</span><br>            &#125;<br><br>            <span class="hljs-comment">//表示当前元素没有使用过</span><br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">false</span>)&#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracing</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="51-N-皇后（C-回溯法实现）"><a href="#51-N-皇后（C-回溯法实现）" class="headerlink" title="51. N 皇后（C++回溯法实现）"></a>51. N 皇后（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//判断是否合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//检查列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; row;i ++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][col] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//检查左上角45度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//检查右下角135度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessboard[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row == n)&#123;<span class="hljs-comment">//表示到最后一层了</span><br>            result.<span class="hljs-built_in">push_back</span>(chessboard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//循环棋盘，然后判断是否合法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(row, col, chessboard, n))&#123;<span class="hljs-comment">//如果合法，那么修改棋盘</span><br>                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<span class="hljs-comment">//放置皇后</span><br>                <span class="hljs-built_in">backtracing</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(n, <span class="hljs-number">0</span>, chessboard);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230828</title>
    <link href="/2023/08/28/leetcode-notes-20230828/"/>
    <url>/2023/08/28/leetcode-notes-20230828/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）78-子集（C-回溯法实现）"><a href="#（复习）78-子集（C-回溯法实现）" class="headerlink" title="（复习）78. 子集（C++回溯法实现）"></a>（复习）78. 子集（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>    &#125;<br><br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="90-子集-II（C-回溯实现）"><a href="#90-子集-II（C-回溯实现）" class="headerlink" title="90. 子集 II（C++回溯实现）"></a>90. 子集 II（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br><br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="491-递增子序列（C-回溯法实现递增子序列）"><a href="#491-递增子序列（C-回溯法实现递增子序列）" class="headerlink" title="491. 递增子序列（C++回溯法实现递增子序列）"></a>491. 递增子序列（C++回溯法实现递增子序列）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//题目中要求大于2的序列</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-comment">// return;不能加return是因为，需要取树上的所有结点</span><br>        &#125;<br><br>        <span class="hljs-comment">//定义本层去重需要使用的unordered_set</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]) || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="491-递增子序列（C-回溯法实现递增子序列，使用int数组代替unordered-set）"><a href="#491-递增子序列（C-回溯法实现递增子序列，使用int数组代替unordered-set）" class="headerlink" title="491. 递增子序列（C++回溯法实现递增子序列，使用int数组代替unordered_set）"></a>491. 递增子序列（C++回溯法实现递增子序列，使用int数组代替unordered_set）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//题目中要求大于2的序列</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-comment">// return;不能加return是因为，需要取树上的所有结点</span><br>        &#125;<br><br>        <span class="hljs-comment">//定义本层去重需要使用的unordered_set</span><br>        <span class="hljs-comment">//unordered_set&lt;int&gt; uset;</span><br>        <span class="hljs-comment">//使用int类型数组代替unordered_set</span><br>        <span class="hljs-type">int</span> unums[<span class="hljs-number">201</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]) || unums[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-comment">//uset.insert(nums[i]);</span><br>            unums[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="46-全排列（C-回溯法实现，使用used数组标记是否使用过）"><a href="#46-全排列（C-回溯法实现，使用used数组标记是否使用过）" class="headerlink" title="46. 全排列（C++回溯法实现，使用used数组标记是否使用过）"></a>46. 全排列（C++回溯法实现，使用used数组标记是否使用过）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//因为是全排列，所以当path的长度等于nums的长度时，得到结果</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示当前nums[i]元素已经使用过</span><br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(nums, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230820</title>
    <link href="/2023/08/20/leetcode-notes-20230820/"/>
    <url>/2023/08/20/leetcode-notes-20230820/</url>
    
    <content type="html"><![CDATA[<h2 id="131-分割回文串（C-回溯法实现）"><a href="#131-分割回文串（C-回溯法实现）" class="headerlink" title="131. 分割回文串（C++回溯法实现）"></a>131. 分割回文串（C++回溯法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//判断字符串是否为回文串的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                <span class="hljs-comment">//截取字符串</span><br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果不是回文数</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//回溯过程，返回已经添加的子串</span><br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）93-复原-IP-地址（C-回溯实现）"><a href="#（复习）93-复原-IP-地址（C-回溯实现）" class="headerlink" title="（复习）93. 复原 IP 地址（C++回溯实现）"></a>（复习）93. 复原 IP 地址（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-comment">//判断是否合法的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断start对应的s中的字符是否为0</span><br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//然后进行判断</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end;i++)&#123;<br>            <span class="hljs-comment">//首先判断每个数字是否合法</span><br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果数组都合法，然后计算从start到end对应的数字之和是否超过了255</span><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span></span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span>(pointNum == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-comment">//判断最后一个逗点之后的字符串是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//判断是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointNum += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//递归调用函数，由于加入了一个点，因此下一个开始index应该为i + 2</span><br>                <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">2</span>, pointNum);<br>                pointNum -= <span class="hljs-number">1</span>;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="（复习）78-子集（C-实现）"><a href="#（复习）78-子集（C-实现）" class="headerlink" title="（复习）78. 子集（C++实现）"></a>（复习）78. 子集（C++实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtraing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtraing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtraing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230817</title>
    <link href="/2023/08/17/leetcode-notes-20230817/"/>
    <url>/2023/08/17/leetcode-notes-20230817/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）40-组合总和-II（C-回溯算法实现）"><a href="#（复习）40-组合总和-II（C-回溯算法实现）" class="headerlink" title="（复习）40. 组合总和 II（C++回溯算法实现）"></a>（复习）40. 组合总和 II（C++回溯算法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义两个数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-comment">//定义回溯函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum ==target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//单层循环逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i<span class="hljs-number">-1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>]==<span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//表示树的同层中的上一个一样的元素使用过了</span><br>            &#125;<br><br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//实现了函数中间</span><br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracing</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230802</title>
    <link href="/2023/08/02/leetcode-notes-20230802/"/>
    <url>/2023/08/02/leetcode-notes-20230802/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）131-分割回文串（C-回溯法实现，无优化版）"><a href="#（复习）131-分割回文串（C-回溯法实现，无优化版）" class="headerlink" title="（复习）131. 分割回文串（C++回溯法实现，无优化版）"></a>（复习）131. 分割回文串（C++回溯法实现，无优化版）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-comment">//设置函数判断输入字符串是否为回文串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; huiwen, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j;i++, j--)&#123;<br>            <span class="hljs-keyword">if</span>(huiwen[i] != huiwen[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯中单层逻辑实现</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex;i &lt; s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="93-复原-IP-地址（C-回溯实现）"><a href="#93-复原-IP-地址（C-回溯实现）" class="headerlink" title="93. 复原 IP 地址（C++回溯实现）"></a>93. 复原 IP 地址（C++回溯实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-comment">//判断是否为合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//两个逗号之间的字符串的开始位置为0，表示不合法</span><br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//记录两个逗号之间的数字相加是否在255范围之内</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end;i ++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> || s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//num累加</span><br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <br>            <span class="hljs-comment">//判断num是否大于255</span><br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">//设置的回溯算法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointSum)</span></span>&#123;<br>        <span class="hljs-comment">//判断pointSum等于3，表示是一个可能的结果</span><br>        <span class="hljs-keyword">if</span>(pointSum == <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>))&#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-comment">//首先判断是否合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i))&#123;<br>                <span class="hljs-comment">//在i位置之后插入一个点</span><br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                pointSum += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//回溯调用</span><br>                <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">2</span>, pointSum);<br>                pointSum -= <span class="hljs-number">1</span>;<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="78-子集（C-回溯法实现）"><a href="#78-子集（C-回溯法实现）" class="headerlink" title="78. 子集（C++回溯法实现）"></a>78. 子集（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">if</span>(startIndex &gt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracing</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230729</title>
    <link href="/2023/07/29/leetcode-notes-20230729/"/>
    <url>/2023/07/29/leetcode-notes-20230729/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）39-组合总和（C-回溯法实现）"><a href="#（复习）39-组合总和（C-回溯法实现）" class="headerlink" title="（复习）39. 组合总和（C++回溯法实现）"></a>（复习）39. 组合总和（C++回溯法实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-type">void</span> backtracing(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> index)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &gt; <span class="hljs-built_in">target</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>            result.push_back(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            path.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            path.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        result.clear();<br>        path.clear();<br>        <br>        backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="40-组合总和-II（C-回溯法实现）"><a href="#40-组合总和-II（C-回溯法实现）" class="headerlink" title="40. 组合总和 II（C++回溯法实现）"></a>40. 组合总和 II（C++回溯法实现）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//核心思想：需要增加used数据，来判断是否使用过</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++)&#123;<br>            <span class="hljs-comment">//判断used数组中是否已经使用过i位置元素</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracing</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//先将candidates进行排序</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-built_in">backtracing</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串（C-回溯法实现，无优化版）"><a href="#131-分割回文串（C-回溯法实现，无优化版）" class="headerlink" title="131. 分割回文串（C++回溯法实现，无优化版）"></a>131. 分割回文串（C++回溯法实现，无优化版）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//判断是否为回文字符串的函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHuiWen</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; huiwen, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--)&#123;<br>            <span class="hljs-keyword">if</span>(huiwen[i] != huiwen[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex &gt;= s.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯法中单层逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isHuiWen</span>(s, startIndex, i))&#123;<br>                string tmp = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//回溯调用</span><br>            <span class="hljs-built_in">backtracing</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">backtracing</span>(s, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230728</title>
    <link href="/2023/07/28/leetcode-notes-20230728/"/>
    <url>/2023/07/28/leetcode-notes-20230728/</url>
    
    <content type="html"><![CDATA[<h2 id="复习：77-组合（C-回溯-剪枝实现）"><a href="#复习：77-组合（C-回溯-剪枝实现）" class="headerlink" title="复习：77. 组合（C++回溯+剪枝实现）"></a>复习：77. 组合（C++回溯+剪枝实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//定义保存路径的数组</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//定义保存整个结果的result数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//回溯实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="216-组合总和-III（C-回溯实现）"><a href="#216-组合总和-III（C-回溯实现）" class="headerlink" title="216. 组合总和 III（C++回溯实现）"></a>216. 组合总和 III（C++回溯实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯算法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-comment">//判断path.size()是否等于k</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            <span class="hljs-comment">//判断targetSum是否等于n</span><br>            <span class="hljs-keyword">if</span>(sum == n)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//回溯单层逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>;i++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            sum += i;<br>            <span class="hljs-built_in">backtracing</span>(k, n, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracing</span>(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合（C-回溯实现）"><a href="#17-电话号码的字母组合（C-回溯实现）" class="headerlink" title="17. 电话号码的字母组合（C++回溯实现）"></a>17. 电话号码的字母组合（C++回溯实现）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义字母和数字之间的映射</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> num2str[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-comment">//0</span><br>        <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-comment">//1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-comment">//2</span><br>        <span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-comment">//3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-comment">//4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-comment">//5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-comment">//6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-comment">//7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-comment">//8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>,<span class="hljs-comment">//9</span><br>    &#125;;<br><br>    vector&lt;<span class="hljs-built_in">string</span>&gt; result;<br>    <span class="hljs-built_in">string</span> s;<span class="hljs-comment">//这个string类型变量就相当于path</span><br><br>    <span class="hljs-comment">//回溯算法实现</span><br>    <span class="hljs-comment">//参数为传入digits地址，起始index下标</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracing</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; digits, <span class="hljs-built_in">int</span> startIndex</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(startIndex == digits.size())&#123;<br>            result.push_back(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//将digits中对应startIndex位置的数字转为数字</span><br>        <span class="hljs-built_in">int</span> digit = digits[startIndex] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">string</span> letters = num2str[digit];<br><br>        <span class="hljs-comment">//单层回溯逻辑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; letters.size();i++)&#123;<br>            s.push_back(letters[i]);<br>            backtracing(digits, startIndex + <span class="hljs-number">1</span>);<br>            s.pop_back();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">letterCombinations</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> digits</span>)</span> &#123;<br>        s.clear();<br>        result.clear();<br>        <span class="hljs-keyword">if</span>(digits.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        backtracing(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和（C-回溯法实现）"><a href="#39-组合总和（C-回溯法实现）" class="headerlink" title="39. 组合总和（C++回溯法实现）"></a>39. 组合总和（C++回溯法实现）</h2><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-comment">//回溯法实现</span><br>    <span class="hljs-type">void</span> backtracing(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-type">int</span> index)&#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-built_in">target</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>            result.push_back(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            path.push_back(candidates[i]);<br>            <span class="hljs-built_in">sum</span> += candidates[i];<br>            backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-built_in">sum</span>, i);<br>            <span class="hljs-built_in">sum</span> -= candidates[i];<br>            path.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; combinationSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        result.clear();<br>        path.clear();<br><br>        backtracing(candidates, <span class="hljs-built_in">target</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230727</title>
    <link href="/2023/07/27/leetcode-notes-20230727/"/>
    <url>/2023/07/27/leetcode-notes-20230727/</url>
    
    <content type="html"><![CDATA[<h2 id="（复习）108-将有序数组转换为二叉搜索树"><a href="#（复习）108-将有序数组转换为二叉搜索树" class="headerlink" title="（复习）108. 将有序数组转换为二叉搜索树"></a>（复习）108. 将有序数组转换为二叉搜索树</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//创建保存结点的队列</span><br>        queue&lt;TreeNode*&gt; nodeQ;<br>        <span class="hljs-comment">//创建保存左left边界的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQ;<br>        <span class="hljs-comment">//创建保存右right边界的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQ;<br><br>        <span class="hljs-comment">//初始化一个空结点并加入到队列中</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>        nodeQ.<span class="hljs-keyword">push</span>(root);<br><br>        <span class="hljs-comment">//将left和right加入到对应的队列中</span><br>        leftQ.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);<br>        rightQ.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//循环遍历实现对树的构造</span><br>        <span class="hljs-keyword">while</span>(!nodeQ.empty())&#123;<br>            <span class="hljs-comment">//首先得到nodeQ队列头部的结点进行赋值</span><br>            TreeNode* curr = nodeQ.front();<br>            nodeQ.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-comment">//得到left和right</span><br>            <span class="hljs-keyword">int</span> left = leftQ.front();<br>            leftQ.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> right = rightQ.front();<br>            rightQ.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>            curr-&gt;val = nums[mid];<br><br>            <span class="hljs-comment">//处理左子树</span><br>            <span class="hljs-keyword">if</span>(left &lt;= mid - <span class="hljs-number">1</span>)&#123;<br>                curr-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                leftQ.<span class="hljs-keyword">push</span>(left);<br>                rightQ.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>                nodeQ.<span class="hljs-keyword">push</span>(curr-&gt;left);<br>            &#125;<br><br>            <span class="hljs-comment">//处理右子树</span><br>            <span class="hljs-keyword">if</span>(right &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>                curr-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                leftQ.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>                rightQ.<span class="hljs-keyword">push</span>(right);<br>                nodeQ.<span class="hljs-keyword">push</span>(curr-&gt;right);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树（C-递归实现）"><a href="#538-把二叉搜索树转换为累加树（C-递归实现）" class="headerlink" title="538. 把二叉搜索树转换为累加树（C++递归实现）"></a>538. 把二叉搜索树转换为累加树（C++递归实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br><br>    void convertBSTHelper(TreeNode* root, int &amp;<span class="hljs-built_in">sum</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        // 遍历右子树<br>        convertBSTHelper(root-&gt;<span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>);<br><br>        // 更新当前节点的值为累加和<br>        <span class="hljs-built_in">sum</span> += root-&gt;val;<br>        root-&gt;val = <span class="hljs-built_in">sum</span>;<br><br>        // 遍历左子树<br>        convertBSTHelper(root-&gt;<span class="hljs-built_in">left</span>, <span class="hljs-built_in">sum</span>);<br>    &#125;<br><br>    TreeNode* convertBST(TreeNode* root) &#123;<br>        //使用递归实现<br>        int <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        convertBSTHelper(root, <span class="hljs-built_in">sum</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="538-把二叉搜索树转换为累加树（C-迭代法实现）"><a href="#538-把二叉搜索树转换为累加树（C-迭代法实现）" class="headerlink" title="538. 把二叉搜索树转换为累加树（C++迭代法实现）"></a>538. 把二叉搜索树转换为累加树（C++迭代法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pre;<span class="hljs-comment">//pre保存当前累加值</span><br><br>    <span class="hljs-comment">//使用迭代法实现</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_new_BST</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        TreeNode* curr = root;<br>        <span class="hljs-comment">//使用栈保存树的结点，实现迭代遍历</span><br>        stack&lt;TreeNode*&gt; st;<br><br>        <span class="hljs-comment">//使用循环实现，按照右中左实现反中序遍历</span><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(curr);<br>                curr = curr-&gt;right;<span class="hljs-comment">//右</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//中</span><br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                curr-&gt;val += pre;<br><br>                pre = curr-&gt;val;<span class="hljs-comment">//更新累加之后的值</span><br><br>                <span class="hljs-comment">//左</span><br>                curr = curr-&gt;left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        pre = <span class="hljs-number">0</span>;<br>        TreeNode* resultNode = <span class="hljs-built_in">get_new_BST</span>(root);<br>        <span class="hljs-keyword">return</span> resultNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="77-组合（C-回溯法实现）"><a href="#77-组合（C-回溯法实现）" class="headerlink" title="77. 组合（C++回溯法实现）"></a>77. 组合（C++回溯法实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置path保存当前层的满足题意结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//设置保存所有path的result结果数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//使用回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n;i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯回来之后，弹出最后一个元素</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//首先清空result数组</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//path清空</span><br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//调用回溯法</span><br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="77-组合（C-回溯法剪枝实现）"><a href="#77-组合（C-回溯法剪枝实现）" class="headerlink" title="77. 组合（C++回溯法剪枝实现）"></a>77. 组合（C++回溯法剪枝实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//设置path保存当前层的满足题意结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">//设置保存所有path的result结果数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-comment">//使用回溯法实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huisu</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startIndex)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>;i ++)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//递归调用</span><br>            <span class="hljs-built_in">huisu</span>(n, k, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯回来之后，弹出最后一个元素</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//首先清空result数组</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//path清空</span><br>        path.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-comment">//调用回溯法</span><br>        <span class="hljs-built_in">huisu</span>(n, k, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
      <tag>回溯算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230726</title>
    <link href="/2023/07/26/leetcode-notes-20230726/"/>
    <url>/2023/07/26/leetcode-notes-20230726/</url>
    
    <content type="html"><![CDATA[<h2 id="复习：669-修剪二叉搜索树（迭代法实现，C-）"><a href="#复习：669-修剪二叉搜索树（迭代法实现，C-）" class="headerlink" title="复习：669. 修剪二叉搜索树（迭代法实现，C++）"></a>复习：669. 修剪二叉搜索树（迭代法实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-comment">//修剪二叉树，迭代实现</span><br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//修剪root节点</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(root != NULL &amp;&amp; (root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root -&gt;</span> right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root -&gt;</span> left;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">//修剪root结点的左子树小于low的情况</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-comment">//循环找到左边界</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> = curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">left</span> -&gt;</span> right;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr -&gt;</span> left;<br>        &#125;<br><br>        curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-comment">//循环处理右子树大于high的情况</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = curr -&gt;</span> <span class="hljs-function"><span class="hljs-title">right</span> -&gt;</span> left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>right;<br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树（C-递归法实现）"><a href="#108-将有序数组转换为二叉搜索树（C-递归法实现）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（C++递归法实现）"></a>108. 将有序数组转换为二叉搜索树（C++递归法实现）</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs excel">/**<br> * Definition for a binary tree node.<br> * struct TreeNode &#123;<br> *     <span class="hljs-built_in">int</span> val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() <span class="hljs-symbol">:</span> val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(<span class="hljs-built_in">int</span> x) <span class="hljs-symbol">:</span> val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(<span class="hljs-built_in">int</span> x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) <span class="hljs-symbol">:</span> val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br><br>    //使用递归法实现<br>    TreeNode* digui(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span> &gt; <span class="hljs-built_in">right</span>)&#123;<br>            return NULL;<br>        &#125;<br><br>        //单层递归逻辑<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + ((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br>        TreeNode* root = new TreeNode(nums[<span class="hljs-built_in">mid</span>]);<br><br>        //递归调用<br>        root-&gt;<span class="hljs-built_in">left</span> = digui(nums, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>);<br>        root-&gt;<span class="hljs-built_in">right</span> = digui(nums, <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);<br><br>        return root;<br>    &#125;<br><br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        //使用迭代法实现<br>        return digui(nums, <span class="hljs-number">0</span>, nums.size() - <span class="hljs-number">1</span>);    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树（C-迭代法实现）"><a href="#108-将有序数组转换为二叉搜索树（C-迭代法实现）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（C++迭代法实现）"></a>108. 将有序数组转换为二叉搜索树（C++迭代法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* sortedArrayToBST(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//初始化根结点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>        queue&lt;TreeNode*&gt; nodeQueue;<span class="hljs-comment">//创建队列保存树结点</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; leftQueue;<span class="hljs-comment">//创建保存left左下标的队列</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; rightQueue;<span class="hljs-comment">//创建保存right右下标的队列</span><br><br>        <span class="hljs-comment">//将left=0和right=nums.size()-1分别放到left和right队列中</span><br>        nodeQueue.<span class="hljs-keyword">push</span>(root);<br>        leftQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">0</span>);<br>        rightQueue.<span class="hljs-keyword">push</span>(nums.<span class="hljs-keyword">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//使用while循环</span><br>        <span class="hljs-keyword">while</span>(!nodeQueue.empty())&#123;<br>            <span class="hljs-comment">//得到当前结点</span><br>            TreeNode* curr = nodeQueue.front();<br>            nodeQueue.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-comment">//拿到left和right下标</span><br>            <span class="hljs-keyword">int</span> left = leftQueue.front();<br>            leftQueue.<span class="hljs-keyword">pop</span>();<br>            <span class="hljs-keyword">int</span> right = rightQueue.front();<br>            rightQueue.<span class="hljs-keyword">pop</span>();<br><br>            <span class="hljs-keyword">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br><br>            curr-&gt;val = nums[mid];<span class="hljs-comment">//将nums[mid]值复制给curr-&gt;val</span><br><br><br>            <span class="hljs-comment">//处理左子树</span><br>            <span class="hljs-keyword">if</span>(left &lt;= mid - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//向nodeQueue中加入left空结点，用于下次赋值</span><br>                curr-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQueue.<span class="hljs-keyword">push</span>(curr-&gt;left);<br>                leftQueue.<span class="hljs-keyword">push</span>(left);<br>                rightQueue.<span class="hljs-keyword">push</span>(mid - <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//处理右子树</span><br>            <span class="hljs-keyword">if</span>(right &gt;= mid + <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//向nodeQueue中加入right空结点，用于下次赋值</span><br>                curr-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">0</span>);<br>                nodeQueue.<span class="hljs-keyword">push</span>(curr-&gt;right);<br>                rightQueue.<span class="hljs-keyword">push</span>(right);<br>                leftQueue.<span class="hljs-keyword">push</span>(mid + <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230719</title>
    <link href="/2023/07/19/leetcode-notes-20230719/"/>
    <url>/2023/07/19/leetcode-notes-20230719/</url>
    
    <content type="html"><![CDATA[<h2 id="669-修剪二叉搜索树（递归实现，C-）"><a href="#669-修剪二叉搜索树（递归实现，C-）" class="headerlink" title="669. 修剪二叉搜索树（递归实现，C++）"></a>669. 修剪二叉搜索树（递归实现，C++）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* trim<span class="hljs-constructor">BST(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span> &#123;<br>        <span class="hljs-comment">//迭代实现</span><br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//当前结点的值小于low，那么遍历root的right右子树</span><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; low)&#123;<br>            TreeNode* node = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>            return node;<br>        &#125;<br><br>        <span class="hljs-comment">//当前结点的值大于high，那么遍历root的左子树</span><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; high)&#123;<br>            TreeNode* node = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>            return node;<br>        &#125;<br><br>        root-&gt;left = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>        root-&gt;right = trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">low</span>, <span class="hljs-params">high</span>)</span>;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树（迭代法实现，C-）"><a href="#669-修剪二叉搜索树（迭代法实现，C-）" class="headerlink" title="669. 修剪二叉搜索树（迭代法实现，C++）"></a>669. 修剪二叉搜索树（迭代法实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return NULL;<br>        &#125;<br><br>        <span class="hljs-comment">//处理根结点，将新树的root结点调节到low,hight之间</span><br>        <span class="hljs-function"><span class="hljs-title">while</span>(root != NULL &amp;&amp; (root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; low || root-&gt;</span>val &gt; high))&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//继续处理</span><br>        TreeNode* curr = root;<br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<span class="hljs-comment">//处理左子树小于low的情况</span><br>            <span class="hljs-comment">//循环找到左边界</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>val &lt; low)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = curr-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span>right;<br>            &#125;<br>            <span class="hljs-comment">//处理curr结点的</span><br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>left;<br>        &#125;<br><br>        <span class="hljs-comment">//处理root结点的右边，将大于high的结点删除掉</span><br>        curr = root;<br><br>        <span class="hljs-keyword">while</span>(curr != NULL)&#123;<br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> != NULL &amp;&amp; curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>val &gt; high)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = curr-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span>left;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>right;<br>        &#125;<br><br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230718</title>
    <link href="/2023/07/18/leetcode-notes-20230718/"/>
    <url>/2023/07/18/leetcode-notes-20230718/</url>
    
    <content type="html"><![CDATA[<h2 id="701-二叉搜索树中的插入操作（递归实现，C-）"><a href="#701-二叉搜索树中的插入操作（递归实现，C-）" class="headerlink" title="701. 二叉搜索树中的插入操作（递归实现，C++）"></a>701. 二叉搜索树中的插入操作（递归实现，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        //用递归方法实现<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            TreeNode* node = new TreeNode(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val)&#123;<br>            root-&gt;<span class="hljs-built_in">left</span> = insertIntoBST(root-&gt;<span class="hljs-built_in">left</span>, val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val)&#123;<br>            root-&gt;<span class="hljs-built_in">right</span> = insertIntoBST(root-&gt;<span class="hljs-built_in">right</span>,val);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="701-二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C-）"><a href="#701-二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C-）" class="headerlink" title="701. 二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C++）"></a>701. 二叉搜索树中的插入操作（迭代遍历二叉搜索树实现插入节点，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;<br>        //使用迭代法实现<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            TreeNode* node = new TreeNode(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        TreeNode* curr = root;<br>        TreeNode* parent = root;<br>        while(curr != NULL)&#123;//while循环当curr等于NULL时弹出，就是需要插入的节点位置<br>            parent = curr;<br>            <span class="hljs-keyword">if</span>(curr-&gt;val &lt; val)&#123;<br>                curr = curr-&gt;<span class="hljs-built_in">right</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = curr-&gt;<span class="hljs-built_in">left</span>;<br>            &#125;<br>        &#125;<br><br>        //处理parent和新插入的节点位置的关系<br>        TreeNode* node = new TreeNode(val);<br>        <span class="hljs-keyword">if</span>(parent-&gt;val &gt; val)&#123;//表示插入点在parent的左<br>            parent-&gt;<span class="hljs-built_in">left</span> = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent-&gt;<span class="hljs-built_in">right</span> = node;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="450-删除二叉搜索树中的节点（递归实现，C-）"><a href="#450-删除二叉搜索树中的节点（递归实现，C-）" class="headerlink" title="450. 删除二叉搜索树中的节点（递归实现，C++）"></a>450. 删除二叉搜索树中的节点（递归实现，C++）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>public:<br>    TreeNode* deleteNode(TreeNode* root, int key) &#123;<br><br>        <span class="hljs-comment">//删除二叉搜索树的结点</span><br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-comment">//第一种情况，key对应的结点为叶子结点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(root -&gt;</span> <span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> == NULL &amp;&amp; root-&gt;</span>right == NULL)&#123;<br>            delete root;<br>            return NULL;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; root-&gt;</span>right == NULL)&#123;<span class="hljs-comment">//第二种情况，删除节点有左子树</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* node = root-&gt;</span>left;<br>            delete root;<br>            return node;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> == NULL &amp;&amp; root-&gt;</span>right != NULL)&#123;<span class="hljs-comment">//第三种情况，删除节点有右子树</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* node = root-&gt;</span>right;<br>            delete root;<br>            return node;<br>        &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> == key &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> != NULL &amp;&amp; root-&gt;</span>right != NULL)&#123;<span class="hljs-comment">//第四种情况，删除节点左右子树都存在</span><br>            T<span class="hljs-function"><span class="hljs-title">reeNode</span>* curr = root-&gt;</span>right;<span class="hljs-comment">//遍历要删除的结点的右子树</span><br>            <span class="hljs-comment">//找到要删除结点的右子树的最左边子树的结点</span><br>            <span class="hljs-function"><span class="hljs-title">while</span>(curr-&gt;</span>left != NULL)&#123;<br>                <span class="hljs-function"><span class="hljs-title">curr</span> = curr-&gt;</span>left;<br>            &#125;<br><br>            <span class="hljs-comment">//将删除节点的左子树移动到上述curr对应的结点的左子树上</span><br>            <span class="hljs-function"><span class="hljs-title">curr</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = root-&gt;</span>left;<br>            <span class="hljs-comment">//记录要删除的节点</span><br>            TreeNode* tmp = root;<br>            <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<span class="hljs-comment">//返回结点的右子树作为根节点</span><br>            delete tmp;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-comment">//然后用root-&gt;left/right来接着对应的递归返回节点</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &lt; key)&#123;<br>            <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span> = deleteNode(root-&gt;</span>right, key);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span>val &gt; key)&#123;<br>            <span class="hljs-function"><span class="hljs-title">root</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = deleteNode(root-&gt;</span>left, key);<br>        &#125;<br>        return root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230716</title>
    <link href="/2023/07/16/leetcode-notes-20230716/"/>
    <url>/2023/07/16/leetcode-notes-20230716/</url>
    
    <content type="html"><![CDATA[<h2 id="98-验证二叉搜索树（迭代，C-）"><a href="#98-验证二叉搜索树（迭代，C-）" class="headerlink" title="98.验证二叉搜索树（迭代，C++）"></a>98.验证二叉搜索树（迭代，C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//使用栈来进行迭代法实现（中序遍历迭代）</span><br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* currNode = root;<br>        TreeNode* preNode = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">//使用同一迭代法遍历树结点</span><br>        <span class="hljs-keyword">while</span>(currNode != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(currNode != <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-comment">//将当前结点加入到栈中</span><br>                st.<span class="hljs-built_in">push</span>(currNode);<br>                currNode = currNode -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                currNode = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//中</span><br>                <span class="hljs-keyword">if</span>(preNode != <span class="hljs-literal">NULL</span> &amp;&amp; currNode-&gt;val &lt;= preNode-&gt;val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//保存前一个结点</span><br>                preNode = currNode;<br>                <span class="hljs-comment">//右</span><br>                currNode = currNode -&gt; right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="530-二叉搜索树的最小绝对差（迭代，C-）"><a href="#530-二叉搜索树的最小绝对差（迭代，C-）" class="headerlink" title="530. 二叉搜索树的最小绝对差（迭代，C++）"></a>530. 二叉搜索树的最小绝对差（迭代，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    //设置最小插值默认为最大<br>    long long result = LONG_MAX;<br>    int getMinimumDifference(TreeNode* root) &#123;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* pre = NULL;<br>        TreeNode* curr = root;<br><br>        while(curr != NULL |<span class="hljs-type">| !st</span>.empty())&#123;<br>            <span class="hljs-keyword">if</span>(curr != NULL)&#123;<br>                st.push(curr);<br>                curr = curr -&gt; <span class="hljs-built_in">left</span>;//左中右<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.pop();<br>                <span class="hljs-keyword">if</span>(pre != NULL &amp;&amp; abs(pre-&gt;val - curr-&gt;val) &lt; result)&#123;<br>                    result = abs(pre-&gt;val - curr-&gt;val);<br>                &#125;<br>                pre = curr;<br>                curr = curr -&gt; <span class="hljs-built_in">right</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（迭代，C-）"><a href="#501-二叉搜索树中的众数（迭代，C-）" class="headerlink" title="501.二叉搜索树中的众数（迭代，C++）"></a>501.二叉搜索树中的众数（迭代，C++）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        TreeNode* curr = root;<br>        <span class="hljs-comment">//创建Map以保存每个树结点对应的次数</span><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>                st.<span class="hljs-built_in">push</span>(curr);<br>                curr = curr -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//中</span><br>                curr = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                dict[curr-&gt;val]++;<br><br>                <span class="hljs-comment">//右边</span><br>                curr = curr -&gt; right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到最大的出现次数</span><br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : dict) &#123;<br>            <span class="hljs-keyword">if</span> (entry.second &gt; maxCount) &#123;<br>                maxCount = entry.second;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 找到出现次数等于最大值的数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : dict) &#123;<br>            <span class="hljs-keyword">if</span> (entry.second == maxCount) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(entry.first);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（递归，C-）"><a href="#501-二叉搜索树中的众数（递归，C-）" class="headerlink" title="501.二叉搜索树中的众数（递归，C++）"></a>501.二叉搜索树中的众数（递归，C++）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> max_count = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大出现次数</span><br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前count</span><br>    TreeNode* pre = NULL;<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; result;<br><br>    void <span class="hljs-constructor">BSTdigui(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-comment">//按照左中右的顺序遍历</span><br>        <span class="hljs-comment">//遍历左子树</span><br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>)</span>;<br><br>        <span class="hljs-comment">//处理本次遍历内部逻辑</span><br>        <span class="hljs-keyword">if</span>(pre<span class="hljs-operator"> == </span>NULL)&#123;<span class="hljs-comment">//第一个结点，因为之前的结点都是1</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre != NULL<span class="hljs-operator"> &amp;&amp; </span>pre-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span>root-&gt;<span class="hljs-keyword">val</span>)&#123;<span class="hljs-comment">//判断pre和curr的值是否相等</span><br>            count++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//与前一个结点数值不相同</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//更新pre</span><br>        pre = root;<br><br>        <span class="hljs-comment">//判断count和max_count的大小，相等，直接将root-&gt;val放入到返回的结果数组中</span><br>        <span class="hljs-keyword">if</span>(count<span class="hljs-operator"> == </span>max_count)&#123;<br>            result.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断是否为最大值</span><br>        <span class="hljs-keyword">if</span>(count &gt; max_count)&#123;<br>            max_count = count;<br>            <span class="hljs-comment">//result中结果都失效了</span><br>            result.clear<span class="hljs-literal">()</span>;<br>            result.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">val</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遍历右子树</span><br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>)</span>;<br>        return ;<br>    &#125;<br><br>    vector&lt;<span class="hljs-built_in">int</span>&gt; find<span class="hljs-constructor">Mode(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="501-二叉搜索树中的众数（迭代法，C-实现）"><a href="#501-二叉搜索树中的众数（迭代法，C-实现）" class="headerlink" title="501.二叉搜索树中的众数（迭代法，C++实现）"></a>501.二叉搜索树中的众数（迭代法，C++实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; findMode(TreeNode* root) &#123;<br>        <span class="hljs-comment">//使用迭代遍历法实现</span><br>        TreeNode* pre = <span class="hljs-keyword">NULL</span>;<br>        TreeNode* curr = root;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">int</span> max_count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br><br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-keyword">NULL</span> || !st.empty())&#123;<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">NULL</span>)&#123;<br>                st.<span class="hljs-keyword">push</span>(curr);<br>                curr = curr -&gt; left;<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                curr = st.top();<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//开始和递归法一样</span><br>                <span class="hljs-keyword">if</span>(pre == <span class="hljs-keyword">NULL</span>)&#123;<span class="hljs-comment">//首个结点</span><br>                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre-&gt;val == curr-&gt;val)&#123;<br>                    <span class="hljs-keyword">count</span>++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//和前一个结点不一样</span><br>                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//更新前一个结点</span><br>                pre = curr;<br><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> == max_count)&#123;<br>                    result.push_back(curr-&gt;val);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> &gt; max_count)&#123;<br>                    max_count = <span class="hljs-keyword">count</span>;<br>                    result.clear();<br>                    result.push_back(curr-&gt;val);<br>                &#125;<br><br>                curr = curr -&gt; right;<span class="hljs-comment">//右结点</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先（递归调用，C-实现）"><a href="#236-二叉树的最近公共祖先（递归调用，C-实现）" class="headerlink" title="236.二叉树的最近公共祖先（递归调用，C++实现）"></a>236.二叉树的最近公共祖先（递归调用，C++实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(NULL), <span class="hljs-built_in">right</span>(NULL) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-keyword">if</span>(root == p |<span class="hljs-type">| root</span> == q |<span class="hljs-type">| root</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        TreeNode* <span class="hljs-built_in">left</span> = lowestCommonAncestor(root-&gt;<span class="hljs-built_in">left</span>, p, q);<br>        TreeNode* <span class="hljs-built_in">right</span> = lowestCommonAncestor(root-&gt;<span class="hljs-built_in">right</span>, p, q);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> != NULL &amp;&amp; <span class="hljs-built_in">right</span> != NULL)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> != NULL &amp;&amp; <span class="hljs-built_in">right</span> == NULL)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span> == NULL &amp;&amp; <span class="hljs-built_in">right</span> != NULL)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">right</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> NULL;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先（递归法，C-实现，充分利用二叉搜索树的特征）"><a href="#235-二叉搜索树的最近公共祖先（递归法，C-实现，充分利用二叉搜索树的特征）" class="headerlink" title="235. 二叉搜索树的最近公共祖先（递归法，C++实现，充分利用二叉搜索树的特征）"></a>235. 二叉搜索树的最近公共祖先（递归法，C++实现，充分利用二叉搜索树的特征）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br><br>    TreeNode* <span class="hljs-constructor">BSTdigui(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>NULL)&#123;<br>            return root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &gt; p-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &gt; q-&gt;<span class="hljs-keyword">val</span>)&#123;<br>            TreeNode* left = <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>            <span class="hljs-keyword">if</span>(left != NULL)&#123;<br>                return left;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span> &lt; p-&gt;<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root-&gt;<span class="hljs-keyword">val</span> &lt; q-&gt;<span class="hljs-keyword">val</span>)&#123;<br>            TreeNode* right = <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>            <span class="hljs-keyword">if</span>(right != NULL)&#123;<br>                return right;<br>            &#125;<br>        &#125;<br>        return root;<br>    &#125; <br><br><br>    TreeNode* lowest<span class="hljs-constructor">CommonAncestor(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">p</span>, TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">q</span>)</span> &#123;<br>        return <span class="hljs-constructor">BSTdigui(<span class="hljs-params">root</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先（迭代法，C-实现，充分利用二叉搜索树的特征）"><a href="#235-二叉搜索树的最近公共祖先（迭代法，C-实现，充分利用二叉搜索树的特征）" class="headerlink" title="235. 二叉搜索树的最近公共祖先（迭代法，C++实现，充分利用二叉搜索树的特征）"></a>235. 二叉搜索树的最近公共祖先（迭代法，C++实现，充分利用二叉搜索树的特征）</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br>class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &gt; p-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>left;<br>            &#125;<span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span>(root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; q-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &amp;&amp; root-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span> &lt; p-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">root</span> = root-&gt;</span>right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                return root;<br>            &#125;<br>        &#125;<br>        return NULL;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alibaba</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230711</title>
    <link href="/2023/07/11/leetcode-notes-20230711/"/>
    <url>/2023/07/11/leetcode-notes-20230711/</url>
    
    <content type="html"><![CDATA[<h2 id="700-二叉搜索树中的搜索（层序遍历法）"><a href="#700-二叉搜索树中的搜索（层序遍历法）" class="headerlink" title="700.二叉搜索树中的搜索（层序遍历法）"></a>700.二叉搜索树中的搜索（层序遍历法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-keyword">val</span> <span class="hljs-operator">==</span> <span class="hljs-keyword">val</span>)&#123;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="700-二叉搜索树中的搜索（递归法）"><a href="#700-二叉搜索树中的搜索（递归法）" class="headerlink" title="700.二叉搜索树中的搜索（递归法）"></a>700.二叉搜索树中的搜索（递归法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode huisu(TreeNode root, int <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.<span class="hljs-keyword">val</span> == <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">//表示在root的左子树中</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> &lt; root.<span class="hljs-keyword">val</span>)&#123;<br>            <span class="hljs-keyword">return</span> huisu(root.left, <span class="hljs-keyword">val</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> huisu(root.right, <span class="hljs-keyword">val</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">return</span> huisu(root, <span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（递归法实现）"><a href="#98-验证二叉搜索树（递归法实现）" class="headerlink" title="98.验证二叉搜索树（递归法实现）"></a>98.验证二叉搜索树（递归法实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>    <span class="hljs-comment">//递归实现中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> digui(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//中序遍历：右中左</span><br>        digui(root.left);<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        digui(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> boolean isValidBST(TreeNode root) &#123;<br>        digui(root);<br>        <span class="hljs-comment">//使用中序遍历，同时保存树的结点的值，判断是否为升序即可</span><br>        <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i <span class="hljs-operator">&lt;</span> result.size(); i <span class="hljs-operator">++</span>)&#123;<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">get</span>(i) <span class="hljs-operator">&lt;=</span> result.<span class="hljs-built_in">get</span>(i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（迭代法实现）"><a href="#98-验证二叉搜索树（迭代法实现）" class="headerlink" title="98.验证二叉搜索树（迭代法实现）"></a>98.验证二叉搜索树（迭代法实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isValidBST(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>)&#123;<br>            stack.<span class="hljs-keyword">push</span>(root);<br>        &#125;<br>        TreeNode pre = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">//循环迭代</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-comment">//得到栈顶结点</span><br>            TreeNode curr = stack.peek();<br>            <span class="hljs-comment">//判断curr是否为null</span><br>            <span class="hljs-comment">//按照右中左的顺序加入到栈中</span><br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>                stack.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出栈顶结点</span><br>                <span class="hljs-keyword">if</span>(curr.right != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//判断当前结点的右结点是否为null，不为null</span><br>                    stack.<span class="hljs-keyword">push</span>(curr.right);<br>                &#125;<br>                stack.<span class="hljs-keyword">push</span>(curr);<br>                stack.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(curr.left != <span class="hljs-keyword">null</span>)&#123;<br>                    stack.<span class="hljs-keyword">push</span>(curr.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//弹出栈顶null（占位）结点</span><br>                stack.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//对结点进行操作</span><br>                TreeNode tmp = stack.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span> &amp;&amp; pre.val &gt;= tmp.val)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树（递归，C-）"><a href="#98-验证二叉搜索树（递归，C-）" class="headerlink" title="98.验证二叉搜索树（递归，C++）"></a>98.验证二叉搜索树（递归，C++）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    long long max_value = LONG_MIN;<br>    bool isValidBST(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root == NULL)&#123;<br>            <span class="hljs-keyword">return</span> true;<br>        &#125;<br><br>        bool <span class="hljs-built_in">left</span> = isValidBST(root-&gt;<span class="hljs-built_in">left</span>);<br>        <span class="hljs-keyword">if</span>(max_value &lt; root-&gt;val)&#123;<br>            max_value = root-&gt;val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> false;<br>        &#125;<br>        bool <span class="hljs-built_in">right</span> = isValidBST(root-&gt;<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span> &amp;&amp; <span class="hljs-built_in">right</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>C++</tag>
      
      <tag>二叉树（从700. 二叉搜索树中的搜索开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230710.md</title>
    <link href="/2023/07/10/leetcode-notes-20230710/"/>
    <url>/2023/07/10/leetcode-notes-20230710/</url>
    
    <content type="html"><![CDATA[<h2 id="513-找树左下角的值（递归写法）"><a href="#513-找树左下角的值（递归写法）" class="headerlink" title="513.找树左下角的值（递归写法）"></a>513.找树左下角的值（递归写法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    int max_depth <span class="hljs-operator">=</span> <span class="hljs-number">-1</span>;<br>    int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> huisu(TreeNode root, int depth)&#123;<br>        <span class="hljs-comment">//设置递归终止条件</span><br>        <span class="hljs-keyword">if</span>(root.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> root.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(max_depth <span class="hljs-operator">&lt;</span> depth)&#123;<br>                max_depth <span class="hljs-operator">=</span> depth;<br>                result <span class="hljs-operator">=</span> root.<span class="hljs-keyword">val</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归左子树条件</span><br>        <span class="hljs-keyword">if</span>(root.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            depth<span class="hljs-operator">++</span>;<br>            huisu(root.left, depth);<br>            depth<span class="hljs-operator">--</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//递归右子树</span><br>        <span class="hljs-keyword">if</span>(root.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            depth<span class="hljs-operator">++</span>;<br>            huisu(root.right, depth);<br>            depth<span class="hljs-operator">--</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int findBottomLeftValue(TreeNode root) &#123;<br>        huisu(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="513-找树左下角的值（迭代法）"><a href="#513-找树左下角的值（迭代法）" class="headerlink" title="513.找树左下角的值（迭代法）"></a>513.找树左下角的值（迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> findBottomLeftValue(TreeNode root) &#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//使用二叉树层序遍历</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-comment">///如果队列不是空的，那么进入循环</span><br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到当前队列的长度</span><br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">size</span>;i ++)&#123;<br>                <span class="hljs-comment">//得到每层的结点</span><br>                TreeNode node = que.poll();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                    result = node.val;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路经总和（递归法）"><a href="#112-路经总和（递归法）" class="headerlink" title="112.路经总和（递归法）"></a>112.路经总和（递归法）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//设置的回溯算法</span><br>    <span class="hljs-keyword">public</span> boolean huisu(TreeNode root, int currSum)&#123;<br>        <span class="hljs-comment">//判断是否为targetSum</span><br>        <span class="hljs-comment">//遇到叶子结点且currSum==0，这表示找到了满足题意的结果</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; currSum == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//遇到叶子节点直接返回false</span><br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            currSum -= root.left.<span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">if</span>(huisu(root.left, currSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            currSum += root.left.<span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            currSum -= root.right.<span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">if</span>(huisu(root.right, currSum)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            currSum += root.right.<span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> boolean hasPathSum(TreeNode root, int targetSum) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> huisu(root, targetSum - root.<span class="hljs-keyword">val</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路径总和（迭代法）"><a href="#112-路径总和（迭代法）" class="headerlink" title="112.路径总和（迭代法）"></a>112.路径总和（迭代法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-comment">//自定义类</span><br>public <span class="hljs-keyword">class</span> MyNode&#123;<br>     TreeNode treeNode;<br>     <span class="hljs-built_in">int</span> currSum = <span class="hljs-number">0</span>;<br>     <span class="hljs-constructor">MyNode(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">currSum</span>)</span>&#123;<br>         this.treeNode = root;<br>         this.currSum = currSum;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean has<span class="hljs-constructor">PathSum(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">targetSum</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用非递归方法做</span><br>        Stack&lt;MyNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        MyNode rootNode = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">root</span>, <span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span>;<br>        st.push(rootNode);<br><br>        <span class="hljs-keyword">while</span>(!st.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            MyNode node = st.peek<span class="hljs-literal">()</span>;<br>            st.pop<span class="hljs-literal">()</span>;<br><br>            <span class="hljs-keyword">if</span>(targetSum<span class="hljs-operator"> == </span>node.currSum<span class="hljs-operator"> &amp;&amp; </span>node.treeNode.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>node.treeNode.right<span class="hljs-operator"> == </span>null)&#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//压入右结点栈中</span><br>            <span class="hljs-keyword">if</span>(node.treeNode.right != null)&#123;<br>                st.push(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">right</span>, <span class="hljs-params">node</span>.<span class="hljs-params">currSum</span> + <span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">right</span>.<span class="hljs-params">val</span>)</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//将左结点压入栈中</span><br>            <span class="hljs-keyword">if</span>(node.treeNode.left != null)&#123;<br>                st.push(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyNode(<span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">left</span>, <span class="hljs-params">node</span>.<span class="hljs-params">currSum</span> + <span class="hljs-params">node</span>.<span class="hljs-params">treeNode</span>.<span class="hljs-params">left</span>.<span class="hljs-params">val</span>)</span>);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路经总和2（回溯法）"><a href="#113-路经总和2（回溯法）" class="headerlink" title="113.路经总和2（回溯法）"></a>113.路经总和2（回溯法）</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用回溯方法做<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> huisu(TreeNode root, <span class="hljs-type">int</span> targetSum, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; targetSum == root.val)&#123;<br>            result.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(<span class="hljs-type">path</span>));<br>        &#125;<br><br>        huisu(root.left, targetSum - root.val, result, <span class="hljs-type">path</span>);<br>        huisu(root.right, targetSum - root.val, result, <span class="hljs-type">path</span>);<br><br>        <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; pathSum(TreeNode root, <span class="hljs-type">int</span> targetSum) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        huisu(root, targetSum, result, <span class="hljs-type">path</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路经总和2（DFS法）"><a href="#113-路经总和2（DFS法）" class="headerlink" title="113.路经总和2（DFS法）"></a>113.路经总和2（DFS法）</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; res = new ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; pathSum(TreeNode root, <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>) &#123;<br>        List&lt;<span class="hljs-keyword">Integer</span>&gt; cur = new ArrayList&lt;&gt;();<br>        dfs(root, cur, <span class="hljs-number">0</span>, <span class="hljs-built_in">sum</span>);            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br><br>    <span class="hljs-keyword">public</span> void dfs(TreeNode node, List&lt;<span class="hljs-keyword">Integer</span>&gt; cur, <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>)&#123;<br>        <span class="hljs-keyword">if</span>(node == null)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.left == null &amp;&amp; node.right == null &amp;&amp; node.val + <span class="hljs-built_in">sum</span> == <span class="hljs-keyword">target</span>)&#123;<br>            cur.add(node.val);<br>            res.add(new ArrayList&lt;&gt;(cur));<br>            cur.remove(cur.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;            <br>        cur.add(node.val);<br>        dfs(node.left, cur, <span class="hljs-built_in">sum</span> + node.val, <span class="hljs-keyword">target</span>);<br>        dfs(node.right, cur, <span class="hljs-built_in">sum</span> + node.val, <span class="hljs-keyword">target</span>);<br>        cur.remove(cur.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//参数：中序遍历数组和后续遍历数组</span><br>    public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">postorder</span>)</span> &#123;<br>        <span class="hljs-comment">//获得分割结点</span><br>        <span class="hljs-built_in">int</span> in_length = inorder.length;<br>        <span class="hljs-built_in">int</span> post_length = postorder.length;<br><br>        <span class="hljs-comment">//判断是否为空结点</span><br>        <span class="hljs-keyword">if</span>(in_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>post_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-comment">//通过后续序列找到切割结点</span><br>        <span class="hljs-built_in">int</span> root_val = postorder<span class="hljs-literal">[<span class="hljs-identifier">post_length</span> - <span class="hljs-number">1</span>]</span>;<br>        <span class="hljs-comment">//构造根结点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历中序序列，找到切割结点在其中的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; in_length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root_val<span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                k = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//按照分割结点将中序序列和后续序列进行分割</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_post = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-comment">//递归调用函数</span><br>        root.left = build<span class="hljs-constructor">Tree(<span class="hljs-params">left_in</span>, <span class="hljs-params">left_post</span>)</span>;<br><br>        <span class="hljs-comment">//按照分割结点构造右子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">in_length</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_post = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>, <span class="hljs-params">k</span>, <span class="hljs-params">post_length</span> - 1)</span>;<br>        root.right = build<span class="hljs-constructor">Tree(<span class="hljs-params">right_in</span>, <span class="hljs-params">right_post</span>)</span>;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">preorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> pre_length = preorder.length;<br>        <span class="hljs-built_in">int</span> in_length = inorder.length;<br>        <span class="hljs-keyword">if</span>(pre_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>in_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> root_val = preorder<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">root_val</span>)</span>;<br>        <br>        <span class="hljs-comment">//得到左子树对应的前序和中序序列</span><br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; in_length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root_val<span class="hljs-operator"> == </span>inorder<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                k = i;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_pre = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>, 1, <span class="hljs-params">k</span> + 1)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        root.left = build<span class="hljs-constructor">Tree(<span class="hljs-params">left_pre</span>, <span class="hljs-params">left_in</span>)</span>;<br><br>        <span class="hljs-comment">//构造右子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_pre = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">pre_length</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_in = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">in_length</span>)</span>;<br>        root.right = build<span class="hljs-constructor">Tree(<span class="hljs-params">right_pre</span>, <span class="hljs-params">right_in</span>)</span>;<br><br>        return root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public TreeNode construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n_length = nums.length;<br>        <span class="hljs-keyword">if</span>(n_length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> max_value = -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//首先找到最大值和最大值对应的index</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max_value &lt; nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)&#123;<br>                max_value = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>                k = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建根结点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">max_value</span>)</span>;<br>        <br>        <span class="hljs-comment">//从根结点左边构造左子树</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> left_nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">k</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> right_nums = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>, <span class="hljs-params">k</span> + 1, <span class="hljs-params">n_length</span>)</span>;<br>        root.left = construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">left_nums</span>)</span>;<br>        root.right = construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">right_nums</span>)</span>;<br><br>        return root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树（递归实现）"><a href="#617-合并二叉树（递归实现）" class="headerlink" title="617. 合并二叉树（递归实现）"></a>617. 合并二叉树（递归实现）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode <span class="hljs-built_in">left</span>;<br> *     TreeNode <span class="hljs-built_in">right</span>;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123;<br> *         this.val = val;<br> *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;<br> *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode huisu(TreeNode root1, TreeNode root2)&#123;<br>        <span class="hljs-keyword">if</span>(root1 == null)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root2 == null)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        root1.val += root2.val;<br>        root1.<span class="hljs-built_in">left</span> = huisu(root1.<span class="hljs-built_in">left</span>, root2.<span class="hljs-built_in">left</span>);<br>        root1.<span class="hljs-built_in">right</span> = huisu(root1.<span class="hljs-built_in">right</span>, root2.<span class="hljs-built_in">right</span>);<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;    <br>    <br>    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>        <span class="hljs-keyword">return</span> huisu(root1, root2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="617-合并二叉树（迭代实现）"><a href="#617-合并二叉树（迭代实现）" class="headerlink" title="617. 合并二叉树（迭代实现）"></a>617. 合并二叉树（迭代实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>        <span class="hljs-comment">//使用层序遍历迭代法</span><br>        <span class="hljs-keyword">if</span>(root1 <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root2 <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        <span class="hljs-comment">//使用层序遍历</span><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-comment">//加入root1</span><br>        que.offer(root1);<br>        <span class="hljs-comment">//加入root2</span><br>        que.offer(root2);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到两个队列中的结点</span><br>            TreeNode node1 <span class="hljs-operator">=</span> que.poll();<br>            TreeNode node2 <span class="hljs-operator">=</span> que.poll();<br><br>            <span class="hljs-comment">//将两个结点的val相加</span><br>            node1.<span class="hljs-keyword">val</span> <span class="hljs-operator">+=</span> node2.<span class="hljs-keyword">val</span>;<br><br>            <span class="hljs-comment">//将树的左结点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(node1.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node1.left);<br>                que.offer(node2.left);<br>            &#125;<br><br>            <span class="hljs-comment">//将树的右结点加入到队列中</span><br>            <span class="hljs-keyword">if</span>(node1.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                que.offer(node1.right);<br>                que.offer(node2.right);<br>            &#125;<br><br>            <span class="hljs-comment">//如果node1的左节点为空直接将node2的左结点赋值给node1</span><br>            <span class="hljs-keyword">if</span>(node1.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                node1.left <span class="hljs-operator">=</span> node2.left;<br>            &#125;<br><br>            <span class="hljs-comment">//如果node1的右节点为空，将node2的有结点赋值给node1</span><br>            <span class="hljs-keyword">if</span>(node1.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node2.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                node1.right <span class="hljs-operator">=</span> node2.right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230610</title>
    <link href="/2023/06/17/leetcode-notes-20230617/"/>
    <url>/2023/06/17/leetcode-notes-20230617/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和（迭代法）"><a href="#404-左叶子之和（迭代法）" class="headerlink" title="404.左叶子之和（迭代法）"></a>404.左叶子之和（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//判断下一个结点是不是左叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                result <span class="hljs-operator">+=</span> node.left.<span class="hljs-keyword">val</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//按照右左中的顺序加入到stack中</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230610</title>
    <link href="/2023/06/10/leetcode-notes-20230610/"/>
    <url>/2023/06/10/leetcode-notes-20230610/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和（迭代法）"><a href="#404-左叶子之和（迭代法）" class="headerlink" title="404.左叶子之和（迭代法）"></a>404.左叶子之和（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法实现</span><br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//判断下一个结点是不是左叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.left.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                result <span class="hljs-operator">+=</span> node.left.<span class="hljs-keyword">val</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//按照右左中的顺序加入到stack中</span><br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树（从左子叶之和开始）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230607</title>
    <link href="/2023/06/07/leetcode-notes-20230607/"/>
    <url>/2023/06/07/leetcode-notes-20230607/</url>
    
    <content type="html"><![CDATA[<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br>class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">//二叉树层序遍历</span><br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt;&gt; result = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">//BFS搜索</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-built_in">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-comment">//借助队列实现</span><br>        <span class="hljs-built_in">Queue</span>&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">//将第一个节点加入队列中</span><br>        <span class="hljs-built_in">queue</span>.offer(root);<br><br>        <span class="hljs-comment">//循环进行遍历</span><br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">queue</span>.isEmpty())&#123;<br>            <span class="hljs-comment">//设置内部的保存结点的list数组</span><br>            <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; tmp = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>            int size = <span class="hljs-built_in">queue</span>.size();<span class="hljs-comment">//获得tmp list的长度</span><br><br>            <span class="hljs-comment">//遍历当前所有的节点</span><br>            for(int i = <span class="hljs-number">0</span>;i &lt; size;i++)&#123;<br>                <span class="hljs-comment">//弹出队列首结点</span><br>                TreeNode node = <span class="hljs-built_in">queue</span>.poll();<br>                <span class="hljs-comment">//向tmp list中添加弹出结点的val</span><br>                tmp.add(node.val);<br>                <span class="hljs-comment">//将左右结点加入到queue中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-built_in">null</span>)&#123;<br>                    <span class="hljs-built_in">queue</span>.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-built_in">null</span>)&#123;<br>                    <span class="hljs-built_in">queue</span>.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//将本次得到的结点list加入到最后的结果list中</span><br>            result.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（递归法）"><a href="#226-翻转二叉树（递归法）" class="headerlink" title="226.翻转二叉树（递归法）"></a>226.翻转二叉树（递归法）</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public class TreeNode &#123;<br> *     int val;<br> *     TreeNode <span class="hljs-built_in">left</span>;<br> *     TreeNode <span class="hljs-built_in">right</span>;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int val) &#123; this.val = val; &#125;<br> *     TreeNode(int val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123;<br> *         this.val = val;<br> *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;<br> *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;<br> *     &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public TreeNode invertTree(TreeNode root) &#123;<br>        //使用递归<br>        <span class="hljs-keyword">if</span>(root == null)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        //交换root的左右结点<br>        TreeNode tmpNode = root.<span class="hljs-built_in">left</span>;<br>        root.<span class="hljs-built_in">left</span> = root.<span class="hljs-built_in">right</span>;<br>        root.<span class="hljs-built_in">right</span> = tmpNode;<br>        invertTree(root.<span class="hljs-built_in">left</span>);<br>        invertTree(root.<span class="hljs-built_in">right</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（前序遍历迭代法）"><a href="#226-翻转二叉树（前序遍历迭代法）" class="headerlink" title="226.翻转二叉树（前序遍历迭代法）"></a>226.翻转二叉树（前序遍历迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode invertTree(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            <span class="hljs-comment">//弹出栈顶结点</span><br>            TreeNode node <span class="hljs-operator">=</span> st.peek();<br>            st.pop();<br>            <span class="hljs-comment">//交换左右结点</span><br>            TreeNode tmp <span class="hljs-operator">=</span> node.left;<br>            node.left <span class="hljs-operator">=</span> node.right;<br>            node.right <span class="hljs-operator">=</span> tmp;<br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="226-翻转二叉树（统一迭代法，前序遍历实现）"><a href="#226-翻转二叉树（统一迭代法，前序遍历实现）" class="headerlink" title="226.翻转二叉树（统一迭代法，前序遍历实现）"></a>226.翻转二叉树（统一迭代法，前序遍历实现）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> TreeNode invertTree(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用统一迭代法</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode curr = st.peek();<br>            <span class="hljs-keyword">if</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出结点</span><br>                <span class="hljs-comment">//按照右中左进栈（前序遍历）</span><br>                <span class="hljs-keyword">if</span>(curr.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(curr.right);<br>                &#125;<br>                <span class="hljs-comment">//中结点入栈</span><br>                st.<span class="hljs-keyword">push</span>(curr);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(curr.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(curr.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//先弹出null结点</span><br>                curr = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//交换结点</span><br>                TreeNode tmp = curr.left;<br>                curr.left = curr.right;<br>                curr.right = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树（递归写法）"><a href="#101-对称二叉树（递归写法）" class="headerlink" title="101.对称二叉树（递归写法）"></a>101.对称二叉树（递归写法）</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//设置递归函数，传入参数分别为root的左右结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>        <span class="hljs-comment">//确定终止条件</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left == <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left.val != right.val)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//确定递归的内容</span><br>        <span class="hljs-comment">//传入为左节点的左子树和右节点的右子树</span><br>        <span class="hljs-keyword">boolean</span> outside = compare(left.left, right.right);<br>        <span class="hljs-comment">//传入为左节点的右子树和右节点的左子树</span><br>        <span class="hljs-keyword">boolean</span> inside = compare(left.right, right.left);<br>        <span class="hljs-keyword">boolean</span> eq = outside &amp;&amp; inside;<br>        <span class="hljs-keyword">return</span> eq;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">//使用递归实现</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">compare</span><span class="hljs-params">(root.left, root.right)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树（迭代写法，使用队列实现）"><a href="#101-对称二叉树（迭代写法，使用队列实现）" class="headerlink" title="101.对称二叉树（迭代写法，使用队列实现）"></a>101.对称二叉树（迭代写法，使用队列实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> boolean isSymmetric(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//使用迭代法进行遍历</span><br>        <span class="hljs-comment">//使用队列每次保存左右子树的同外侧结点和同内侧结点</span><br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root.left);<br>        que.offer(root.right);<br><br>        <span class="hljs-comment">//while循环遍历que进行比较</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            <span class="hljs-comment">//得到que中的两个节点判断是否相同</span><br>            TreeNode leftNode <span class="hljs-operator">=</span> que.peek();<br>            que.poll();<br>            TreeNode rightNode <span class="hljs-operator">=</span> que.peek();<br>            que.poll();<br><br>            <span class="hljs-comment">//进行判断的逻辑</span><br>            <span class="hljs-keyword">if</span>(leftNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> rightNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                continue;<span class="hljs-comment">//表示两个结点都是空的，那么continue</span><br>            &#125;<br><br>            <span class="hljs-comment">//判断两个结点是否相同</span><br>            <span class="hljs-comment">// if(leftNode != null &amp;&amp; rightNode == null)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;else if(leftNode == null &amp;&amp; rightNode != null)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;else if(leftNode.val != rightNode.val)&#123;</span><br>            <span class="hljs-comment">//     return false;</span><br>            <span class="hljs-comment">// &#125;</span><br><br>            <span class="hljs-keyword">if</span>((leftNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> rightNode <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> (leftNode.<span class="hljs-keyword">val</span> <span class="hljs-operator">!=</span> rightNode.<span class="hljs-keyword">val</span>)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//然后将leftNode的左子树和rightNode的右子树加入到que中</span><br>            que.offer(leftNode.left);<br>            que.offer(rightNode.right);<br><br>            <span class="hljs-comment">//将leftNode的右子树和rightNode的左子树加入到que中</span><br>            que.offer(leftNode.right);<br>            que.offer(rightNode.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度（递归方法）"><a href="#104-二叉树的最大深度（递归方法）" class="headerlink" title="104.二叉树的最大深度（递归方法）"></a>104.二叉树的最大深度（递归方法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//递归方法</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> leftDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-built_in">int</span> rightDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>        <span class="hljs-built_in">int</span> maxDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftDepth, rightDepth);<br>        return maxDepth;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度（使用迭代法，队列实现层次遍历）"><a href="#104-二叉树的最大深度（使用迭代法，队列实现层次遍历）" class="headerlink" title="104.二叉树的最大深度（使用迭代法，队列实现层次遍历）"></a>104.二叉树的最大深度（使用迭代法，队列实现层次遍历）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxDepth(TreeNode root) &#123;<br>        <span class="hljs-comment">//迭代法求二叉树深度</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxResult = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//设置队列存储结点</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-comment">//深度加1</span><br>            maxResult++;<br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = que.<span class="hljs-keyword">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">size</span>;i++)&#123;<br>                TreeNode node = que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559.N 叉树的最大深度"></a>559.N 叉树的最大深度</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-keyword">class</span> Node &#123;<br>    <span class="hljs-keyword">public</span> int <span class="hljs-keyword">val</span>;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> children;<br><br>    <span class="hljs-keyword">public</span> Node() &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> Node(int _val) &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> _val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node(int _val, List<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> _children) &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> _val;<br>        children <span class="hljs-operator">=</span> _children;<br>    &#125;<br>&#125;;<br><span class="hljs-operator">*/</span><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int maxDepth(Node root) &#123;<br>        <span class="hljs-comment">//使用迭代法+队列实现层次遍历</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义队列</span><br>        Queue<span class="hljs-operator">&lt;</span>Node<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            result<span class="hljs-operator">++</span>;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                Node node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br><br>                <span class="hljs-keyword">for</span>(int j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j <span class="hljs-operator">&lt;</span> node.children.size();j<span class="hljs-operator">++</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(node.children.<span class="hljs-built_in">get</span>(j) <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                        que.offer(node.children.<span class="hljs-built_in">get</span>(j));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度（使用递归法）"><a href="#111-二叉树的最小深度（使用递归法）" class="headerlink" title="111.二叉树的最小深度（使用递归法）"></a>111.二叉树的最小深度（使用递归法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">minDepth</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> leftDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">minDepth</span>)</span>;<br>        <span class="hljs-built_in">int</span> rightDepth = get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">minDepth</span>)</span>;<br><br>        <span class="hljs-keyword">if</span>(root.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>root.right<span class="hljs-operator"> == </span>null)&#123;<br>            minDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftDepth, rightDepth);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minDepth = <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(leftDepth, rightDepth);<br>        &#125;<br>        return minDepth;<br>    &#125;<br><br>    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        return get<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度（使用迭代法-队列实现层次遍历）"><a href="#111-二叉树的最小深度（使用迭代法-队列实现层次遍历）" class="headerlink" title="111.二叉树的最小深度（使用迭代法+队列实现层次遍历）"></a>111.二叉树的最小深度（使用迭代法+队列实现层次遍历）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int minDepth(TreeNode root) &#123;<br>        <span class="hljs-comment">//迭代法得到最小深度，使用队列实现</span><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            result<span class="hljs-operator">++</span>;<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">==</span> <span class="hljs-literal">null</span> <span class="hljs-operator">&amp;&amp;</span> node.right <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="222-完全二叉树的节点个数（使用层次遍历实现）"><a href="#222-完全二叉树的节点个数（使用层次遍历实现）" class="headerlink" title="222.完全二叉树的节点个数（使用层次遍历实现）"></a>222.完全二叉树的节点个数（使用层次遍历实现）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> int countNodes(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int result <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> que <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> LinkedList<span class="hljs-operator">&lt;&gt;</span>();<br>        que.offer(root);<br>        result<span class="hljs-operator">++</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>que.isEmpty())&#123;<br>            int len <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span>(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> len;i<span class="hljs-operator">++</span>)&#123;<br>                TreeNode node <span class="hljs-operator">=</span> que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    result<span class="hljs-operator">++</span>;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                    result<span class="hljs-operator">++</span>;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（递归方法）"><a href="#110-平衡二叉树（递归方法）" class="headerlink" title="110.平衡二叉树（递归方法）"></a>110.平衡二叉树（递归方法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//使用递归方法</span><br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Height(TreeNode <span class="hljs-params">root</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">int</span> leftHeight = get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>        <span class="hljs-keyword">if</span>(leftHeight<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//表示不满足平衡二叉树</span><br>        return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> rightHeight = get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>        <span class="hljs-keyword">if</span>(rightHeight<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)&#123;<br>            return -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(leftHeight, rightHeight);<br>        return result;<br>    &#125;<br>    public boolean is<span class="hljs-constructor">Balanced(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        return get<span class="hljs-constructor">Height(<span class="hljs-params">root</span>)</span><span class="hljs-operator"> == </span>-<span class="hljs-number">1</span> ? <span class="hljs-literal">false</span>: <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）"><a href="#110-平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）" class="headerlink" title="110.平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）"></a>110.平衡二叉树（迭代法遍历得到以当前结点为根结点的最大高度，然后求每个结点的左右子树的高度差）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义求以root结点作为根节点的最大高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getHeight(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> len = que.<span class="hljs-keyword">size</span>();<br>            result++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>                TreeNode node = que.peek();<br>                que.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalanced(TreeNode root) &#123;<br>        <span class="hljs-comment">//遍历的时候求当前左右节点的最大高度，然后求之间的差的绝对值，将该值和1比较</span><br>        <span class="hljs-comment">//外层使用二叉树的统一迭代遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//按照后序遍历方法</span><br>                st.<span class="hljs-keyword">push</span>(node);<span class="hljs-comment">//中</span><br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//添加进去之前需要判断是否为平衡树</span><br>                <span class="hljs-keyword">int</span> leftHeight = getHeight(node.left);<br>                <span class="hljs-keyword">int</span> rightHeight = getHeight(node.right);<br>                <span class="hljs-keyword">if</span>(Math.<span class="hljs-keyword">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//首先弹出标记用的空结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树（递归得到树的最大高度-遍历当前结点判断该结点的左右子树高度差是否大于1）"><a href="#110-平衡二叉树（递归得到树的最大高度-遍历当前结点判断该结点的左右子树高度差是否大于1）" class="headerlink" title="110.平衡二叉树（递归得到树的最大高度+遍历当前结点判断该结点的左右子树高度差是否大于1）"></a>110.平衡二叉树（递归得到树的最大高度+遍历当前结点判断该结点的左右子树高度差是否大于1）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getHeight(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> leftHeight = getHeight(root.left);<br>        <span class="hljs-keyword">int</span> rightHeight = getHeight(root.right);<br>        <span class="hljs-keyword">int</span> maxDepth = <span class="hljs-number">1</span> + Math.max(leftHeight, rightHeight);<br>        <span class="hljs-keyword">return</span> maxDepth;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isBalanced(TreeNode root) &#123;<br>        <span class="hljs-comment">//遍历的时候求当前左右节点的最大高度，然后求之间的差的绝对值，将该值和1比较</span><br>        <span class="hljs-comment">//外层使用二叉树的统一迭代遍历</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//按照后序遍历方法</span><br>                st.<span class="hljs-keyword">push</span>(node);<span class="hljs-comment">//中</span><br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//添加进去之前需要判断是否为平衡树</span><br>                <span class="hljs-keyword">int</span> leftHeight = getHeight(node.left);<br>                <span class="hljs-keyword">int</span> rightHeight = getHeight(node.right);<br>                <span class="hljs-keyword">if</span>(Math.<span class="hljs-keyword">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//首先弹出标记用的空结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用递归调用实现<br>    //参数分别为传入的结点，本次的单条路径，所有路径结果数组<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> travelTreeAllPath(TreeNode root, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;String&gt; result)&#123;<br>        //将中结点加入到<span class="hljs-type">path</span>中，这样才算遍历到了叶子结点<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        //递归条件，到叶子节点结束递归<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            //结束递归的时候将<span class="hljs-type">path</span>中对应的结果添加到result list中<br>            String path_str = &quot;&quot;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>;i++)&#123;<br>                path_str += String.valueOf(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i));<br>                path_str += &quot;-&gt;&quot;;<br>            &#125;<br>            path_str += <span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);<br>            //将当前结果加入到result list中<br>            result.<span class="hljs-keyword">add</span>(path_str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        //每次递归需要执行的代码<br>        //不是空结点才进行递归<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.left, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.right, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        travelTreeAllPath(root, <span class="hljs-type">path</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><br>//使用StringBuilder进行字符串的构造，效率提升很大<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    //使用递归调用实现<br>    //参数分别为传入的结点，本次的单条路径，所有路径结果数组<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> travelTreeAllPath(TreeNode root, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;String&gt; result)&#123;<br>        //将中结点加入到<span class="hljs-type">path</span>中，这样才算遍历到了叶子结点<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(root.val);<br>        //递归条件，到叶子节点结束递归<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            //结束递归的时候将<span class="hljs-type">path</span>中对应的结果添加到result list中<br>            StringBuilder sb = <span class="hljs-built_in">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>;i++)&#123;<br>                sb.append(String.valueOf(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i)));<br>                sb.append(&quot;-&gt;&quot;);<br>            &#125;<br>            sb.append(<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>));<br>            //将当前结果加入到result list中<br>            result.<span class="hljs-keyword">add</span>(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        //每次递归需要执行的代码<br>        //不是空结点才进行递归<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.left, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>            travelTreeAllPath(root.right, <span class="hljs-type">path</span>, result);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);//回溯<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        travelTreeAllPath(root, <span class="hljs-type">path</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径（使用迭代方法实现）"><a href="#257-二叉树的所有路径（使用迭代方法实现）" class="headerlink" title="257.二叉树的所有路径（使用迭代方法实现）"></a>257.二叉树的所有路径（使用迭代方法实现）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public List&lt;String&gt; binary<span class="hljs-constructor">TreePaths(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        <span class="hljs-comment">//使用前序迭代法</span><br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return result;<br>        &#125;<br>        <span class="hljs-comment">//保存当前对应的tmp path</span><br>        Stack&lt;String&gt; path = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//保存前序遍历时的树结点</span><br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        st.push(root);<br>        path.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span>);<br>        <span class="hljs-keyword">while</span>(!st.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            TreeNode node = st.peek<span class="hljs-literal">()</span>;<br>            st.pop<span class="hljs-literal">()</span>;<span class="hljs-comment">//弹出栈顶结点</span><br><br>            <span class="hljs-comment">//去除该节点对应的path</span><br>            String str = path.peek<span class="hljs-literal">()</span>;<br>            path.pop<span class="hljs-literal">()</span>;<br><br>            <span class="hljs-comment">//入栈之前先判断当前是否为叶子结点</span><br>            <span class="hljs-keyword">if</span>(node.left<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>node.right<span class="hljs-operator"> == </span>null)&#123;<br>                <span class="hljs-comment">//将path放入到result数组中</span><br>                result.add(str);<br>            &#125;<br><br>            <span class="hljs-comment">//右左中顺序入栈</span><br>            <span class="hljs-keyword">if</span>(node.right != null)&#123;<br>                st.push(node.right);<br>                StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">str</span>)</span>;<br>                sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.append(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">node</span>.<span class="hljs-params">right</span>.<span class="hljs-params">val</span>)</span>);<br>                path.push(sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(node.left != null)&#123;<br>                st.push(node.left);<br>                StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">str</span>)</span>;<br>                sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>                sb.append(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">node</span>.<span class="hljs-params">left</span>.<span class="hljs-params">val</span>)</span>);<br>                path.push(sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="404-左叶子之和（使用迭代法）"><a href="#404-左叶子之和（使用迭代法）" class="headerlink" title="404.左叶子之和（使用迭代法）"></a>404.左叶子之和（使用迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sumOfLeftLeaves(TreeNode root) &#123;<br>        <span class="hljs-comment">//二叉树迭代遍历得到左右左叶子之和</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//判断条件需要重新理解</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span> &amp;&amp; node.left.left == <span class="hljs-keyword">null</span> &amp;&amp; node.left.right == <span class="hljs-keyword">null</span>)&#123;<br>                    result += node.left.val;<br>                &#125;<br>                <span class="hljs-comment">//按照右左中的顺序加入栈中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230605</title>
    <link href="/2023/06/05/leetcode-notes-20230605/"/>
    <url>/2023/06/05/leetcode-notes-20230605/</url>
    
    <content type="html"><![CDATA[<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义递归函数</span><br>    void preorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-comment">//将当前root节点的值存入到result中</span><br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br>    public List&lt;Integer&gt; preorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        preorder<span class="hljs-constructor">Traversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//定义后续遍历递归函数</span><br>    void tree<span class="hljs-constructor">PostOrderTraversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>    &#125;<br><br>    public List&lt;Integer&gt; postorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        tree<span class="hljs-constructor">PostOrderTraversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    void tree<span class="hljs-constructor">InorderTraversal(TreeNode <span class="hljs-params">root</span>, List&lt;Integer&gt; <span class="hljs-params">result</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null)&#123;<br>            return;<br>        &#125;<br><br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">result</span>)</span>;<br>        result.add(root.<span class="hljs-keyword">val</span>);<br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">result</span>)</span>;<br>    &#125;<br><br>    public List&lt;Integer&gt; inorder<span class="hljs-constructor">Traversal(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        tree<span class="hljs-constructor">InorderTraversal(<span class="hljs-params">root</span>, <span class="hljs-params">result</span>)</span>;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历（迭代方式）"><a href="#144-二叉树的前序遍历（迭代方式）" class="headerlink" title="144.二叉树的前序遍历（迭代方式）"></a>144.二叉树的前序遍历（迭代方式）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//非递归方式遍历二叉树</span><br>        <span class="hljs-comment">//定义一个保存节点值的栈</span><br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-comment">//定义返回的结果数组</span><br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br><br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <br>        st.add(root);<br>        <span class="hljs-comment">//while循环Stack栈，将其中的val添加到result数组中</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode tmpNode <span class="hljs-operator">=</span> st.pop();<br>            <span class="hljs-comment">//将当前节点加入到result中</span><br>            result.add(tmpNode.<span class="hljs-keyword">val</span>);<br>            <span class="hljs-comment">//然后将tmpNode节点的右节点现加入到st中</span><br>            <span class="hljs-keyword">if</span>(tmpNode.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(tmpNode.right);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(tmpNode.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(tmpNode.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历（迭代法）"><a href="#94-二叉树的中序遍历（迭代法）" class="headerlink" title="94.二叉树的中序遍历（迭代法）"></a>94.二叉树的中序遍历（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> inorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//使用迭代法得到二叉树的中序遍历节点值</span><br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        TreeNode curr <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-keyword">while</span>(curr <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span> <span class="hljs-operator">||</span> <span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            <span class="hljs-keyword">if</span>(curr <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(curr);<br>                curr <span class="hljs-operator">=</span> curr.left;<span class="hljs-comment">//得到左节点</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//表示左子树到底了，需要开始向result中添加节点值</span><br>                curr <span class="hljs-operator">=</span> st.pop();<span class="hljs-comment">//弹出节点</span><br>                result.add(curr.<span class="hljs-keyword">val</span>);<span class="hljs-comment">//将弹出的节点加入到result数组中</span><br>                curr <span class="hljs-operator">=</span> curr.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历（迭代法）"><a href="#145-二叉树的后序遍历（迭代法）" class="headerlink" title="145.二叉树的后序遍历（迭代法）"></a>145.二叉树的后序遍历（迭代法）</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> a binary tree node.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     TreeNode left;<br> <span class="hljs-operator">*</span>     TreeNode right;<br> <span class="hljs-operator">*</span>     TreeNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> <span class="hljs-operator">*</span>         this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>         this.left <span class="hljs-operator">=</span> left;<br> <span class="hljs-operator">*</span>         this.right <span class="hljs-operator">=</span> right;<br> <span class="hljs-operator">*</span>     &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> postorderTraversal(TreeNode root) &#123;<br>        List<span class="hljs-operator">&lt;</span>Integer<span class="hljs-operator">&gt;</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ArrayList<span class="hljs-operator">&lt;&gt;</span>();<br>        <span class="hljs-keyword">if</span>(root <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Stack<span class="hljs-operator">&lt;</span>TreeNode<span class="hljs-operator">&gt;</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> Stack<span class="hljs-operator">&lt;&gt;</span>();<br>        st.push(root);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-operator">!</span>st.isEmpty())&#123;<br>            TreeNode node <span class="hljs-operator">=</span> st.pop();<br>            result.add(node.<span class="hljs-keyword">val</span>);<br>            <span class="hljs-keyword">if</span>(node.left <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.left);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node.right <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>                st.push(node.right);<br>            &#125;<br>        &#125;<br>        Collections.reverse(result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历（统一迭代法）"><a href="#144-二叉树的前序遍历（统一迭代法）" class="headerlink" title="144.二叉树的前序遍历（统一迭代法）"></a>144.二叉树的前序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;<br>        <span class="hljs-comment">//统一模板进行二叉树遍历</span><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//判断右节点是否为空，不为空加入到stack中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果遇到节点为null，首先弹出null节点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<span class="hljs-comment">//弹出不是null的节点（标记的结点）</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                result.add(node.val);<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历（统一迭代法）"><a href="#94-二叉树的中序遍历（统一迭代法）" class="headerlink" title="94.二叉树的中序遍历（统一迭代法）"></a>94.二叉树的中序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//将右节点添加到st中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br><br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//弹出空节点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<span class="hljs-comment">//弹出被标记节点</span><br>                result.add(node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历（统一迭代法）"><a href="#145-二叉树的后序遍历（统一迭代法）" class="headerlink" title="145.二叉树的后序遍历（统一迭代法）"></a>145.二叉树的后序遍历（统一迭代法）</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;TreeNode&gt; st = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-keyword">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.isEmpty())&#123;<br>            TreeNode node = st.peek();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                st.<span class="hljs-keyword">pop</span>();<br>                <span class="hljs-comment">//先将中间节点放进st中</span><br>                st.<span class="hljs-keyword">push</span>(node);<br>                st.<span class="hljs-keyword">push</span>(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">//再将右节点放入stack中</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.right);<br>                &#125;<br>                <span class="hljs-comment">//左节点放入stack中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    st.<span class="hljs-keyword">push</span>(node.left);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//弹出null结点</span><br>                st.<span class="hljs-keyword">pop</span>();<br>                node = st.peek();<br>                st.<span class="hljs-keyword">pop</span>();<br>                result.add(node.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230604</title>
    <link href="/2023/06/04/leetcode-notes-20230604/"/>
    <url>/2023/06/04/leetcode-notes-20230604/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针相关题目"><a href="#双指针相关题目" class="headerlink" title="双指针相关题目"></a>双指针相关题目</h1><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-keyword">val</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125;<br>            fast++;<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>双指针法中出现的题目均为前边几个章节中已经出现过的，这里就不再赘述，可以查看本人之前的博客进行学习。</em></p><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;<br><br>    <span class="hljs-comment">//定义两个栈</span><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>()</span> &#123;<br>        stackIn = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>        stackOut = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        stackIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        <span class="hljs-comment">//调用得到stackOut</span><br>        isStackOut();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>()</span> &#123;<br>        isStackOut();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();<br>    &#125;<br><br>    <span class="hljs-comment">//判断stackOut是否为空，如果是空的，直接将stackIn中的元素放到stackOut中</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isStackOut</span>()</span>&#123;<br>        <span class="hljs-comment">//如果栈不是空的</span><br>        <span class="hljs-keyword">if</span>(!stackOut.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>            stackOut.push(stackIn.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;<br><br>    Queue&lt;Integer&gt; q1;<br>    Queue&lt;Integer&gt; q2;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span>()</span> &#123;<br>        q1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        q2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>        <span class="hljs-comment">//先放在q2辅助队列中，为了保证最后进入的元素最先出来</span><br>        q2.offer(x);<br>        <span class="hljs-comment">//将q1队列中的其他元素加入到q2中</span><br>        <span class="hljs-keyword">while</span>(!q1.isEmpty())&#123;<br>            q2.offer(q1.poll());<br>        &#125;<br>        <span class="hljs-comment">//最后将q2和q1进行交换</span><br>        Queue&lt;Integer&gt; qTemp = q1;<br>        q1 = q2;<br>        q2 = qTemp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.poll();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">top</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> q1.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化栈</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//定义dict用于表示匹配关系</span><br>        Map&lt;Character, Character&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>);<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;&#123;&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>        dict.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.<span class="hljs-built_in">toCharArray</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">containsKey</span>(ch)) &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果此时栈为空，那么表示此时符号进栈之后不可能再找到与之匹配的符号，直接返回false；</span><br>                <span class="hljs-comment">//或者栈不为空，但是此时即将入栈的符号和栈顶的符号不匹配，也直接返回false即可；</span><br>                <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>() || dict.<span class="hljs-built_in">get</span>(stack.<span class="hljs-built_in">pop</span>()) != ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">isEmpty</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化定义栈</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stack</span>&lt;Character&gt;();<br><br>        <span class="hljs-keyword">for</span>(Character ch : s.<span class="hljs-built_in">toCharArray</span>())&#123;<br>            <span class="hljs-comment">//判断栈顶元素是否和当前元素相同，相同同时都删除</span><br>            <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">isEmpty</span>() &amp;&amp; stack.<span class="hljs-built_in">peek</span>() == ch)&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//最终得到stack中的字符串</span><br>        <span class="hljs-type">String</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">isEmpty</span>())&#123;<br>            result = stack.<span class="hljs-built_in">pop</span>() + result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//优化版本，使用了StringBuilder加快了代码执行的效率</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s.<span class="hljs-built_in">toCharArray</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!stack.<span class="hljs-built_in">isEmpty</span>() &amp;&amp; stack.<span class="hljs-built_in">peek</span>() == ch) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            sb.<span class="hljs-built_in">append</span>(stack.<span class="hljs-built_in">pop</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">toString</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> eval<span class="hljs-constructor">RPN(String[] <span class="hljs-params">tokens</span>)</span> &#123;<br>        <span class="hljs-comment">//定义保存符号的Stack</span><br>        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;<br>        Map&lt;String, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        dict.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">1</span>);<br>        dict.put(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">2</span>);<br>        dict.put(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">3</span>);<br>        dict.put(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">for</span>(String str : tokens)&#123;<br>            <span class="hljs-keyword">if</span>(dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">str</span>)</span>)&#123;<br>                <span class="hljs-built_in">int</span> second = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>                <span class="hljs-built_in">int</span> first = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>                <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>                    result = first + second;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">2</span>)&#123;<br>                    result = first - second;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.get(str)<span class="hljs-operator"> == </span><span class="hljs-number">3</span>)&#123;<br>                    result = first<span class="hljs-operator"> * </span>second;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    result = first<span class="hljs-operator"> / </span>second;<br>                &#125;<br>                stack.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">result</span>)</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.push(str);<br>            &#125;<br>        &#125;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">stack</span>.<span class="hljs-params">pop</span>()</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//优化之后的代码</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> eval<span class="hljs-constructor">RPN(String[] <span class="hljs-params">tokens</span>)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinkedList()</span>;<br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span>.equals(s)) &#123;        <span class="hljs-comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br>                stack.push(stack.pop<span class="hljs-literal">()</span> + stack.pop<span class="hljs-literal">()</span>);      <span class="hljs-comment">// 注意 - 和/ 需要特殊处理</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-&quot;</span>.equals(s)) &#123;<br>                stack.push(-stack.pop<span class="hljs-literal">()</span> + stack.pop<span class="hljs-literal">()</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;*&quot;</span>.equals(s)) &#123;<br>                stack.push(stack.pop<span class="hljs-literal">()</span><span class="hljs-operator"> * </span>stack.pop<span class="hljs-literal">()</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/&quot;</span>.equals(s)) &#123;<br>                <span class="hljs-built_in">int</span> temp1 = stack.pop<span class="hljs-literal">()</span>;<br>                <span class="hljs-built_in">int</span> temp2 = stack.pop<span class="hljs-literal">()</span>;<br>                stack.push(temp2<span class="hljs-operator"> / </span>temp1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">s</span>)</span>);<br>            &#125;<br>        &#125;<br>        return stack.pop<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义自己实现的一个基于双端队列的单调队列类</span><br><span class="hljs-keyword">class</span> MyQueue&#123;<br>    Deque&lt;Integer&gt; dequeue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">//设置poll方法</span><br>    void poll(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-comment">//移除的时候判断当前移除的元素是否和队列的头部相同，相同则弹出</span><br>        <span class="hljs-keyword">if</span>(!dequeue.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>dequeue.peek<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)&#123;<br>            dequeue.poll<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置的add方法</span><br>    <span class="hljs-comment">//add的时候需要判断和当前队列中的元素的大小关系，需要维持递减的顺序</span><br>    void add(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">while</span>(!dequeue.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> &amp;&amp; </span>dequeue.get<span class="hljs-constructor">Last()</span> &lt; <span class="hljs-keyword">val</span>)&#123;<br>            dequeue.remove<span class="hljs-constructor">Last()</span>;<span class="hljs-comment">//移除最后的元素</span><br>        &#125;<br>        <span class="hljs-comment">//增加到队列中</span><br>        dequeue.add(<span class="hljs-keyword">val</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获得队列头部元素值</span><br>    <span class="hljs-built_in">int</span> peek<span class="hljs-literal">()</span>&#123;<br>        return dequeue.peek<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> max<span class="hljs-constructor">SlidingWindow(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>            return nums;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> len = nums.length -k + <span class="hljs-number">1</span>;<span class="hljs-comment">//定义最后结果数组的长度</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置的结果数组对应的index索引值</span><br><br>        MyQueue myqueue = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyQueue()</span>;<br><br>        <span class="hljs-comment">//先将前k个元素放入队列中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            myqueue.add(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//得到第一个前k个元素中最大值</span><br>        result<span class="hljs-literal">[<span class="hljs-identifier">index</span><span class="hljs-operator">++</span>]</span> = myqueue.peek<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">//循环遍历后边的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-comment">//滑动窗口往后移动一格，首先判断队列中的第一个元素是否需要弹出</span><br>            myqueue.poll(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-identifier">k</span>]</span>);<br>            <span class="hljs-comment">//然后判断，增加的元素是否需要到达队顶</span><br>            myqueue.add(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>            <span class="hljs-comment">//记录最大值</span><br>            result<span class="hljs-literal">[<span class="hljs-identifier">index</span><span class="hljs-operator">++</span>]</span> = myqueue.peek<span class="hljs-literal">()</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> top<span class="hljs-constructor">KFrequent(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">//key为元素，value为元素出现的频率</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i: nums)&#123;<br>            map.put(i, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">i</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//按照map的value进行排序</span><br>        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; sortedList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.entry<span class="hljs-constructor">Set()</span>);<br>        <span class="hljs-comment">// 使用 Comparator 和流式操作按照 value 进行降序排序</span><br>        sortedList.sort(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Map</span>.</span><span class="hljs-module"><span class="hljs-identifier">Entry</span>.</span></span>comparing<span class="hljs-constructor">ByValue(Comparator.<span class="hljs-params">reverseOrder</span>()</span>));<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i ++)&#123;<br>            result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sortedList.get(i).get<span class="hljs-constructor">Key()</span>;    <br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//使用小顶堆实现</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> top<span class="hljs-constructor">KFrequent(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-comment">//保存key-value对应的字典</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> num: nums)&#123;<br>            map.put(num, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">num</span>, 0)</span> + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//创建优先级队列</span><br>        <span class="hljs-comment">//后边设置插入的顺序为构建小顶堆</span><br>        PriorityQueue&lt;<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair1<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>-pair2<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>);<br>        <br>        <span class="hljs-comment">//遍历map，开始插入</span><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: map.entry<span class="hljs-constructor">Set()</span>)&#123;<br>            <span class="hljs-comment">//首先，判断小顶堆中元素个数，如果小于k，直接插入即可</span><br>            <span class="hljs-keyword">if</span>(pq.size<span class="hljs-literal">()</span> &lt; k)&#123;<br>                pq.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;entry.get<span class="hljs-constructor">Key()</span>, entry.get<span class="hljs-constructor">Value()</span>&#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//判断当前准备插入的元素对是否大于当前顶点，如果是，删除顶点，然后直接插入当前节点</span><br>                <span class="hljs-keyword">if</span>(entry.get<span class="hljs-constructor">Value()</span> &gt; pq.peek<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>)&#123;<br>                    <span class="hljs-comment">//先弹出顶点元素</span><br>                    pq.poll<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">//然后插入</span><br>                    pq.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;entry.get<span class="hljs-constructor">Key()</span>, entry.get<span class="hljs-constructor">Value()</span>&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//创建返回数组结果</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>        <span class="hljs-comment">//循环pq队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            result<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = pq.poll<span class="hljs-literal">()</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>双指针</tag>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230602</title>
    <link href="/2023/06/02/leetcode-notes-20230602/"/>
    <url>/2023/06/02/leetcode-notes-20230602/</url>
    
    <content type="html"><![CDATA[<h2 id="459-重复的子字符串（需要不定时回顾，使用了KMP算法）"><a href="#459-重复的子字符串（需要不定时回顾，使用了KMP算法）" class="headerlink" title="459.重复的子字符串（需要不定时回顾，使用了KMP算法）"></a>459.重复的子字符串（需要不定时回顾，使用了KMP算法）</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-comment">//得到前缀表的函数</span><br>    void get<span class="hljs-constructor">Next(<span class="hljs-params">int</span>[] <span class="hljs-params">next</span>, String <span class="hljs-params">s</span>)</span>&#123;<br>        next<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                j = next<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>;<br>            &#125;<br>            <span class="hljs-comment">//判断字符串s中对应位置为i和j是否包含相等的字符</span><br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                j++;<br>            &#125;<br>            next<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = j;<br>        &#125;<br>    &#125;<br><br>    public boolean repeated<span class="hljs-constructor">SubstringPattern(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">//使用KMP字符串匹配算法实现</span><br>        <span class="hljs-keyword">if</span>(s.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//构造长度为s.length()的next数组</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">s</span>.<span class="hljs-identifier">length</span>()]</span>;<br>        get<span class="hljs-constructor">Next(<span class="hljs-params">next</span>, <span class="hljs-params">s</span>)</span>;<br>        <span class="hljs-built_in">int</span> len = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(next<span class="hljs-literal">[<span class="hljs-identifier">len</span> - <span class="hljs-number">1</span>]</span> != <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>len % (len - next<span class="hljs-literal">[<span class="hljs-identifier">len</span> - <span class="hljs-number">1</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
      <tag>字符串处理相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230601</title>
    <link href="/2023/06/01/leetcode-notes-20230601/"/>
    <url>/2023/06/01/leetcode-notes-20230601/</url>
    
    <content type="html"><![CDATA[<h2 id="350-两个数组的交集"><a href="#350-两个数组的交集" class="headerlink" title="350.两个数组的交集"></a>350.两个数组的交集</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] <span class="hljs-keyword">intersect</span>(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span>[] record1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-type">int</span>[] record2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br><br>        <span class="hljs-type">int</span> nums1Length = nums1.length;<br>        <span class="hljs-type">int</span> nums2Length = nums2.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1Length;i++)&#123;<br>            record1[nums1[i]]++; <br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; nums2Length;i++)&#123;<br>            record2[nums2[i]]++;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; tmp = <span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        <br>        <span class="hljs-type">int</span> n = Math.max(record1.length, record2.length);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(record1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; record2[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> m = Math.min(record1[i], record2[i]);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m;j++)&#123;<br>                    tmp.<span class="hljs-keyword">add</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[tmp.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.size();i++)&#123;<br>            result[i] = tmp.<span class="hljs-keyword">get</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//得到数字n的每个位置上的数字平方和</span><br>    <span class="hljs-built_in">int</span> getSum(<span class="hljs-built_in">int</span> n)&#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">sum</span> += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isHappy(<span class="hljs-built_in">int</span> n) &#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-built_in">int</span> currSum = getSum(n);<br>            <span class="hljs-keyword">if</span>(currSum == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(dict.containsKey(currSum) &amp;&amp; dict.get(currSum) != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dict.put(currSum, <span class="hljs-number">1</span>);<br>            &#125;<br>            n = currSum;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> </span>&#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums2.length;j++)&#123;<br>                map.<span class="hljs-built_in">put</span>(nums1[i] + nums2[j], map.<span class="hljs-built_in">getOrDefault</span>(nums1[i] + nums2[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums3.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; nums4.length;j++)&#123;<br>                count += map.<span class="hljs-built_in">getOrDefault</span>(<span class="hljs-number">0</span> - (nums3[i] + nums4[j]), <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">//首先对nums进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//判断第一个nums是否为大于0，如果是直接返回空的list</span><br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br><br>        <span class="hljs-comment">//然后使用双指针循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-comment">//从i=1开始，判断当前元素和前一个元素是否相同，相同直接跳过</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//然后使用双指针</span><br>            <span class="hljs-built_in">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//当left&lt;right时进入循环</span><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-comment">//判断三者之和与0的大小关系</span><br>                <span class="hljs-comment">//当三者之和大于0时，right--</span><br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//三者之和等于0，那么作为一个结果添加到result中</span><br>                    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    tmp.<span class="hljs-keyword">add</span>(nums[i]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[left]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[right]);<br>                    result.<span class="hljs-keyword">add</span>(tmp);<span class="hljs-comment">//将当前的结果list添加到result中</span><br><br>                    <span class="hljs-comment">//然后去除和left/right重复的元素</span><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br><br>                    left++;<span class="hljs-comment">//左指针向右++</span><br>                    right--;<span class="hljs-comment">//右指针向左--</span><br>                    <br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>;i ++)&#123;<br>            <span class="hljs-comment">//进行剪枝处理</span><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-keyword">target</span> &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//进入第二层循环</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length;j++)&#123;<br>                <span class="hljs-comment">//剪枝</span><br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; <span class="hljs-keyword">target</span> &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//对j进行去重</span><br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">int</span> left = j + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//准备使用双指针</span><br>                <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i] + nums[j] + nums[left] + nums[right] &gt; <span class="hljs-keyword">target</span>)&#123;<br>                        right--;<br>                    &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[i] + nums[j] + nums[left] + nums[right] &lt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                        left++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                        tmp.add(nums[i]);<br>                        tmp.add(nums[j]);<br>                        tmp.add(nums[left]);<br>                        tmp.add(nums[right]);<br>                        result.add(tmp);<br><br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])&#123;<br>                            right--;<br>                        &#125;<br><br>                        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;<br>                            left++;<br>                        &#125;<br><br>                        left++;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public void reverseString(<span class="hljs-built_in">char</span>[] s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = s.length - <span class="hljs-number">1</span>;<br><br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">char</span> tmp = s[<span class="hljs-built_in">left</span>];<br>            s[<span class="hljs-built_in">left</span>] = s[<span class="hljs-built_in">right</span>];<br>            s[<span class="hljs-built_in">right</span>] = tmp;<br>            <span class="hljs-built_in">left</span>++;<br>            <span class="hljs-built_in">right</span>--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541.反转字符串 II"></a>541.反转字符串 II</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-type">void</span> reverse(<span class="hljs-type">char</span>[] s_char, <span class="hljs-type">int</span> <span class="hljs-keyword">begin</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-type">char</span> tmp = s_char[<span class="hljs-keyword">end</span>];<br>            s_char[<span class="hljs-keyword">end</span>] = s_char[<span class="hljs-keyword">begin</span>];<br>            s_char[<span class="hljs-keyword">begin</span>] = tmp;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> String reverseStr(String s, <span class="hljs-type">int</span> k) &#123;<br>        //将String字符串转换为<span class="hljs-type">char</span>数组<br>        <span class="hljs-type">char</span>[] s_char = s.toCharArray();<br>        <span class="hljs-type">int</span> n = s.length();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(;i &lt; n;i = i + <span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-type">int</span> start = i;<br>            <span class="hljs-type">int</span> end = Math.min(n - <span class="hljs-number">1</span>, <span class="hljs-keyword">start</span> + k - <span class="hljs-number">1</span>);<br>            reverse(s_char, <span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(s_char);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String replace<span class="hljs-constructor">Space(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s<span class="hljs-operator"> == </span>null)&#123;<br>            return null;<br>        &#125;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>            &#125;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br><br>    void reverse<span class="hljs-constructor">String(StringBuilder <span class="hljs-params">sb</span>, <span class="hljs-params">int</span> <span class="hljs-params">begin</span>, <span class="hljs-params">int</span> <span class="hljs-params">end</span>)</span>&#123;<br>        <span class="hljs-comment">//然后反转字符串</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">begin</span> &lt; <span class="hljs-keyword">end</span>)&#123;<br>            <span class="hljs-built_in">char</span> tmp = sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">begin</span>)</span>;<br>            sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">begin</span>, <span class="hljs-params">sb</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">end</span>)</span>);<br>            sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">end</span>, <span class="hljs-params">tmp</span>)</span>;<br>            <span class="hljs-keyword">begin</span>++;<br>            <span class="hljs-keyword">end</span>--;<br>        &#125;<br>    &#125;<br><br>    public String reverse<span class="hljs-constructor">Words(String <span class="hljs-params">s</span>)</span> &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-comment">//先删除字符串中前边或后边的空格</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = s.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-comment">//去除字符串中间多余的空格</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span> != <span class="hljs-character">&#x27; &#x27;</span><span class="hljs-operator"> || </span>sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">sb</span>.<span class="hljs-params">length</span>()</span> - <span class="hljs-number">1</span>) != <span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>);<br>            &#125;<br>            left++;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">begin</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = sb.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<br>        reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>, <span class="hljs-params">begin</span>, <span class="hljs-params">end</span>)</span>;<br><br>        <span class="hljs-comment">//反转字符串之后，反转字符串中每个单词</span><br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> inner_end = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> n = sb.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">while</span>(start &lt; n)&#123;<br>            <span class="hljs-keyword">while</span>(inner_end &lt; n<span class="hljs-operator"> &amp;&amp; </span>sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">inner_end</span>)</span> != <span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>                inner_end++;<br>            &#125;<br>            <span class="hljs-comment">//反转从start到end的字符串</span><br>            reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>, <span class="hljs-params">start</span>, <span class="hljs-params">inner_end</span> - 1)</span>;<br>            <span class="hljs-comment">//然后进入下一个单词</span><br>            start = inner_end + <span class="hljs-number">1</span>;<br>            inner_end = start + <span class="hljs-number">1</span>;<br>        &#125;<br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer58-II-左旋转字符串"><a href="#剑指Offer58-II-左旋转字符串" class="headerlink" title="剑指Offer58-II.左旋转字符串"></a>剑指Offer58-II.左旋转字符串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String reverse<span class="hljs-constructor">LeftWords(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> l = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">//得到实际左旋转的格数</span><br>        <span class="hljs-built_in">int</span> k = n % l;<br><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k;i &lt; l;i++)&#123;<br>            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;<br>            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>        &#125;<br><br>        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a>28.找出字符串中第一个匹配项的下标</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> str<span class="hljs-constructor">Str(String <span class="hljs-params">haystack</span>, String <span class="hljs-params">needle</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(haystack.length<span class="hljs-literal">()</span> &lt; needle.length<span class="hljs-literal">()</span>) return -<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> result = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; haystack.length<span class="hljs-literal">()</span>)&#123;<br>            <span class="hljs-comment">//每次设置j从0开始</span><br>            j = <span class="hljs-number">0</span>;<br>            result = i;<br>            <span class="hljs-comment">//判断是否成功，成功直接返回true，否则返回false</span><br>            <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                <span class="hljs-keyword">while</span>(j &lt; needle.length<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>i &lt; haystack.length<span class="hljs-literal">()</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span>needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)&#123;<br>                        i++;<br>                        j++;<br>                        continue;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        break;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-operator"> == </span>needle.length<span class="hljs-literal">()</span>)&#123;<br>                    return result;<br>                &#125;<br>            &#125;<br>            i = result + <span class="hljs-number">1</span>;<br>        &#125;<br>        return -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230531</title>
    <link href="/2023/05/31/leetcode-notes-20230531/"/>
    <url>/2023/05/31/leetcode-notes-20230531/</url>
    
    <content type="html"><![CDATA[<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//慢指针每次走一步</span><br>            slow = slow.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//快指针每次走两步</span><br>            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-comment">//如果两个指针相遇，那么一个指针从相遇结点出发，一个指针从头节点出发，等到下次两个节点相遇的时候就是链表环形入口结点</span><br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                ListNode index1 = fast;<br>                ListNode index2 = head;<br>                <span class="hljs-keyword">while</span>(index1 != index2)&#123;<br>                    index1 = index1.<span class="hljs-keyword">next</span>;<br>                    index2 = index2.<span class="hljs-keyword">next</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD##"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>##</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> isAnagram(String s, String t) &#123;<br>        //设置<span class="hljs-type">record</span>数组的长度大小为<span class="hljs-number">26</span>（<span class="hljs-number">26</span>个小写字母）<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; s.length();i++)&#123;<br>            <span class="hljs-type">record</span>[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; t.length();i++)&#123;<br>            <span class="hljs-type">record</span>[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> canConstruct(String ransomNote, String magazine) &#123;<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.length();i++)&#123;<br>            <span class="hljs-type">record</span>[ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; magazine.length();i++)&#123;<br>            <span class="hljs-type">record</span>[magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        //数组作为map<br>        <span class="hljs-type">int</span>[] <span class="hljs-type">record</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.length;i++)&#123;<br>            //map只记录是否有，并不需要记录每个key值对应的<span class="hljs-keyword">values</span>数量<br>            <span class="hljs-type">record</span>[nums1[i]] = <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[nums2[i]] == <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">record</span>[nums2[i]] = <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; tmpList = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;(); <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-type">record</span>.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">record</span>[i] == <span class="hljs-number">3</span>)&#123;<br>                tmpList.<span class="hljs-keyword">add</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[tmpList.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: tmpList)&#123;<br>            result[<span class="hljs-keyword">index</span>] = tmpList.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">index</span>);<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>0faf98f2fe074769adf459ed307fb014a35a9876</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230528</title>
    <link href="/2023/05/28/leetcode-notes-20230528/"/>
    <url>/2023/05/28/leetcode-notes-20230528/</url>
    
    <content type="html"><![CDATA[<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode removeElements(ListNode head, int val) &#123;<br>        ListNode <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">ListNode</span>();<br>        ListNode resultHead = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = head;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val != val)&#123;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = head;<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Head</span>.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> resultHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//定义链表的结点类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br>     int <span class="hljs-keyword">val</span>;<span class="hljs-comment">//定义链表中的值</span><br>     ListNode next;<br>     <span class="hljs-comment">//创建构造函数</span><br>     ListNode()&#123;&#125;<br>     <span class="hljs-comment">//创建自定义构造函数</span><br>     ListNode(int <span class="hljs-keyword">val</span>)&#123;<br>         <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>    <span class="hljs-comment">//定义链表的成员变量</span><br>    int size;<br>    <span class="hljs-comment">//定义一个虚拟的头结点</span><br>    ListNode head;<br><br>    <span class="hljs-comment">//在默认构造函数中初始化链表</span><br>    <span class="hljs-keyword">public</span> MyLinkedList() &#123;<br>        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.head = new ListNode(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> int <span class="hljs-keyword">get</span>(int index) &#123;<br>        <span class="hljs-comment">//首先判断index是否无效，如果无效返回-1</span><br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.size)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        ListNode resultNode = <span class="hljs-keyword">this</span>.head;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt;= index;i ++)&#123;<br>            resultNode = resultNode.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode.<span class="hljs-keyword">val</span>; <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtHead(int <span class="hljs-keyword">val</span>) &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, <span class="hljs-keyword">val</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtTail(int <span class="hljs-keyword">val</span>) &#123;<br>        addAtIndex(<span class="hljs-keyword">this</span>.size, <span class="hljs-keyword">val</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void addAtIndex(int index, int <span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-keyword">this</span>.size)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>            index = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.size++;<br><br>        ListNode predNode = <span class="hljs-keyword">this</span>.head;<br>        <span class="hljs-comment">//得到predNode（要插入结点的前驱）</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; index;i++)&#123;<br>            predNode = predNode.next;<br>        &#125;<br><br>        ListNode addNode = new ListNode(<span class="hljs-keyword">val</span>);<br>        addNode.next = predNode.next;<br>        predNode.next = addNode;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> void deleteAtIndex(int index) &#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-keyword">this</span>.size || index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.size--;<br>        <span class="hljs-comment">//判断index是否为0</span><br>        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode predNode = head;<br>        <span class="hljs-comment">//找到需要删除结点的前驱结点</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; index;i++)&#123;<br>            predNode = predNode.next;<br>        &#125;<br><br>        predNode.next = predNode.next.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj.get(index);</span><br><span class="hljs-comment"> * obj.addAtHead(val);</span><br><span class="hljs-comment"> * obj.addAtTail(val);</span><br><span class="hljs-comment"> * obj.addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj.deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">/**</span><br> <span class="hljs-operator">*</span> Definition <span class="hljs-keyword">for</span> singly<span class="hljs-operator">-</span>linked list.<br> <span class="hljs-operator">*</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ListNode &#123;<br> <span class="hljs-operator">*</span>     int <span class="hljs-keyword">val</span>;<br> <span class="hljs-operator">*</span>     ListNode next;<br> <span class="hljs-operator">*</span>     ListNode() &#123;&#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; &#125;<br> <span class="hljs-operator">*</span>     ListNode(int <span class="hljs-keyword">val</span>, ListNode next) &#123; this.<span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">val</span>; this.next <span class="hljs-operator">=</span> next; &#125;<br> <span class="hljs-operator">*</span> &#125;<br> <span class="hljs-operator">*/</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;<br>        ListNode currNode <span class="hljs-operator">=</span> head;<br>        ListNode resultNode <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        ListNode tmpNode <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span>(currNode <span class="hljs-operator">!=</span> <span class="hljs-literal">null</span>)&#123;<br>            tmpNode <span class="hljs-operator">=</span> currNode.next;<br>            currNode.next <span class="hljs-operator">=</span> resultNode;<br>            resultNode <span class="hljs-operator">=</span> currNode;<br>            currNode <span class="hljs-operator">=</span> tmpNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-两两交换链表中的结点"><a href="#24-两两交换链表中的结点" class="headerlink" title="24.两两交换链表中的结点"></a>24.两两交换链表中的结点</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;<br>        ListNode xuniHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        xuniHead.<span class="hljs-keyword">next</span> = head;<br>        ListNode curr = xuniHead;<br><br>        <span class="hljs-keyword">while</span>(curr.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;<br>            ListNode tmp = curr.<span class="hljs-keyword">next</span>;<br>            ListNode tmp1 = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>            curr.<span class="hljs-keyword">next</span> = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = tmp;<br>            curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = tmp1;<br><br>            curr = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> xuniHead.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy.<span class="hljs-keyword">next</span> = head;<br>        ListNode fast = dummy;<br>        ListNode slow = dummy;<br><br>        <span class="hljs-comment">//先移动快指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            fast = fast.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//同时移动快慢指针</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>)&#123;<br>            fast = fast.<span class="hljs-keyword">next</span>;<br>            slow = slow.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面试题02-07-链表相交"><a href="#面试题02-07-链表相交" class="headerlink" title="面试题02.07.链表相交"></a>面试题02.07.链表相交</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;<br>        ListNode currA = headA;<br>        ListNode currB = headB;<br>        <span class="hljs-built_in">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> lenB = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(currA != <span class="hljs-literal">null</span>)&#123;<br>            currA = currA.<span class="hljs-keyword">next</span>;<br>            lenA++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(currB != <span class="hljs-literal">null</span>)&#123;<br>            currB = currB.<span class="hljs-keyword">next</span>;<br>            lenB++;<br>        &#125;<br><br>        currA = headA;<br>        currB = headB;<br><br>        <span class="hljs-comment">//使得currA指向较长链表的那个</span><br>        <span class="hljs-keyword">if</span>(lenA &lt; lenB)&#123;<br>            <span class="hljs-built_in">int</span> tmpL = lenA;<br>            lenA = lenB;<br>            lenB = tmpL;<br>            <br>            ListNode tmpNode = currA;<br>            currA = currB;<br>            currB = tmpNode;<br>        &#125;<br><br>        <span class="hljs-comment">//求两者的长度差</span><br>        <span class="hljs-built_in">int</span> gap = lenA - lenB;<br><br>        <span class="hljs-comment">//然后使得较长的指针移动到较短的链表的尾部位置</span><br>        <span class="hljs-keyword">while</span>(gap-- &gt; <span class="hljs-number">0</span>)&#123;<br>            currA = currA.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//同时移动两个链表的指针</span><br>        <span class="hljs-keyword">while</span>(currA != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(currA == currB)&#123;<br>                <span class="hljs-keyword">return</span> currA;<br>            &#125;<br><br>            currA = currA.<span class="hljs-keyword">next</span>;<br>            currB = currB.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230527</title>
    <link href="/2023/05/27/leetcode-notes-20230527/"/>
    <url>/2023/05/27/leetcode-notes-20230527/</url>
    
    <content type="html"><![CDATA[<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[][] generateMatrix(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-comment">//定义一个动态增加的list，最后转换为int即可</span><br>        <span class="hljs-built_in">int</span>[][] matrixResult = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n][n];<br><br>        <span class="hljs-comment">//设置给每个格子赋值的值</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始值设置为1</span><br>        <span class="hljs-built_in">int</span> offset = <span class="hljs-number">1</span>;<span class="hljs-comment">//设置的每圈应该在右开的时候减少的偏移量</span><br>        <span class="hljs-built_in">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> loop = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> mid = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(loop &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-comment">//上行：从左到右进行填充</span><br>            <span class="hljs-keyword">for</span>(j = startY;j &lt; n - offset;j++)&#123;<br>                matrixResult[startX][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-comment">//右列：从上到下及逆行填充</span><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; n - offset; i++)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; j &gt; startY;j--)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; i &gt; startX;i--)&#123;<br>                matrixResult[i][j] = <span class="hljs-keyword">count</span>++;<br>            &#125;<br><br>            <span class="hljs-comment">//将对应的startX和startY进行更新</span><br>            startX++;<br>            startY++;<br><br>            offset++;<br>            loop--;<br>        &#125;<br><br>        <span class="hljs-comment">//最后判断是否需要填充中心位置的元素</span><br>        <span class="hljs-comment">//也就是n为奇数时需要填充</span><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            matrixResult[mid][mid] = <span class="hljs-keyword">count</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrixResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.length;<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">loop</span> = Math.min(m, n) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">loop</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>;j++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>;i++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(;j &gt; startY; j<span class="hljs-comment">--)&#123;</span><br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(;i &gt; startX;i<span class="hljs-comment">--)&#123;</span><br>                result.<span class="hljs-keyword">add</span>(matrix[i][j]);<br>            &#125;<br><br>            startX++;<br>            startY++;<br>            <span class="hljs-keyword">offset</span>++;<br><br>            <span class="hljs-keyword">loop</span> <span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(result.size() == n * m)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <br>        //添加<br>        <span class="hljs-keyword">if</span>(m &gt; n)&#123;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>;i++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[i][startY]);<br>            &#125;<br>            result.<span class="hljs-keyword">add</span>(matrix[i][startY]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j++)&#123;<br>                result.<span class="hljs-keyword">add</span>(matrix[startX][j]);<br>            &#125;<br>            result.<span class="hljs-keyword">add</span>(matrix[startX][j]);        <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; n == m)&#123;<br>            result.<span class="hljs-keyword">add</span>(matrix[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指offer29-顺时针打印矩阵"><a href="#剑指offer29-顺时针打印矩阵" class="headerlink" title="剑指offer29.顺时针打印矩阵"></a>剑指offer29.顺时针打印矩阵</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] spiralOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> m = matrix.length;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m*n];<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> startX = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> startY = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">loop</span> = Math.min(m, n) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">loop</span> &gt; <span class="hljs-number">0</span>)&#123;<br>            i = startX;<br>            j = startY;<br><br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j ++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>; i ++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; j &gt; startY; j<span class="hljs-comment">--)&#123;</span><br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(; i &gt; startX; i<span class="hljs-comment">--)&#123;</span><br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][j];<br>            &#125;<br><br>            startX++;<br>            startY++;<br>            <span class="hljs-keyword">offset</span>++;<br>            <span class="hljs-keyword">loop</span><span class="hljs-comment">--;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span> == m*n)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;here&quot;);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(m &gt; n)&#123;<br>            <span class="hljs-keyword">for</span>(i = startX; i &lt; m - <span class="hljs-keyword">offset</span>; i++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[i][startY];<br>            &#125;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[m - <span class="hljs-keyword">offset</span>][startY];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">for</span>(j = startY; j &lt; n - <span class="hljs-keyword">offset</span>; j++)&#123;<br>                result[<span class="hljs-keyword">index</span>++] = matrix[startX][j];<br>            &#125;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[startX][n - <span class="hljs-keyword">offset</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == n &amp;&amp; m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            result[<span class="hljs-keyword">index</span>++] = matrix[m / <span class="hljs-number">2</span>][m / <span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs-20230525</title>
    <link href="/2023/05/25/leetcode-notes-20230525/"/>
    <url>/2023/05/25/leetcode-notes-20230525/</url>
    
    <content type="html"><![CDATA[<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//滑动窗口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> target, <span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">1000000001</span>;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">sum</span> &gt;= target)&#123;<br>                <span class="hljs-built_in">int</span> in_result = (i - start) + <span class="hljs-number">1</span>;<br>                result = result &lt; in_result ? result : in_result;<br>                <span class="hljs-keyword">sum</span> -= nums[start++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == <span class="hljs-number">1000000001</span> ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//超时写法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> total<span class="hljs-constructor">Fruit(<span class="hljs-params">int</span>[] <span class="hljs-params">fruits</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = fruits.length;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max_num = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">while</span>(is<span class="hljs-constructor">AboveTwo(<span class="hljs-params">fruits</span>, <span class="hljs-params">start</span>, <span class="hljs-params">i</span>)</span><span class="hljs-operator"> &amp;&amp; </span>start &lt; i)&#123;<br>                start ++;<br>            &#125;<br>            max_num = max_num &lt; (i - start) + <span class="hljs-number">1</span> ? (i - start) + <span class="hljs-number">1</span> : max_num;<br>        &#125;<br>        return max_num;<br>    &#125;<br><br>    <span class="hljs-comment">//判断从start到i之间是否有超过两种不同类型的水果</span><br>    boolean is<span class="hljs-constructor">AboveTwo(<span class="hljs-params">int</span>[] <span class="hljs-params">array</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span>&#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = left; i &lt;= right;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span><span class="hljs-operator"> &amp;&amp; </span>dict.size<span class="hljs-literal">()</span> &lt; <span class="hljs-number">2</span>)&#123;<br>                dict.put(<span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, <span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span><span class="hljs-operator"> &amp;&amp; </span>dict.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">2</span>)&#123;<br>                return <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">array</span>[<span class="hljs-params">i</span>])</span>)&#123;<br>                continue;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//滑动窗口写法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> total<span class="hljs-constructor">Fruit(<span class="hljs-params">int</span>[] <span class="hljs-params">fruits</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = fruits.length;<br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> max_num = -<span class="hljs-number">1</span>;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>            <span class="hljs-comment">//获得原来存在map中的对应的水果种类的水果树数量</span><br>            dict.put(fruits<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">fruits</span>[<span class="hljs-params">i</span>], 0)</span> + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//然后判断当前窗口中是否存在超过两种水果</span><br>            <span class="hljs-keyword">while</span>(dict.size<span class="hljs-literal">()</span> &gt; <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-comment">//设置start对应的位置水果种类对应的树木数量 - 1</span><br>                dict.put(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>, dict.get(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>) - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//如果在当前滑动窗口中不存在对应的种类的树木（即树木数量为0）</span><br>                <span class="hljs-keyword">if</span>(dict.get(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//那么直接删除dict字典中对应的key</span><br>                    dict.remove(fruits<span class="hljs-literal">[<span class="hljs-identifier">start</span>]</span>);<br>                &#125;<br>                <span class="hljs-comment">//然后滑动窗口左边start向左移动一位</span><br>                start ++;<br>            &#125;<br>            <span class="hljs-comment">//然后，更新最大值</span><br>            max_num = max_num &lt; (i - start) + <span class="hljs-number">1</span> ? (i - start) + <span class="hljs-number">1</span> : max_num;<br>        &#125;<br>        return max_num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String min<span class="hljs-constructor">Window(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> sn = s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> tn = t.length<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-built_in">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> minLen = Integer.MAX_VALUE;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br><br>        Map&lt;Character, Integer&gt; tDict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; tn; i++) &#123;<br>            tDict.put(t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>, tDict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">t</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        Map&lt;Character, Integer&gt; windowDict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> formed = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录窗口中满足条件的字符数量</span><br><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sn) &#123;<br>            <span class="hljs-built_in">char</span> c = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>;<br>            windowDict.put(c, windowDict.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">c</span>, 0)</span> + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (tDict.contains<span class="hljs-constructor">Key(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> &amp;&amp; </span>windowDict.get(c).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span><span class="hljs-operator"> == </span>tDict.get(c).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>) &#123;<br>                formed++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (left &lt;= right<span class="hljs-operator"> &amp;&amp; </span>formed<span class="hljs-operator"> == </span>tDict.size<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-comment">// 更新最小窗口长度和结果</span><br>                <span class="hljs-built_in">int</span> curLen = right - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (curLen &lt; minLen) &#123;<br>                    minLen = curLen;<br>                    result = s.substring(left, right + <span class="hljs-number">1</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 缩小窗口左边界</span><br>                <span class="hljs-built_in">char</span> leftChar = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>;<br>                windowDict.put(leftChar, windowDict.get(leftChar) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (tDict.contains<span class="hljs-constructor">Key(<span class="hljs-params">leftChar</span>)</span><span class="hljs-operator"> &amp;&amp; </span>windowDict.get(leftChar).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span> &lt; tDict.get(leftChar).<span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>) &#123;<br>                    formed--;<br>                &#125;<br><br>                left++;<br>            &#125;<br><br>            right++;<br>        &#125;<br><br>        return result;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my-leetcode-logs</title>
    <link href="/2023/05/24/leetcode-notes-20230524/"/>
    <url>/2023/05/24/leetcode-notes-20230524/</url>
    
    <content type="html"><![CDATA[<h1 id="My-LeetCode-HOT-100-logs"><a href="#My-LeetCode-HOT-100-logs" class="headerlink" title="My LeetCode HOT 100 logs"></a>My LeetCode HOT 100 logs</h1><p><em>use language: java</em></p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == <span class="hljs-keyword">target</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-built_in">String</span>[] strs) &#123;<br>        Map&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>: strs)&#123;<br>            <span class="hljs-type">char</span>[] array = <span class="hljs-built_in">str</span>.<span class="hljs-property">toCharArray</span>();<br>            Arrays.<span class="hljs-property">sort</span>(array);<br>            <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(array);<br>            List&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-built_in">map</span>.<span class="hljs-property">getOrDefault</span>(<span class="hljs-built_in">key</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;<span class="hljs-built_in">String</span>&gt;());<br>            list.<span class="hljs-property">add</span>(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">key</span>, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt;(<span class="hljs-built_in">map</span>.<span class="hljs-property">values</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128.最长连续序列"></a>128.最长连续序列</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-built_in">int</span> longestConsecutive(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">Set</span>&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>            <span class="hljs-keyword">set</span>.add(<span class="hljs-built_in">num</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">set</span>.contains(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">int</span> currNum = <span class="hljs-built_in">num</span>;<br>                <span class="hljs-built_in">int</span> inner_result = <span class="hljs-number">1</span>;<br><br>                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">set</span>.contains(currNum + <span class="hljs-number">1</span>))&#123;<br>                    inner_result += <span class="hljs-number">1</span>;<br>                    currNum += <span class="hljs-number">1</span>;<br>                &#125;<br>                <br>                result = Math.max(result, inner_result);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span> &#123;<br>    public void moveZeroes(int[] nums) &#123;<br>        int n = nums.length;<br>        <br>        int <span class="hljs-built_in">lp</span> = <span class="hljs-number">0</span>;<br>        int <span class="hljs-built_in">rp</span> = <span class="hljs-built_in">lp</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">lp</span> != n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-type">lp</span>] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-built_in">rp</span> != n)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[<span class="hljs-type">rp</span>] != <span class="hljs-number">0</span>)&#123;<br>                        int tmp = nums[<span class="hljs-type">rp</span>];<br>                        nums[<span class="hljs-type">rp</span>] = nums[<span class="hljs-type">lp</span>];<br>                        nums[<span class="hljs-type">lp</span>] = tmp;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">rp</span> += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">lp</span> += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">rp</span> = <span class="hljs-built_in">lp</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> maxArea(<span class="hljs-built_in">int</span>[] height) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = height.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> area = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">int</span> h = Math.min(height[<span class="hljs-built_in">left</span>], height[<span class="hljs-built_in">right</span>]);<br>            area = Math.max(area, h * (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>));<br>            <span class="hljs-built_in">if</span>(height[<span class="hljs-built_in">left</span>] &lt; height[<span class="hljs-built_in">right</span>])&#123;<br>                <span class="hljs-built_in">left</span> ++;<br>            &#125;else&#123;<br>                <span class="hljs-built_in">right</span> -- ;<br>            &#125;<br>        &#125;<br>        return area;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; threeSum(<span class="hljs-type">int</span>[] nums) &#123;<br>        //首先先排序（升序）<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> n = nums.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            //判断i位置的元素是否和其前一个元素相同，相同那么进入下一次循环<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>)&#123;<br>                    right<span class="hljs-comment">--;</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; tmp = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>                    tmp.<span class="hljs-keyword">add</span>(nums[i]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[left]);<br>                    tmp.<span class="hljs-keyword">add</span>(nums[right]);<br>                    result.<span class="hljs-keyword">add</span>(tmp);<br><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right - <span class="hljs-number">1</span>] == nums[right])&#123;<br>                        right<span class="hljs-comment">--;</span><br>                    &#125;<br><br>                    <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left + <span class="hljs-number">1</span>] == nums[left])&#123;<br>                        left++;<br>                    &#125;<br><br>                    right<span class="hljs-comment">--;</span><br>                    left++;<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> lengthOfLongestSubstring(String s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = s.length();<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>)&#123;<br>            Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();<br>            map.put(s.charAt(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">left</span>);<br>            while(<span class="hljs-built_in">right</span> &lt; <span class="hljs-built_in">n</span> &amp;&amp; !map.containsKey(s.charAt(<span class="hljs-built_in">right</span>)))&#123;<br>                map.put(s.charAt(<span class="hljs-built_in">right</span>), <span class="hljs-built_in">right</span>);<br>                <span class="hljs-built_in">right</span>++;<br>            &#125;<br>            result = Math.max(result, <span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>);<br>            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">char</span>[] p_chars = p.<span class="hljs-built_in">toCharArray</span>(); <span class="hljs-comment">// 转换为字符数组</span><br>        Arrays.<span class="hljs-built_in">sort</span>(p_chars); <span class="hljs-comment">// 对字符数组进行排序</span><br>        <span class="hljs-type">String</span> sorted_p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(p_chars); <span class="hljs-comment">// 将字符数组转换回字符串</span><br>        <span class="hljs-comment">//System.out.println(&quot;sorted_p: &quot; + sorted_p);</span><br><br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-keyword">while</span>(left &lt;= l - n)&#123;<br>            <span class="hljs-type">String</span> tmp = s.<span class="hljs-built_in">substring</span>(left, left + n);<br>            <span class="hljs-type">char</span>[] tmp_chars = tmp.<span class="hljs-built_in">toCharArray</span>(); <span class="hljs-comment">// 转换为字符数组</span><br>            Arrays.<span class="hljs-built_in">sort</span>(tmp_chars); <span class="hljs-comment">// 对字符数组进行排序</span><br>            <span class="hljs-type">String</span> sorted_tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(tmp_chars); <span class="hljs-comment">// 将字符数组转换回字符串</span><br>            <span class="hljs-comment">//System.out.println(&quot;sorted_tmp: &quot; + sorted_tmp);</span><br>            <span class="hljs-keyword">if</span>(sorted_tmp.<span class="hljs-built_in">equals</span>(sorted_p))&#123;<br>                result.<span class="hljs-built_in">add</span>(left);<br>            &#125;<br>            left += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560.和为 K 的子数组"></a>560.和为 K 的子数组</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Solution &#123;<br>    public int subarraySum(int[] nums, int k) &#123;<br>        Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> HashMap&lt;Integer, Integer&gt;();<br>        int <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        int result = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">length</span>;i++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[i];<br><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">sum</span> - k))&#123;<br>                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span> - k, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            result += <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">sum</span> - k);<br><br>            <br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">sum</span>))&#123;<br>                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span>, <span class="hljs-number">0</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">sum</span>, <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">sum</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>] || <span class="hljs-keyword">target</span> &gt; nums[nums.length - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; <span class="hljs-keyword">target</span>)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &gt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">target</span> &gt; nums[nums.length - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == <span class="hljs-keyword">target</span>)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &lt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(nums[mid] &gt; <span class="hljs-keyword">target</span>)</span></span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//暴力解法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                    nums<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>                &#125;<br>                i--;<br>                n--;<br>            &#125;<br>        &#125;<br>        return n;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//快慢指针法</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; n; fast ++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-keyword">val</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125; <br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//快慢指针</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Duplicates(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        Map&lt;Integer, Integer&gt; dict = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(!dict.contains<span class="hljs-constructor">Key(<span class="hljs-params">nums</span>[<span class="hljs-params">fast</span>])</span>)&#123;<br>                nums<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>                dict.put(nums<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零-1"><a href="#283-移动零-1" class="headerlink" title="283.移动零"></a>283.移动零</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//使用快慢指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> moveZeroes(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                nums[slow ++] = nums[fast];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(; slow &lt; n; slow ++)&#123;<br>            nums[slow] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//使用快慢指针</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean backspace<span class="hljs-constructor">Compare(String <span class="hljs-params">s</span>, String <span class="hljs-params">t</span>)</span> &#123;<br>        <span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span> s_arr = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br>        <span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span> t_arr = t.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><br>        <span class="hljs-keyword">if</span>(rebuild<span class="hljs-constructor">String(<span class="hljs-params">s_arr</span>)</span>.equals(rebuild<span class="hljs-constructor">String(<span class="hljs-params">t_arr</span>)</span>))&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//重建字符串函数</span><br>    String rebuild<span class="hljs-constructor">String(<span class="hljs-params">char</span>[] <span class="hljs-params">c</span>)</span>&#123;<br>        <span class="hljs-built_in">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> fast = <span class="hljs-number">0</span>; fast &lt; c.length; fast++)&#123;<br>            <span class="hljs-keyword">if</span>(c<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span> != <span class="hljs-character">&#x27;#&#x27;</span>)&#123;<br>                c<span class="hljs-literal">[<span class="hljs-identifier">slow</span><span class="hljs-operator">++</span>]</span> = c<span class="hljs-literal">[<span class="hljs-identifier">fast</span>]</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(slow &gt; <span class="hljs-number">0</span>)&#123;<br>                    slow--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">c</span>)</span>.substring(<span class="hljs-number">0</span>,slow);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//使用前后双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">sortedSquares</span>(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> end = nums.length;<br>       <span class="hljs-type">int</span>[] new_nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[end];<br>       <span class="hljs-type">int</span> i = end - <span class="hljs-number">1</span>;<br>       end --;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            new_nums[i--] = nums[start] * nums[start] &gt; nums[end] * nums[end] ? nums[start]*nums[start++] : nums[end]*nums[end--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> new_nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode Logs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>About ME</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p><strong>Yangyang Wang</strong></p><p><em><strong>2000-02 | 男 | 汉族 | 中共党员</strong></em><br>2000-02 | Male | Han Nationality | Full member of the CPC</p><p><strong>我的GitHub主页（我的开源项目）：<a href="https://github.com/TheWangYang">https://github.com/TheWangYang</a></strong><br>My GitHub HomePage : <a href="https://github.com/TheWangYang">https://github.com/TheWangYang</a></p><p><strong>我的CSDN主页（记录技术博客等）：<a href="https://blog.csdn.net/weixin_43749999">https://blog.csdn.net/weixin_43749999</a></strong><br>My Personal Blog(CSDN) Address : <a href="https://blog.csdn.net/weixin_43749999">https://blog.csdn.net/weixin_43749999</a></p><p><strong>我的Leetcode主页（我的刷题记录）：<a href="https://leetcode-cn.com/u/wyypersist">https://leetcode-cn.com/u/wyypersist</a></strong><br>My Leetcode HomePage ： <a href="https://leetcode-cn.com/u/wyypersist">https://leetcode-cn.com/u/wyypersist</a></p><h2 id="教育经历-Education"><a href="#教育经历-Education" class="headerlink" title="教育经历(Education)"></a>教育经历(Education)</h2><p><strong>&gt;硕士在读，西安交通大学（985&#x2F;211&#x2F;双一流），人工智能与机器人研究所（人工智能学院），电子信息（人工智能）专业，2022年9月-2025年6月</strong><br>Master Degree, Xi’an Jiaotong University, Institute of Artificial Intelligence and Robotics(IAIR), Electronic Information (Artificial Intelligence), September 2022 - June 2025</p><p><em>截止本页更新时，硕士阶段GPA排名及相关成绩情况学院还未公布</em><br><em>coming soon …</em></p><p><strong>&gt;学士学位，郑州大学（211&#x2F;双一流），网络空间安全学院，软件工程专业，2018年9月-2022年6月</strong><br>Bachelor Degree, Zhengzhou University, School of Cyberspace Security, Software Engineering, September 2018 - June 2022</p><p><strong>本科全阶段成绩GPA排名：14&#x2F;184（专业前7.6%）</strong><br>GPA of all undergraduate stages: 3.44 &#x2F; 4.00 (14&#x2F;184, top 7.6%)</p><p><strong>本科全阶段综合排名（包含竞赛&#x2F;专利&#x2F;软著等加分项）：9&#x2F;184（专业前4.89%）</strong><br>Comprehensive ranking of all undergraduate stages (including bonus points for competitions&#x2F;patents&#x2F;software, etc.): (9&#x2F;184, top 4.89%)</p><p><strong>保研至西安交通大学</strong><br>Entered Xi’an Jiaotong University through recommendation interview</p><h2 id="研究兴趣（Research-Interest）"><a href="#研究兴趣（Research-Interest）" class="headerlink" title="研究兴趣（Research Interest）"></a>研究兴趣（Research Interest）</h2><p><em><strong>计算机视觉</strong></em><br>Computer Vision</p><ul><li><strong>图片拼接&#x2F;融合（硕士前期阶段做过探索）</strong>, Image splicing&#x2F;fusion (explored in the early stage of master’s degree)</li><li><strong>工业领域缺陷检测（硕士阶段重点研究）</strong>, Defect detection in the industrial field (key research at the master’s level)</li><li><strong>神经网络场-NeRF（参加竞赛时做过一段时间探索，竞赛名次全球top13）</strong>, Neural Network Field-NeRF (I did some exploration for a while when I participated in the competition, and the competition ranked top 13 in the world)</li><li>…</li></ul><p><strong>机器学习大数据处理分析</strong><br>Machine Learning</p><h2 id="实习经历（Intern-Experience）"><a href="#实习经历（Intern-Experience）" class="headerlink" title="实习经历（Intern Experience）"></a>实习经历（Intern Experience）</h2><p><strong>&gt;计算机视觉算法工程师（实习），<a href="http://www.ukdq.com.cn/">南京悠阔电气有限公司</a>，2022年3月-2022年6月</strong><br>Computer Vision Algorithm Engineer(intern), <a href="http://www.ukdq.com.cn/">Nanjing Youkuo Electric Technology Co., Ltd.</a>, March 2022 - June 2022</p><ul><li><strong>与组内成员合作，对采集到的变压器表面部位图片进行数据标注、模型训练、获取onnx权重模型或tensorRT模型，并使用C++&#x2F;Python编写部署推理API。</strong> Cooperate with members of the group to annotate the collected images of the transformer surface, perform model training, obtain the onnx weight model or tensorRT model, and use C++&#x2F;Python to write and deploy the inference API.</li><li><strong>作为负责人，将部署在NVIDIA显卡上的算法移植到了寒武纪MLU卡上。</strong> As the person in charge, the algorithm deployed on the NVIDIA graphics card was ported to the Cambrian MLU card.</li><li><strong>主要使用寒武纪官方提供的docker镜像来加载部署验证环境。 首先对模型的pth权重进行量化，然后保存为.cambricon模型（Cambrian提供的离线格式模型）。 然后，使用寒武纪CNRT运行时库部署并加载离线模型，获取.so动态链接库，由业务端python脚本调用，完成批量图像推理。</strong> Mainly use the official docker image provided by Cambrian to load the deployment verification environment. First, quantize the pth weight, and then save it as a .cambricon model (offline model provided by Cambrian). Then, use the Cambrian CNRT runtime library to deploy and load the offline model to obtain the .so dynamic link library, which is called by the business-side python script to complete batch image reasoning.</li></ul><p><strong>&gt;coming soon…</strong></p><h2 id="项目经历（Project-Experience）"><a href="#项目经历（Project-Experience）" class="headerlink" title="项目经历（Project Experience）"></a>项目经历（Project Experience）</h2><h4 id="硕士阶段（截止目前）Master-Period-until-now"><a href="#硕士阶段（截止目前）Master-Period-until-now" class="headerlink" title="硕士阶段（截止目前）Master Period(until now)"></a>硕士阶段（截止目前）Master Period(until now)</h4><p><strong>&gt;缺陷检测算法软硬协同架构设计与系统集成-中国科技部-科技创新2030—“新一代人工智能”重大项目子课题 | 2021年10月-2023年10月</strong><br>Defect detection algorithm software and hardware collaborative architecture design and system integration-China Ministry of Science and Technology-Technological Innovation 2030-“New Generation Artificial Intelligence” major project sub-topic | October 2021-October 2023</p><ul><li><strong>项目简介：作为项目组的核心成员，主要负责支持成像与感知推理的检测、学习与决策系统设计与搭建、研究基于少样本学习的检测算法。前期工作主要是在自建数据集上使用较新的目标检测算法来验证和演示检测任务。我们提出了结合空间注意力机制的改进FCOS算法。目前工作主要集中在工业缺陷检测领域中利用异常样本较少和正常样本较多的无监督或半监督算法的研究（few-shot&#x2F;zero-shot）。</strong>, Project Introduction: As a core member of the project team, he is mainly responsible for supporting the detection of imaging and perceptual reasoning, the design and construction of learning and decision-making systems, and the research of detection algorithms based on few-shot learning. The preliminary work is mainly to use newer target detection algorithms on self-built data sets to verify and demonstrate detection tasks. We propose an improved FCOS algorithm combined with a spatial attention mechanism. Current work is mainly focused on the research of unsupervised or semi-supervised algorithms (few-shot&#x2F;zero-shot) that utilize fewer abnormal samples and more normal samples in the field of industrial defect detection.</li><li><strong>项目取得成果（Project Achieved Results）</strong></li><li><em><strong>IEEE Transactions on Instrumentation and Measurement(TIM, 二作&#x2F;second author, JCR Q1&#x2F;SCI Area 2) (在审, in process)</strong></em></li><li><strong>发明专利一项（二作，不含导师），“一种工业缺陷检测优化方法、系统、装置、设备及存储介质”</strong>, One invention patent (two works, excluding mentor), “an industrial defect detection optimization method, system, device, equipment and storage medium”</li><li><em><strong>more coming soon…</strong></em></li></ul><h4 id="本科阶段-Bachelor-Period"><a href="#本科阶段-Bachelor-Period" class="headerlink" title="本科阶段 Bachelor Period"></a>本科阶段 Bachelor Period</h4><p><strong>&gt;基于机器学习的智能医疗柜 | 2021年3月-2021年5月</strong>, Intelligent Medical Cabinet Based on Machine Learning | March 2021-May 2021</p><ul><li><strong>项目简介：作为负责人，我组织团队成员开发了“基于机器学习的智能医疗柜”深度学习项目，我主要负责Web端、APP端和后端算法模块的开发。在查阅了相关文献并结合自身能力后，我决定将算法分析分为：收集数据预处理、老人健康指标、大量数据输入分类器、获得结果并可视化。</strong>, As the person in charge, I organized team members to develop the “Smart Medical Cabinet Based on Machine Learning” deep learning project. I was mainly responsible for the development of the Web, APP and back-end algorithm modules. After reviewing relevant literature and combining my own abilities, I decided to divide the algorithm analysis into: collecting data preprocessing, elderly health indicators, inputting large amounts of data into the classifier, obtaining results and visualizing them.</li><li><strong>项目取得成果（Project Achieved Results）</strong></li><li><strong>该项目荣获2021年中国大学生计算机设计大赛河南省级赛三等奖</strong>, This project won the 2021 Chinese College Student Computer Design Competition Henan Provincial Third Prize.</li></ul><p><strong>&gt;SmartGloves智能数据手套 | 2020年5月-2020年9月</strong>, SmartGloves Intelligent Data Gloves | May 2020-September 2020</p><ul><li><strong>项目介绍：我作为团队核心成员完整参与了“SmartGloves智能数据手套”项目的研发过程，负责使用机器学习技术分析患者康复数据。该项目采用镜像疗法帮助患者进行手部康复。我将数据分析过程分为：收集数据、数据预处理、患者手指曲率回归预测、患者康复程度人工智能评估等步骤。</strong>, As a core member of the team, I fully participated in the research and development process of the “SmartGloves Intelligent Data Gloves” project, responsible for using machine learning technology to analyze patient rehabilitation data. This program uses mirror therapy to help patients with hand rehabilitation. I divide the data analysis process into the following steps: data collection, data preprocessing, patient finger curvature regression prediction, and artificial intelligence assessment of patient recovery.</li><li><strong>项目取得成果（Project Achieved Results）</strong></li><li><strong>该项目荣获第十四届ICAN国际创新创业大赛三等奖</strong>, This project won the third prize of the 14th ICAN International Innovation Entrepreneurship Competition.</li></ul><h2 id="荣誉和奖励（Honors-and-Awards）"><a href="#荣誉和奖励（Honors-and-Awards）" class="headerlink" title="荣誉和奖励（Honors and Awards）"></a>荣誉和奖励（Honors and Awards）</h2><h4 id="硕士阶段（截止目前）Master-Period-until-now-1"><a href="#硕士阶段（截止目前）Master-Period-until-now-1" class="headerlink" title="硕士阶段（截止目前）Master Period(until now)"></a>硕士阶段（截止目前）Master Period(until now)</h4><ul><li><p><strong>2023年全球人工智能技术创新大赛 GigaRendering 基于千兆像素稀疏图像的全新视角渲染算法II赛道 | 全球第13名 | 2023年6月</strong>, 2023 Global Artificial Intelligence Technology Innovation Contest-GigaRendering A New Perspective Rendering Algorithm Based on Gigapixel Sparse Images II Track | TOP20 | 2023.6</p></li><li><p><strong>2023年第十三届中兴捧月全球精英算法挑战赛-图像处理赛道 | 区域优胜奖（超分辨率方向赛题，来自世界各地的近1200名选手参加了本次比赛的图像处理子赛道，其中前60名有机会进入复赛） | 2023年5月</strong>, The 13th ZTE Pengyue Global Elite Challenge in 2023 - Image Processing Track | Regional Excellence Award(Super-Resolution direction competition questions, Nearly 1,200 people from all over the world participated in the image processing sub-track of this competition, and the top 60 of them have the opportunity to win the regional award) | 2023.5</p></li><li><p><strong>2023年“华为杯”第五届中国研究生人工智能创新大赛全国总决赛 | 国家级三等奖（前30%队伍获一、二、三等奖） | 2023年8月</strong>, 2023 “Huawei Cup” National Finals of the 5th China Postgraduate Artificial Intelligence Innovation Competition | Third Prize (30% chance of winning) | 2023.8</p></li><li><p><strong>2023年华为嵌入式软件大赛（实物组）西北赛区 | 第36名 | 2023年6月</strong>, 2023 Huawei Embedded Software Contest (Physical Group) Northwest Division | TOP36 | 2023.6</p></li><li><p><strong>2023年中国研究生电子设计大赛西北赛区技术赛道 | 西北赛区二等奖 | 2023年7月</strong>, 2023 China Postgraduate Electronic Design Competition Northwest Division Technology Track | Second Prize | 2023.7</p></li><li><p><strong>2023年中国研究生电子设计大赛西北赛区商业计划赛道 | 西北赛区二等奖 | 2023年7月</strong>, 2023 China Postgraduate Electronic Design Competition Northwest Division Business Plan Track | Second Prize | 2023.7</p></li><li><p><strong>2023年中国国际互联网+创新创业大赛西安交通大学校赛 | 银奖（前47%有望获得金奖、银奖、铜奖） | 2023年7月</strong>, 2023 China International Internet + Innovation and Entrepreneurship Competition Xi’an Jiaotong University School Competition | Silver Award (Second Prize, The top 47% are expected to win the bronze award, and the proportion of the silver award is even less) | 2023.7</p></li><li><p>…</p></li></ul><h4 id="本科阶段-Bachelor-Period-1"><a href="#本科阶段-Bachelor-Period-1" class="headerlink" title="本科阶段 Bachelor Period"></a>本科阶段 Bachelor Period</h4><ul><li><p><strong>第十届中国软件杯大学生软件设计大赛决赛 | 国家级三等奖 | 2021年5月</strong>, Finals of the 10th China Software Cup College Student Software Design Competition | Third Prize | 2021.5</p></li><li><p><strong>2020年中国大学生计算机大赛-微信小程序应用开发赛 | 二等奖 | 2020年7月</strong>, 2020 China University Computer Competition - WeChat Approval Application Development Raihua Shuangyai District | Second Prize | 2020.7</p></li><li><p><strong>2021年美国大学生数学建模竞赛 | H奖 | 2021年4月</strong>, 2021 American College Students Mathematics Modeling Competition | Second Prize | 2021.4</p></li><li><p><strong>2020年亚太地区大学生数学建模竞赛 | 国际二等奖 | 2021年1月</strong>, 2020 College Students Mathematics Modeling Competition | Second Prize | 2021.1</p></li><li><p><strong>第十四届ICAN国际创新创业大赛中国区总决赛 | 国家级三等奖 | 2020年12月</strong>, Chinese Finals of the 14th ICAN International Innovation and Entrepreneurship Competition | Third Prize | 2020.12</p></li><li><p><strong>第十四届ICAN国际创新创业大赛河南赛区 | 省级一等奖 | 2020年10月</strong>, Henan Division of the 14th ICAN International Innovation and Entrepreneurship Competition | First Prize | 2020.10</p></li><li><p><strong>2021年中国大学生计算机设计大赛河南省级赛 | 省级三等奖 | 2021年5月</strong>, 2021 China University of Computer Design Competition Henan Provincial | Third Prize | 2021.5</p></li><li><p><strong>2020-2021学年郑州大学二等奖学金 | 2021年12月</strong>, 2020-2021 Journal of Zhengzhou University | First-class Scholarship | 2021.12</p></li><li><p><strong>2020-2021学年郑州大学三好学生 | 2021年12月</strong>, 2020-2021 school year Zhengzhou University | Three good students | 2021.12</p></li><li><p><strong>2019-2020学年郑州大学一等奖学金 | 2020年12月</strong>, 2019-2020 Journal of Zhengzhou University | First-class Scholarship | 2020.12</p></li><li><p><strong>2019-2020学年郑州大学三好学生 | 2020年12月</strong>, 2019-2020 school year Zhengzhou University | Three good students | 2020.12</p></li><li><p><strong>2018-2019学年郑州大学二等奖学金 | 2019年12月</strong>, 2018-2019 Journal of Zhengzhou University | First-class Scholarship | 2019.12</p></li><li><p><strong>2018-2019学年郑州大学三好学生 | 2019年12月</strong>, 2018-2019 school year Zhengzhou University | Three good students | 2019.12</p></li></ul><h2 id="专业技能（Professional-Skill）"><a href="#专业技能（Professional-Skill）" class="headerlink" title="专业技能（Professional Skill）"></a>专业技能（Professional Skill）</h2><p><strong>语言：Java(用作web开发+后端开发等)、Python(用作深度学习任务+小型服务器系统快速实现+QT界面快速开发等)、C++(用作LeetCode等算法题)</strong>, Java (used for web development + back-end development, etc.), Python (used for deep learning tasks + rapid implementation of small server systems + rapid development of QT interface, etc.), C++ (used for algorithm questions such as LeetCode)</p><p>…</p><h2 id="综合素质（Comprehensive-Quality）"><a href="#综合素质（Comprehensive-Quality）" class="headerlink" title="综合素质（Comprehensive Quality）"></a>综合素质（Comprehensive Quality）</h2><h4 id="社区和组织经验（Community-and-Organizational-Experiences）"><a href="#社区和组织经验（Community-and-Organizational-Experiences）" class="headerlink" title="社区和组织经验（Community and Organizational Experiences）"></a>社区和组织经验（Community and Organizational Experiences）</h4><p><strong>硕士阶段（Master Period）</strong></p><p><strong>&gt;组织名称：…</strong>, Organization: coming soon…</p><ul><li><strong>主要工作：…</strong>: coming soon …</li></ul><p>…<br><strong>本科阶段（Bachelor Period）</strong></p><p><strong>&gt;组织名称：优课达（杭州）网络有限公司郑州大学北校区俱乐部 | 2019年10月-2020年10月</strong>, Organization: Youkeda (Hangzhou) Network Co., Ltd. Zhengzhou University North Campus Club | Oct 2019 - Oct 2020</p><ul><li><strong>主要工作：我作为俱乐部负责人，在阿里巴巴技术专家的指导下定期组织技术交流。俱乐部会员技术在原有水平上有了很大的提高。</strong>, I have currently served as the head of Zhengzhou University North Campus Club, and regularly organized technical exchanges under the guidance of  Alibaba technical experts.Club membership technology has been greatly improved in the original level.</li></ul><h4 id="英语能力（English-Ability）"><a href="#英语能力（English-Ability）" class="headerlink" title="英语能力（English Ability）"></a>英语能力（English Ability）</h4><p><strong>英语水平：CET-4：545，CET-6：501，雅思总分：6.5，在研究生一年级期末阶段完成了4次全英答辩</strong>, English Level: CET-4:545, CET-6:501, IELTS(total):6.5, Completed 4 English defenses at the end of the first year of graduate school</p><h4 id="其他（Others）"><a href="#其他（Others）" class="headerlink" title="其他（Others）"></a>其他（Others）</h4><p><strong>&gt;爱好：篮球（大学新生篮球赛二等奖）、电影、音乐、…</strong>, Hobbies: Basketball (College New Student Collection Second Prize), Films, Music, …</p><p><strong>&gt;我对待学习的态度非常认真，不解决问题不罢休，也正是因为自己的这样一份坚持，才得以在本科阶段顺利保研攻读硕士研究生，并帮助自己完成了很多事情</strong></p><h2 id="联系我（Contact-Me）"><a href="#联系我（Contact-Me）" class="headerlink" title="联系我（Contact Me）"></a>联系我（Contact Me）</h2><p><strong>Email:<a href="mailto:&#119;&#x79;&#x79;&#115;&#117;&#99;&#x63;&#101;&#x73;&#x73;&#50;&#48;&#x32;&#x30;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#x6d;">&#119;&#x79;&#x79;&#115;&#117;&#99;&#x63;&#101;&#x73;&#x73;&#50;&#48;&#x32;&#x30;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#x6d;</a></strong></p><p><strong>QQ: 844817943</strong></p><p><strong>Phone &amp; WeChat: 13803907433</strong></p><p><strong>地址：中国西安市西咸新区沣西新城西安交通大学创新港校区</strong>, Where am I now: Xi’an Jiaotong University Innovation Port Campus, Fengxi New City, Xixian New District, Xi’an City, China</p><p><strong>邮政编码：710100</strong>, Postal Code: 710100</p><p><em>This page was last updated on September 17, 2023.</em></p>]]></content>
    
  </entry>
  
  
  
</search>
